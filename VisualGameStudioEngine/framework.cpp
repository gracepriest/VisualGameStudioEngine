// framework.cpp
// Visual Game Studio Engine - Framework v1.0 / Engine v0.5
#include "pch.h"
#include "framework.h"

#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <queue>
#include <array>
#include <algorithm>
#include <cctype>
#include <string>
#include <cstring>
#include <cmath>
#include <fstream>
#include <functional>

// ============================================================================
// GLOBAL ENGINE STATE
// ============================================================================
namespace {
    EngineState g_engineState = ENGINE_STOPPED;
    unsigned long long g_frameCount = 0;
    float g_timeScale = 1.0f;
    float g_masterVolume = 1.0f;
    bool g_audioPaused = false;

    // Fixed timestep
    double g_fixedStep = 1.0 / 60.0;
    double g_accum = 0.0;

    // Asset root path
    char g_assetRoot[FW_PATH_MAX] = "";

    // Draw callback
    DrawCallback userDrawCallback = nullptr;

    // Managed Camera2D
    Camera2D g_camera = { {0, 0}, {0, 0}, 0.0f, 1.0f };
    int g_cameraFollowEntity = -1;

    // Enhanced Camera State
    struct CameraState {
        // Smooth follow
        Vector2 followTarget = { 0, 0 };
        float followLerp = 0.1f;          // 0-1, speed of follow
        bool followEnabled = false;

        // Deadzone
        float deadzoneWidth = 0;
        float deadzoneHeight = 0;
        bool deadzoneEnabled = false;

        // Look-ahead
        float lookaheadDistance = 0;
        float lookaheadSmoothing = 0.1f;
        Vector2 lookaheadVelocity = { 0, 0 };
        Vector2 currentLookahead = { 0, 0 };
        bool lookaheadEnabled = false;

        // Screen shake
        float shakeIntensity = 0;
        float shakeDuration = 0;
        float shakeTimer = 0;
        float shakeFrequency = 60.0f;     // oscillations per second
        float shakeDecay = 1.0f;          // 0-1, how fast it decays
        float shakeTime = 0;              // for noise sampling
        Vector2 shakeOffset = { 0, 0 };

        // Bounds
        float boundsMinX = 0, boundsMinY = 0;
        float boundsMaxX = 0, boundsMaxY = 0;
        bool boundsEnabled = false;

        // Zoom limits and transitions
        float minZoom = 0.1f;
        float maxZoom = 10.0f;
        float zoomFrom = 1.0f;
        float zoomTo = 1.0f;
        float zoomDuration = 0;
        float zoomTimer = 0;
        Vector2 zoomPivot = { 0, 0 };     // for ZoomAt
        bool zoomAtPivot = false;

        // Rotation transition
        float rotationFrom = 0;
        float rotationTo = 0;
        float rotationDuration = 0;
        float rotationTimer = 0;

        // Pan transition
        Vector2 panFrom = { 0, 0 };
        Vector2 panTo = { 0, 0 };
        float panDuration = 0;
        float panTimer = 0;
        bool panning = false;

        // Flash effect
        unsigned char flashR = 255, flashG = 255, flashB = 255, flashA = 255;
        float flashDuration = 0;
        float flashTimer = 0;
    };
    CameraState g_camState;

    // Debug overlay state
    bool g_debugEnabled = false;
    bool g_debugDrawBounds = true;
    bool g_debugDrawHierarchy = false;
    bool g_debugDrawStats = true;
}

// ============================================================================
// SOUND CACHE
// ============================================================================
namespace {
    struct SoundEntry {
        Sound snd{};
        bool valid = false;
        bool paused = false;
    };
    std::unordered_map<int, SoundEntry> g_sounds;
    int g_nextSound = 1;
}

// ============================================================================
// TEXTURE CACHE
// ============================================================================
namespace {
    std::string NormalizePath(std::string p) {
        std::replace(p.begin(), p.end(), '\\', '/');
        std::transform(p.begin(), p.end(), p.begin(),
            [](unsigned char c) { return (unsigned char)std::tolower(c); });
        return p;
    }

    std::string ResolveAssetPath(const char* path) {
        if (!path) return "";
        std::string p(path);
        if (g_assetRoot[0] != '\0' && p.length() > 0 && p[0] != '/' && p[1] != ':') {
            p = std::string(g_assetRoot) + "/" + p;
        }
        return NormalizePath(p);
    }

    struct TexEntry {
        Texture2D   tex{};
        int         refCount = 0;
        std::string path;
        bool        valid = false;
    };

    std::unordered_map<int, TexEntry> g_texByHandle;
    std::unordered_map<std::string, int> g_handleByTexPath;
    int g_nextTexHandle = 1;

    int AcquireTextureH_Internal(const char* cpath) {
        std::string path = ResolveAssetPath(cpath);
        auto it = g_handleByTexPath.find(path);
        if (it != g_handleByTexPath.end()) {
            g_texByHandle[it->second].refCount++;
            return it->second;
        }

        Texture2D t = LoadTexture(path.c_str());
        int h = g_nextTexHandle++;

        TexEntry e;
        e.tex = t;
        e.refCount = 1;
        e.path = path;
        e.valid = (t.id != 0);
        g_texByHandle[h] = e;
        g_handleByTexPath[path] = h;
        return h;
    }

    void ReleaseTextureH_Internal(int h) {
        auto it = g_texByHandle.find(h);
        if (it == g_texByHandle.end()) return;
        if (--it->second.refCount <= 0) {
            if (it->second.valid) UnloadTexture(it->second.tex);
            g_handleByTexPath.erase(it->second.path);
            g_texByHandle.erase(it);
        }
    }

    const Texture2D* GetTextureH_Internal(int h) {
        auto it = g_texByHandle.find(h);
        if (it == g_texByHandle.end() || !it->second.valid) return nullptr;
        return &it->second.tex;
    }
}

// ============================================================================
// FONT CACHE
// ============================================================================
namespace {
    struct FontEntry {
        Font        font{};
        int         refCount = 0;
        std::string key;
        bool        valid = false;
    };

    std::unordered_map<int, FontEntry> g_fontByHandle;
    std::unordered_map<std::string, int> g_handleByFontKey;
    int g_nextFontHandle = 1;

    std::string MakeFontKey(const std::string& path, int size) {
        return NormalizePath(path) + "|" + std::to_string(size);
    }

    int AcquireFontH_Internal(const char* cpath, int size) {
        std::string key = MakeFontKey(cpath ? cpath : "", size);
        auto it = g_handleByFontKey.find(key);
        if (it != g_handleByFontKey.end()) {
            g_fontByHandle[it->second].refCount++;
            return it->second;
        }

        std::string path = ResolveAssetPath(cpath);
        Font f = LoadFontEx(path.c_str(), size, nullptr, 0);
        int h = g_nextFontHandle++;

        FontEntry e;
        e.font = f;
        e.refCount = 1;
        e.key = key;
        e.valid = (f.texture.id != 0);
        g_fontByHandle[h] = e;
        g_handleByFontKey[key] = h;
        return h;
    }

    void ReleaseFontH_Internal(int h) {
        auto it = g_fontByHandle.find(h);
        if (it == g_fontByHandle.end()) return;
        if (--it->second.refCount <= 0) {
            if (it->second.valid) UnloadFont(it->second.font);
            g_handleByFontKey.erase(it->second.key);
            g_fontByHandle.erase(it);
        }
    }

    const Font* GetFontH_Internal(int h) {
        auto it = g_fontByHandle.find(h);
        if (it == g_fontByHandle.end() || !it->second.valid) return nullptr;
        return &it->second.font;
    }
}

// ============================================================================
// MUSIC CACHE
// ============================================================================
namespace {
    struct MusicEntry {
        Music       mus{};
        int         refCount = 0;
        std::string path;
        bool        valid = false;
        bool        playing = false;
    };

    std::unordered_map<int, MusicEntry> g_musByHandle;
    std::unordered_map<std::string, int> g_handleByMusPath;
    int g_nextMusicHandle = 1;

    int AcquireMusicH_Internal(const char* cpath) {
        std::string path = ResolveAssetPath(cpath);
        auto it = g_handleByMusPath.find(path);
        if (it != g_handleByMusPath.end()) {
            g_musByHandle[it->second].refCount++;
            return it->second;
        }

        Music m = LoadMusicStream(path.c_str());
        int h = g_nextMusicHandle++;

        MusicEntry e;
        e.mus = m;
        e.refCount = 1;
        e.path = path;
        e.valid = (m.ctxData != nullptr);
        e.playing = false;
        g_musByHandle[h] = e;
        g_handleByMusPath[path] = h;
        return h;
    }

    void ReleaseMusicH_Internal(int h) {
        auto it = g_musByHandle.find(h);
        if (it == g_musByHandle.end()) return;
        if (--it->second.refCount <= 0) {
            if (it->second.valid) {
                StopMusicStream(it->second.mus);
                UnloadMusicStream(it->second.mus);
            }
            g_handleByMusPath.erase(it->second.path);
            g_musByHandle.erase(it);
        }
    }

    Music* GetMusicH_Internal(int h) {
        auto it = g_musByHandle.find(h);
        if (it == g_musByHandle.end() || !it->second.valid) return nullptr;
        return &it->second.mus;
    }
}

// ============================================================================
// ECS CORE
// ============================================================================
namespace {
    using Entity = int;

    // Component structures
    struct Transform2D {
        Vector2 position{ 0.0f, 0.0f };
        float   rotation = 0.0f;
        Vector2 scale{ 1.0f, 1.0f };
    };

    struct Sprite2D {
        int       textureHandle = 0;
        Rectangle source{ 0, 0, 0, 0 };
        Color     tint{ 255, 255, 255, 255 };
        int       layer = 0;
        bool      visible = true;
    };

    struct NameComponent {
        char name[FW_NAME_MAX] = {0};
    };

    struct TagComponent {
        char tag[FW_TAG_MAX] = {0};
    };

    struct HierarchyComponent {
        int parent = -1;
        int firstChild = -1;
        int nextSibling = -1;
        int prevSibling = -1;
    };

    struct Velocity2D {
        float vx = 0.0f;
        float vy = 0.0f;
    };

    struct BoxCollider2D {
        float offsetX = 0.0f;
        float offsetY = 0.0f;
        float width = 0.0f;
        float height = 0.0f;
        bool isTrigger = false;
    };

    struct EnabledComponent {
        bool enabled = true;
    };

    // ========================================================================
    // TILESET (shared resource)
    // ========================================================================
    struct Tileset {
        int textureHandle = 0;
        int tileWidth = 16;
        int tileHeight = 16;
        int columns = 1;
        bool valid = false;
    };

    std::unordered_map<int, Tileset> g_tilesets;
    int g_nextTilesetHandle = 1;

    // ========================================================================
    // TILEMAP COMPONENT
    // ========================================================================
    struct TilemapComponent {
        int tilesetHandle = 0;
        int mapWidth = 0;
        int mapHeight = 0;
        std::vector<int> tiles;  // 2D grid stored as 1D, -1 = empty
        std::unordered_set<int> solidTiles;  // Which tile indices are solid
    };

    // ========================================================================
    // ANIMATION CLIP (shared resource)
    // ========================================================================
    struct AnimFrame {
        Rectangle source{0, 0, 0, 0};
        float duration = 0.1f;  // seconds
    };

    struct AnimClip {
        std::string name;
        std::vector<AnimFrame> frames;
        int loopMode = ANIM_LOOP_REPEAT;
        bool valid = false;
    };

    std::unordered_map<int, AnimClip> g_animClips;
    int g_nextAnimClipHandle = 1;

    // ========================================================================
    // ANIMATOR COMPONENT
    // ========================================================================
    struct AnimatorComponent {
        int clipHandle = 0;
        int currentFrame = 0;
        float timer = 0.0f;
        float speed = 1.0f;
        bool playing = false;
        bool pingpongReverse = false;  // For pingpong mode
    };

    // ========================================================================
    // PARTICLE EMITTER COMPONENT
    // ========================================================================
    struct Particle {
        float x, y;
        float vx, vy;
        float life;       // Remaining life
        float maxLife;    // Initial life (for lerping)
        float size;
        bool active = false;
    };

    // Color stop for gradient
    struct ColorStop {
        float time;  // 0-1 normalized
        Color color;
    };

    struct ParticleEmitterComponent {
        int textureHandle = 0;
        Rectangle sourceRect{0, 0, 0, 0};

        // Emission settings
        float emissionRate = 10.0f;  // particles per second
        float emissionAccum = 0.0f;  // accumulator for spawning
        int maxParticles = 100;

        // Particle properties
        float lifetimeMin = 1.0f;
        float lifetimeMax = 2.0f;
        float velocityMinX = -50.0f, velocityMinY = -100.0f;
        float velocityMaxX = 50.0f, velocityMaxY = -50.0f;
        Color colorStart{255, 255, 255, 255};
        Color colorEnd{255, 255, 255, 0};
        float sizeStart = 8.0f;
        float sizeEnd = 2.0f;
        float gravityX = 0.0f;
        float gravityY = 100.0f;
        float spreadAngle = 45.0f;  // Cone angle in degrees
        float directionX = 0.0f;
        float directionY = -1.0f;   // Default: upward

        // Enhanced: Emitter shape
        int shape = EMITTER_SHAPE_POINT;
        float shapeRadius = 0.0f;
        float shapeWidth = 0.0f;
        float shapeHeight = 0.0f;
        float shapeInnerRadius = 0.0f;
        float shapeLine[4] = {0, 0, 0, 0};
        bool edgeEmission = false;

        // Enhanced: Rotation/spin
        float rotationMin = 0.0f;
        float rotationMax = 0.0f;
        float spinMin = 0.0f;
        float spinMax = 0.0f;

        // Enhanced: Blend mode
        int blendMode = PARTICLE_BLEND_ALPHA;

        // Enhanced: Color gradient
        int colorStopCount = 2;
        ColorStop colorStops[4];

        // Enhanced: Size curve
        float sizeCurve[4] = {1.0f, 1.0f, 1.0f, 1.0f};
        bool useSizeCurve = false;

        // Enhanced: Velocity modifiers
        float drag = 0.0f;
        float accelX = 0.0f;
        float accelY = 0.0f;
        float radialAccel = 0.0f;
        float tangentialAccel = 0.0f;

        // Enhanced: Noise
        float noiseStrength = 0.0f;
        float noiseFrequency = 1.0f;
        float noiseScrollSpeed = 0.0f;
        float noiseOffset = 0.0f;

        // Enhanced: Sub-emitters
        int subEmitterOnDeath = -1;
        int subEmitterOnBirth = -1;

        // Enhanced: Trail
        bool trailEnabled = false;
        int trailLength = 5;
        float trailWidth = 2.0f;
        Color trailColor{255, 255, 255, 128};

        // Enhanced: Collision
        bool collisionEnabled = false;
        float collisionBounce = 0.5f;
        float collisionFriction = 0.1f;
        float collisionLifetimeLoss = 0.0f;
        bool collisionKill = false;

        // Enhanced: Animation
        int animColumns = 1;
        int animRows = 1;
        float animFPS = 10.0f;
        bool animRandomStart = false;
        bool randomTexture = false;
        int sortMode = 0;

        // State
        bool active = false;
        std::vector<Particle> particles;
    };

    // Particle attractor
    struct ParticleAttractor {
        int id;
        float x, y;
        float strength;
        float radius;
        float falloffPower;
    };
    static std::unordered_map<int, ParticleAttractor> g_particleAttractors;
    static int g_nextAttractorId = 1;
    static float g_particleGlobalTimeScale = 1.0f;

    // Entity storage
    int g_nextEntityId = 1;
    std::unordered_set<Entity> g_entities;
    std::unordered_map<Entity, Transform2D> g_transform2D;
    std::unordered_map<Entity, Sprite2D> g_sprite2D;
    std::unordered_map<Entity, NameComponent> g_name;
    std::unordered_map<Entity, TagComponent> g_tag;
    std::unordered_map<Entity, HierarchyComponent> g_hierarchy;
    std::unordered_map<Entity, Velocity2D> g_velocity2D;
    std::unordered_map<Entity, BoxCollider2D> g_boxCollider2D;
    std::unordered_map<Entity, EnabledComponent> g_enabled;
    std::unordered_map<Entity, TilemapComponent> g_tilemap;
    std::unordered_map<Entity, AnimatorComponent> g_animator;
    std::unordered_map<Entity, ParticleEmitterComponent> g_particleEmitter;

    // Helpers
    bool EcsIsAlive(Entity e) {
        return g_entities.find(e) != g_entities.end();
    }

    void RemoveFromParent(Entity e) {
        auto hIt = g_hierarchy.find(e);
        if (hIt == g_hierarchy.end()) return;

        HierarchyComponent& h = hIt->second;
        if (h.parent == -1) return;

        auto pIt = g_hierarchy.find(h.parent);
        if (pIt != g_hierarchy.end()) {
            if (pIt->second.firstChild == e) {
                pIt->second.firstChild = h.nextSibling;
            }
        }

        if (h.prevSibling != -1) {
            auto prevIt = g_hierarchy.find(h.prevSibling);
            if (prevIt != g_hierarchy.end()) {
                prevIt->second.nextSibling = h.nextSibling;
            }
        }
        if (h.nextSibling != -1) {
            auto nextIt = g_hierarchy.find(h.nextSibling);
            if (nextIt != g_hierarchy.end()) {
                nextIt->second.prevSibling = h.prevSibling;
            }
        }

        h.parent = -1;
        h.prevSibling = -1;
        h.nextSibling = -1;
    }

    void DestroyEntityRecursive(Entity e) {
        auto hIt = g_hierarchy.find(e);
        if (hIt != g_hierarchy.end()) {
            int child = hIt->second.firstChild;
            while (child != -1) {
                int next = -1;
                auto chIt = g_hierarchy.find(child);
                if (chIt != g_hierarchy.end()) {
                    next = chIt->second.nextSibling;
                }
                DestroyEntityRecursive(child);
                child = next;
            }
        }

        RemoveFromParent(e);
        g_entities.erase(e);
        g_transform2D.erase(e);
        g_sprite2D.erase(e);
        g_name.erase(e);
        g_tag.erase(e);
        g_hierarchy.erase(e);
        g_velocity2D.erase(e);
        g_boxCollider2D.erase(e);
        g_enabled.erase(e);
    }

    void EcsClearAllInternal() {
        g_entities.clear();
        g_transform2D.clear();
        g_sprite2D.clear();
        g_name.clear();
        g_tag.clear();
        g_hierarchy.clear();
        g_velocity2D.clear();
        g_boxCollider2D.clear();
        g_enabled.clear();
    }

    Vector2 GetWorldPositionInternal(Entity e) {
        auto tIt = g_transform2D.find(e);
        if (tIt == g_transform2D.end()) return Vector2{ 0, 0 };

        Vector2 pos = tIt->second.position;

        auto hIt = g_hierarchy.find(e);
        if (hIt != g_hierarchy.end() && hIt->second.parent != -1) {
            Vector2 parentPos = GetWorldPositionInternal(hIt->second.parent);
            pos.x += parentPos.x;
            pos.y += parentPos.y;
        }

        return pos;
    }

    float GetWorldRotationInternal(Entity e) {
        auto tIt = g_transform2D.find(e);
        if (tIt == g_transform2D.end()) return 0.0f;

        float rot = tIt->second.rotation;

        auto hIt = g_hierarchy.find(e);
        if (hIt != g_hierarchy.end() && hIt->second.parent != -1) {
            rot += GetWorldRotationInternal(hIt->second.parent);
        }

        return rot;
    }

    Vector2 GetWorldScaleInternal(Entity e) {
        auto tIt = g_transform2D.find(e);
        if (tIt == g_transform2D.end()) return Vector2{ 1, 1 };

        Vector2 scale = tIt->second.scale;

        auto hIt = g_hierarchy.find(e);
        if (hIt != g_hierarchy.end() && hIt->second.parent != -1) {
            Vector2 parentScale = GetWorldScaleInternal(hIt->second.parent);
            scale.x *= parentScale.x;
            scale.y *= parentScale.y;
        }

        return scale;
    }

    bool IsActiveInHierarchyInternal(Entity e) {
        auto enIt = g_enabled.find(e);
        if (enIt != g_enabled.end() && !enIt->second.enabled) return false;

        auto hIt = g_hierarchy.find(e);
        if (hIt != g_hierarchy.end() && hIt->second.parent != -1) {
            return IsActiveInHierarchyInternal(hIt->second.parent);
        }

        return true;
    }

    Rectangle GetBoxColliderWorldBoundsInternal(Entity e) {
        Rectangle result = { 0, 0, 0, 0 };

        auto bcIt = g_boxCollider2D.find(e);
        if (bcIt == g_boxCollider2D.end()) return result;

        Vector2 worldPos = GetWorldPositionInternal(e);
        Vector2 worldScale = GetWorldScaleInternal(e);

        result.x = worldPos.x + bcIt->second.offsetX * worldScale.x;
        result.y = worldPos.y + bcIt->second.offsetY * worldScale.y;
        result.width = bcIt->second.width * worldScale.x;
        result.height = bcIt->second.height * worldScale.y;

        return result;
    }

    // Draw sprites (layer sorted, respects enabled state)
    struct DrawItem {
        int         layer;
        Sprite2D*   sprite;
        Entity      entity;
    };

    void EcsDrawSpritesInternal() {
        if (g_sprite2D.empty()) return;

        std::vector<DrawItem> items;
        items.reserve(g_sprite2D.size());

        for (auto& kv : g_sprite2D) {
            Entity e = kv.first;
            Sprite2D& sp = kv.second;
            if (!sp.visible) continue;
            if (!EcsIsAlive(e)) continue;
            if (!IsActiveInHierarchyInternal(e)) continue;

            auto tIt = g_transform2D.find(e);
            if (tIt == g_transform2D.end()) continue;

            items.push_back(DrawItem{ sp.layer, &sp, e });
        }

        std::sort(items.begin(), items.end(),
            [](const DrawItem& a, const DrawItem& b) {
                return a.layer < b.layer;
            });

        for (auto& it : items) {
            Sprite2D* sp = it.sprite;

            const Texture2D* tex = GetTextureH_Internal(sp->textureHandle);
            if (!tex) continue;

            Vector2 worldPos = GetWorldPositionInternal(it.entity);
            float worldRot = GetWorldRotationInternal(it.entity);
            Vector2 worldScale = GetWorldScaleInternal(it.entity);

            Rectangle dst;
            dst.x = worldPos.x;
            dst.y = worldPos.y;
            dst.width = sp->source.width * worldScale.x;
            dst.height = sp->source.height * worldScale.y;

            Vector2 origin{ dst.width * 0.5f, dst.height * 0.5f };

            DrawTexturePro(*tex, sp->source, dst, origin, worldRot, sp->tint);
        }
    }
}

// ============================================================================
// SCENE SYSTEM
// ============================================================================
namespace {
    struct ScriptScene {
        SceneCallbacks cb{};
    };

    std::unordered_map<int, ScriptScene> g_scenes;
    std::vector<int> g_sceneStack;
    int g_nextSceneHandle = 1;

    ScriptScene* GetScene(int h) {
        auto it = g_scenes.find(h);
        return (it == g_scenes.end()) ? nullptr : &it->second;
    }

    ScriptScene* TopScene() {
        if (g_sceneStack.empty()) return nullptr;
        return GetScene(g_sceneStack.back());
    }

    // Scene Manager State
    struct SceneManagerState {
        // Transition settings
        SceneTransitionType transitionType = TRANSITION_FADE;
        TransitionEasing transitionEasing = EASE_IN_OUT_QUAD;
        float transitionDuration = 0.5f;
        Color transitionColor = { 0, 0, 0, 255 };  // Black by default

        // Transition runtime state
        TransitionState transitionState = TRANS_STATE_NONE;
        float transitionTimer = 0.0f;
        int pendingScene = -1;           // Scene to change to after transition out
        bool pendingIsPush = false;      // Is this a push or change?
        bool pendingIsPop = false;       // Is this a pop?

        // Loading screen
        bool loadingEnabled = false;
        float loadingMinDuration = 0.5f;
        float loadingTimer = 0.0f;
        float loadingProgress = 0.0f;
        LoadingCallback loadingCallback = nullptr;
        LoadingDrawCallback loadingDrawCallback = nullptr;

        // Preloading
        bool isPreloading = false;
        int preloadScene = -1;

        // Render texture for transition effects
        RenderTexture2D transitionRenderTexture = { 0 };
        bool renderTextureValid = false;
    };

    SceneManagerState g_sceneManager;

    // Easing functions
    float ApplyEasing(float t, TransitionEasing easing) {
        switch (easing) {
            case EASE_LINEAR:
                return t;
            case EASE_IN_QUAD:
                return t * t;
            case EASE_OUT_QUAD:
                return t * (2.0f - t);
            case EASE_IN_OUT_QUAD:
                return t < 0.5f ? 2.0f * t * t : -1.0f + (4.0f - 2.0f * t) * t;
            case EASE_IN_CUBIC:
                return t * t * t;
            case EASE_OUT_CUBIC: {
                float f = t - 1.0f;
                return f * f * f + 1.0f;
            }
            case EASE_IN_OUT_CUBIC:
                return t < 0.5f ? 4.0f * t * t * t : (t - 1.0f) * (2.0f * t - 2.0f) * (2.0f * t - 2.0f) + 1.0f;
            case EASE_IN_EXPO:
                return t == 0.0f ? 0.0f : powf(2.0f, 10.0f * (t - 1.0f));
            case EASE_OUT_EXPO:
                return t == 1.0f ? 1.0f : 1.0f - powf(2.0f, -10.0f * t);
            case EASE_IN_OUT_EXPO:
                if (t == 0.0f) return 0.0f;
                if (t == 1.0f) return 1.0f;
                if (t < 0.5f) return powf(2.0f, 20.0f * t - 10.0f) / 2.0f;
                return (2.0f - powf(2.0f, -20.0f * t + 10.0f)) / 2.0f;
            default:
                return t;
        }
    }

    // Initialize render texture for transitions if needed
    void EnsureTransitionRenderTexture() {
        if (!g_sceneManager.renderTextureValid) {
            int w = GetScreenWidth();
            int h = GetScreenHeight();
            if (w > 0 && h > 0) {
                g_sceneManager.transitionRenderTexture = LoadRenderTexture(w, h);
                g_sceneManager.renderTextureValid = true;
            }
        }
    }

    // Perform the actual scene switch
    void PerformSceneSwitch() {
        if (g_sceneManager.pendingIsPop) {
            // Pop operation
            if (!g_sceneStack.empty()) {
                if (auto sc = TopScene(); sc && sc->cb.onExit) sc->cb.onExit();
                g_sceneStack.pop_back();
                if (auto sc = TopScene(); sc && sc->cb.onResume) sc->cb.onResume();
            }
        }
        else if (g_sceneManager.pendingIsPush) {
            // Push operation
            g_sceneStack.push_back(g_sceneManager.pendingScene);
            if (auto sc = TopScene(); sc && sc->cb.onEnter) sc->cb.onEnter();
        }
        else {
            // Change operation
            if (!g_sceneStack.empty()) {
                if (auto sc = TopScene(); sc && sc->cb.onExit) sc->cb.onExit();
                g_sceneStack.pop_back();
            }
            g_sceneStack.push_back(g_sceneManager.pendingScene);
            if (auto sc = TopScene(); sc && sc->cb.onEnter) sc->cb.onEnter();
        }

        g_sceneManager.pendingScene = -1;
        g_sceneManager.pendingIsPush = false;
        g_sceneManager.pendingIsPop = false;
    }
}

// ============================================================================
// PREFAB STORAGE
// ============================================================================
namespace {
    struct PrefabData {
        std::vector<uint8_t> data;
        bool valid = false;
    };

    std::unordered_map<int, PrefabData> g_prefabs;
    int g_nextPrefabHandle = 1;
}

// Forward declarations
extern "C" void Framework_UpdateAllMusic();
extern "C" void Framework_ResourcesShutdown();

// ============================================================================
// ENGINE STATE & LIFECYCLE
// ============================================================================
extern "C" {

    bool Framework_Initialize(int width, int height, const char* title) {
        InitWindow(width, height, title);
        SetTargetFPS(60);
        g_engineState = ENGINE_RUNNING;
        g_frameCount = 0;
        g_timeScale = 1.0f;
        g_accum = 0.0;

        // Initialize camera
        g_camera.offset = Vector2{ (float)width / 2.0f, (float)height / 2.0f };
        g_camera.target = Vector2{ 0, 0 };
        g_camera.rotation = 0.0f;
        g_camera.zoom = 1.0f;

        return true;
    }

    void Framework_Update() {
        if (g_engineState == ENGINE_STOPPED) return;

        g_frameCount++;

        BeginDrawing();

        if (userDrawCallback != nullptr) {
            userDrawCallback();
        }

        EndDrawing();

        if (!g_audioPaused) {
            Framework_UpdateAllMusic();
        }

        // Only accumulate time if not paused
        if (g_engineState == ENGINE_RUNNING) {
            g_accum += (double)GetFrameTime() * g_timeScale;
        }
    }

    bool Framework_ShouldClose() {
        return WindowShouldClose() || g_engineState == ENGINE_QUITTING;
    }

    // Forward declarations for shutdown cleanup
    void Framework_Physics_DestroyAllBodies();
    void Framework_UI_DestroyAll();
    void Framework_Timer_CancelAll();
    void Framework_Tween_KillAll();
    void Framework_FSM_DestroyAll();
    void Framework_Pool_DestroyAll();
    void Framework_Batch_DestroyAll();
    void Framework_Atlas_DestroyAll();
    void Framework_SpriteSheet_DestroyAll();
    void Framework_Level_DestroyAll();
    void Framework_Net_Shutdown();
    void Framework_Lighting_Shutdown();
    void Framework_Effects_Shutdown();
    void Framework_Skeleton_DestroyAll();
    void Framework_Cmd_Shutdown();

    void Framework_Shutdown() {
        g_engineState = ENGINE_STOPPED;

        // Clean up all systems before shutting down
        Framework_Physics_DestroyAllBodies();  // Clear physics bodies
        Framework_UI_DestroyAll();             // Clear UI elements
        Framework_Timer_CancelAll();           // Cancel all timers
        Framework_Tween_KillAll();             // Kill all tweens
        Framework_FSM_DestroyAll();            // Destroy all FSMs
        Framework_Pool_DestroyAll();           // Destroy all object pools
        Framework_Batch_DestroyAll();          // Destroy all sprite batches
        Framework_Atlas_DestroyAll();          // Destroy all texture atlases
        Framework_SpriteSheet_DestroyAll();    // Destroy all sprite sheets
        Framework_Level_DestroyAll();          // Destroy all levels
        Framework_Net_Shutdown();              // Shutdown networking
        Framework_Lighting_Shutdown();         // Shutdown lighting
        Framework_Effects_Shutdown();          // Shutdown effects
        Framework_Skeleton_DestroyAll();       // Destroy all skeletons
        Framework_Cmd_Shutdown();              // Shutdown command console

        // Clear resources and ECS last
        Framework_ResourcesShutdown();
        EcsClearAllInternal();
        CloseWindow();
    }

    int Framework_GetState() {
        return (int)g_engineState;
    }

    void Framework_Pause() {
        if (g_engineState == ENGINE_RUNNING) {
            g_engineState = ENGINE_PAUSED;
        }
    }

    void Framework_Resume() {
        if (g_engineState == ENGINE_PAUSED) {
            g_engineState = ENGINE_RUNNING;
        }
    }

    void Framework_Quit() {
        g_engineState = ENGINE_QUITTING;
    }

    bool Framework_IsPaused() {
        return g_engineState == ENGINE_PAUSED;
    }

    // ========================================================================
    // DRAW CONTROL
    // ========================================================================
    void Framework_SetDrawCallback(DrawCallback callback) {
        userDrawCallback = callback;
    }

    void Framework_BeginDrawing() { BeginDrawing(); }
    void Framework_EndDrawing() { EndDrawing(); }

    void Framework_ClearBackground(unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        Color color = { r, g, b, a };
        ClearBackground(color);
    }

    void Framework_DrawText(const char* text, int x, int y, int fontSize,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        Color color = { r, g, b, a };
        DrawText(text, x, y, fontSize, color);
    }

    void Framework_DrawRectangle(int x, int y, int w, int h,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        Color color = { r, g, b, a };
        DrawRectangle(x, y, w, h, color);
    }

    // ========================================================================
    // TIMING
    // ========================================================================
    void   Framework_SetTargetFPS(int fps) { SetTargetFPS(fps); }
    float  Framework_GetFrameTime() { return GetFrameTime(); }
    float  Framework_GetDeltaTime() { return GetFrameTime() * g_timeScale; }
    double Framework_GetTime() { return GetTime(); }
    int    Framework_GetFPS() { return GetFPS(); }
    unsigned long long Framework_GetFrameCount() { return g_frameCount; }

    void  Framework_SetTimeScale(float scale) { g_timeScale = scale < 0.0f ? 0.0f : scale; }
    float Framework_GetTimeScale() { return g_timeScale; }

    void   Framework_SetFixedStep(double seconds) { g_fixedStep = seconds; }
    void   Framework_ResetFixedClock() { g_accum = 0.0; }

    bool Framework_StepFixed() {
        if (g_engineState != ENGINE_RUNNING) return false;
        if (g_accum >= g_fixedStep) {
            g_accum -= g_fixedStep;
            return true;
        }
        return false;
    }

    double Framework_GetFixedStep() { return g_fixedStep; }
    double Framework_GetAccumulator() { return g_accum; }

    // ========================================================================
    // INPUT - KEYBOARD
    // ========================================================================
    bool Framework_IsKeyPressed(int key) { return IsKeyPressed(key); }
    bool Framework_IsKeyPressedRepeat(int key) { return IsKeyPressedRepeat(key); }
    bool Framework_IsKeyDown(int key) { return IsKeyDown(key); }
    bool Framework_IsKeyReleased(int key) { return IsKeyReleased(key); }
    bool Framework_IsKeyUp(int key) { return IsKeyUp(key); }
    int  Framework_GetKeyPressed() { return GetKeyPressed(); }
    int  Framework_GetCharPressed() { return GetCharPressed(); }
    void Framework_SetExitKey(int key) { SetExitKey(key); }

    // ========================================================================
    // INPUT - MOUSE
    // ========================================================================
    int     Framework_GetMouseX() { return GetMouseX(); }
    int     Framework_GetMouseY() { return GetMouseY(); }
    bool    Framework_IsMouseButtonPressed(int b) { return IsMouseButtonPressed(b); }
    bool    Framework_IsMouseButtonDown(int b) { return IsMouseButtonDown(b); }
    bool    Framework_IsMouseButtonReleased(int b) { return IsMouseButtonReleased(b); }
    bool    Framework_IsMouseButtonUp(int b) { return IsMouseButtonUp(b); }
    Vector2 Framework_GetMousePosition() { return GetMousePosition(); }
    Vector2 Framework_GetMouseDelta() { return GetMouseDelta(); }
    void    Framework_SetMousePosition(int x, int y) { SetMousePosition(x, y); }
    void    Framework_SetMouseOffset(int ox, int oy) { SetMouseOffset(ox, oy); }
    void    Framework_SetMouseScale(float sx, float sy) { SetMouseScale(sx, sy); }
    float   Framework_GetMouseWheelMove() { return GetMouseWheelMove(); }
    Vector2 Framework_GetMouseWheelMoveV() { return GetMouseWheelMoveV(); }
    void    Framework_SetMouseCursor(int cursor) { SetMouseCursor(cursor); }

    void Framework_ShowCursor() { ShowCursor(); }
    void Framework_HideCursor() { HideCursor(); }
    bool Framework_IsCursorHidden() { return IsCursorHidden(); }
    void Framework_EnableCursor() { EnableCursor(); }
    void Framework_DisableCursor() { DisableCursor(); }
    bool Framework_IsCursorOnScreen() { return IsCursorOnScreen(); }

    // ========================================================================
    // SHAPES
    // ========================================================================
    void Framework_DrawPixel(int x, int y,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawPixel(x, y, Color{ r, g, b, a });
    }

    void Framework_DrawLine(int x0, int y0, int x1, int y1,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawLine(x0, y0, x1, y1, Color{ r, g, b, a });
    }

    void Framework_DrawCircle(int cx, int cy, float radius,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawCircle(cx, cy, radius, Color{ r, g, b, a });
    }

    void Framework_DrawCircleLines(int cx, int cy, float radius,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawCircleLines(cx, cy, radius, Color{ r, g, b, a });
    }

    void Framework_DrawRectangleLines(int x, int y, int w, int h,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawRectangleLines(x, y, w, h, Color{ r, g, b, a });
    }

    void Framework_DrawTriangle(int x1, int y1, int x2, int y2, int x3, int y3,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawTriangle(Vector2{ (float)x1, (float)y1 }, Vector2{ (float)x2, (float)y2 }, Vector2{ (float)x3, (float)y3 }, Color{ r, g, b, a });
    }

    void Framework_DrawTriangleLines(int x1, int y1, int x2, int y2, int x3, int y3,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawTriangleLines(Vector2{ (float)x1, (float)y1 }, Vector2{ (float)x2, (float)y2 }, Vector2{ (float)x3, (float)y3 }, Color{ r, g, b, a });
    }

    // ========================================================================
    // COLLISIONS
    // ========================================================================
    bool      Framework_CheckCollisionRecs(Rectangle a, Rectangle b) { return CheckCollisionRecs(a, b); }
    bool      Framework_CheckCollisionCircles(Vector2 c1, float r1, Vector2 c2, float r2) { return CheckCollisionCircles(c1, r1, c2, r2); }
    bool      Framework_CheckCollisionCircleRec(Vector2 c, float r, Rectangle rec) { return CheckCollisionCircleRec(c, r, rec); }
    bool      Framework_CheckCollisionCircleLine(Vector2 c, float r, Vector2 p1, Vector2 p2) { return CheckCollisionCircleLine(c, r, p1, p2); }
    bool      Framework_CheckCollisionPointRec(Vector2 p, Rectangle rec) { return CheckCollisionPointRec(p, rec); }
    bool      Framework_CheckCollisionPointCircle(Vector2 p, Vector2 c, float r) { return CheckCollisionPointCircle(p, c, r); }
    bool      Framework_CheckCollisionPointTriangle(Vector2 p, Vector2 p1, Vector2 p2, Vector2 p3) { return CheckCollisionPointTriangle(p, p1, p2, p3); }
    bool      Framework_CheckCollisionPointLine(Vector2 p, Vector2 p1, Vector2 p2, int thr) { return CheckCollisionPointLine(p, p1, p2, thr); }
    bool      Framework_CheckCollisionPointPoly(Vector2 p, const Vector2* pts, int n) { return CheckCollisionPointPoly(p, pts, n); }
    bool      Framework_CheckCollisionLines(Vector2 s1, Vector2 e1, Vector2 s2, Vector2 e2, Vector2* cp) {
        return CheckCollisionLines(s1, e1, s2, e2, cp);
    }
    Rectangle Framework_GetCollisionRec(Rectangle a, Rectangle b) { return GetCollisionRec(a, b); }

    // ========================================================================
    // TEXTURES / IMAGES
    // ========================================================================
    Texture2D Framework_LoadTexture(const char* fileName) {
        std::string path = ResolveAssetPath(fileName);
        return LoadTexture(path.c_str());
    }

    void Framework_UnloadTexture(Texture2D texture) { UnloadTexture(texture); }
    bool Framework_IsTextureValid(Texture2D texture) { return IsTextureValid(texture); }

    void Framework_UpdateTexture(Texture2D texture, const void* pixels) { UpdateTexture(texture, pixels); }
    void Framework_UpdateTextureRec(Texture2D texture, Rectangle rec, const void* pixels) { UpdateTextureRec(texture, rec, pixels); }
    void Framework_GenTextureMipmaps(Texture2D* texture) { GenTextureMipmaps(texture); }
    void Framework_SetTextureFilter(Texture2D texture, int filter) { SetTextureFilter(texture, filter); }
    void Framework_SetTextureWrap(Texture2D texture, int wrap) { SetTextureWrap(texture, wrap); }

    void Framework_DrawTexture(Texture2D texture, int posX, int posY,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawTexture(texture, posX, posY, Color{ r, g, b, a });
    }

    void Framework_DrawTextureV(Texture2D texture, Vector2 position,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawTextureV(texture, position, Color{ r, g, b, a });
    }

    void Framework_DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawTextureEx(texture, position, rotation, scale, Color{ r, g, b, a });
    }

    void Framework_DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawTextureRec(texture, source, position, Color{ r, g, b, a });
    }

    void Framework_DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin,
        float rotation, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawTexturePro(texture, source, dest, origin, rotation, Color{ r, g, b, a });
    }

    void Framework_DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin,
        float rotation, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawTextureNPatch(texture, nPatchInfo, dest, origin, rotation, Color{ r, g, b, a });
    }

    RenderTexture2D Framework_LoadRenderTexture(int width, int height) { return LoadRenderTexture(width, height); }
    void Framework_UnloadRenderTexture(RenderTexture2D target) { UnloadRenderTexture(target); }
    bool Framework_IsRenderTextureValid(RenderTexture2D target) { return IsRenderTextureValid(target); }
    void Framework_BeginTextureMode(RenderTexture2D rt) { BeginTextureMode(rt); }
    void Framework_EndTextureMode() { EndTextureMode(); }
    void Framework_BeginMode2D(Camera2D cam) { BeginMode2D(cam); }
    void Framework_EndMode2D() { EndMode2D(); }

    Image Framework_LoadImage(const char* fileName) {
        std::string path = ResolveAssetPath(fileName);
        return LoadImage(path.c_str());
    }
    void  Framework_UnloadImage(Image img) { UnloadImage(img); }
    void  Framework_ImageColorInvert(Image* img) { ImageColorInvert(img); }
    void  Framework_ImageResize(Image* img, int w, int h) { ImageResize(img, w, h); }
    void  Framework_ImageFlipVertical(Image* img) { ImageFlipVertical(img); }

    Font Framework_LoadFontEx(const char* fileName, int fontSize, int* glyphs, int glyphCount) {
        std::string path = ResolveAssetPath(fileName);
        return LoadFontEx(path.c_str(), fontSize, glyphs, glyphCount);
    }

    void Framework_UnloadFont(Font font) { UnloadFont(font); }

    void Framework_DrawTextEx(Font font, const char* text, Vector2 pos, float fontSize, float spacing,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        DrawTextEx(font, text, pos, fontSize, spacing, Color{ r, g, b, a });
    }

    Rectangle Framework_SpriteFrame(Rectangle sheetArea, int frameW, int frameH, int index, int columns) {
        Rectangle r{};
        r.x = sheetArea.x + (index % columns) * frameW;
        r.y = sheetArea.y + (index / columns) * frameH;
        r.width = (float)frameW;
        r.height = (float)frameH;
        return r;
    }

    void Framework_DrawFPS(int x, int y) { DrawFPS(x, y); }
    void Framework_DrawGrid(int slices, float spacing) { DrawGrid(slices, spacing); }

    // ========================================================================
    // CAMERA 2D (Managed)
    // ========================================================================
    void Framework_Camera_SetPosition(float x, float y) {
        g_camera.target = Vector2{ x, y };
    }

    void Framework_Camera_SetTarget(float x, float y) {
        g_camera.target = Vector2{ x, y };
    }

    void Framework_Camera_SetRotation(float rotation) {
        g_camera.rotation = rotation;
    }

    void Framework_Camera_SetZoom(float zoom) {
        g_camera.zoom = zoom < 0.01f ? 0.01f : zoom;
    }

    void Framework_Camera_SetOffset(float x, float y) {
        g_camera.offset = Vector2{ x, y };
    }

    Vector2 Framework_Camera_GetPosition() {
        return g_camera.target;
    }

    float Framework_Camera_GetZoom() {
        return g_camera.zoom;
    }

    float Framework_Camera_GetRotation() {
        return g_camera.rotation;
    }

    void Framework_Camera_FollowEntity(int entity) {
        g_cameraFollowEntity = entity;
    }

    void Framework_Camera_BeginMode() {
        // Update camera if following an entity
        if (g_cameraFollowEntity != -1 && EcsIsAlive(g_cameraFollowEntity)) {
            Vector2 pos = GetWorldPositionInternal(g_cameraFollowEntity);
            g_camera.target = pos;
        }
        BeginMode2D(g_camera);
    }

    void Framework_Camera_EndMode() {
        EndMode2D();
    }

    Vector2 Framework_Camera_ScreenToWorld(float screenX, float screenY) {
        return GetScreenToWorld2D(Vector2{ screenX, screenY }, g_camera);
    }

    Vector2 Framework_Camera_WorldToScreen(float worldX, float worldY) {
        return GetWorldToScreen2D(Vector2{ worldX, worldY }, g_camera);
    }

    // ========================================================================
    // CAMERA 2D (Enhanced)
    // ========================================================================

    // Easing function for smooth transitions
    static float EaseOutQuad(float t) {
        return t * (2.0f - t);
    }

    static float EaseInOutQuad(float t) {
        return t < 0.5f ? 2.0f * t * t : 1.0f - powf(-2.0f * t + 2.0f, 2.0f) / 2.0f;
    }

    // Simple noise function for shake
    static float ShakeNoise(float x) {
        // Simple pseudo-random based on sine
        return sinf(x * 12.9898f) * cosf(x * 78.233f);
    }

    // Smooth follow
    void Framework_Camera_SetFollowTarget(float x, float y) {
        g_camState.followTarget = Vector2{ x, y };
    }

    void Framework_Camera_SetFollowLerp(float lerpSpeed) {
        g_camState.followLerp = lerpSpeed < 0.0f ? 0.0f : (lerpSpeed > 1.0f ? 1.0f : lerpSpeed);
    }

    float Framework_Camera_GetFollowLerp() {
        return g_camState.followLerp;
    }

    void Framework_Camera_SetFollowEnabled(bool enabled) {
        g_camState.followEnabled = enabled;
    }

    bool Framework_Camera_IsFollowEnabled() {
        return g_camState.followEnabled;
    }

    // Deadzone
    void Framework_Camera_SetDeadzone(float width, float height) {
        g_camState.deadzoneWidth = width < 0 ? 0 : width;
        g_camState.deadzoneHeight = height < 0 ? 0 : height;
    }

    void Framework_Camera_GetDeadzone(float* width, float* height) {
        if (width) *width = g_camState.deadzoneWidth;
        if (height) *height = g_camState.deadzoneHeight;
    }

    void Framework_Camera_SetDeadzoneEnabled(bool enabled) {
        g_camState.deadzoneEnabled = enabled;
    }

    bool Framework_Camera_IsDeadzoneEnabled() {
        return g_camState.deadzoneEnabled;
    }

    // Look-ahead
    void Framework_Camera_SetLookahead(float distance, float smoothing) {
        g_camState.lookaheadDistance = distance;
        g_camState.lookaheadSmoothing = smoothing < 0.0f ? 0.0f : (smoothing > 1.0f ? 1.0f : smoothing);
    }

    void Framework_Camera_SetLookaheadEnabled(bool enabled) {
        g_camState.lookaheadEnabled = enabled;
        if (!enabled) {
            g_camState.currentLookahead = Vector2{ 0, 0 };
        }
    }

    void Framework_Camera_SetLookaheadVelocity(float vx, float vy) {
        g_camState.lookaheadVelocity = Vector2{ vx, vy };
    }

    // Screen shake
    void Framework_Camera_Shake(float intensity, float duration) {
        g_camState.shakeIntensity = intensity;
        g_camState.shakeDuration = duration;
        g_camState.shakeTimer = duration;
        g_camState.shakeFrequency = 60.0f;
        g_camState.shakeDecay = 1.0f;
    }

    void Framework_Camera_ShakeEx(float intensity, float duration, float frequency, float decay) {
        g_camState.shakeIntensity = intensity;
        g_camState.shakeDuration = duration;
        g_camState.shakeTimer = duration;
        g_camState.shakeFrequency = frequency > 0 ? frequency : 60.0f;
        g_camState.shakeDecay = decay < 0 ? 0 : (decay > 1 ? 1 : decay);
    }

    void Framework_Camera_StopShake() {
        g_camState.shakeTimer = 0;
        g_camState.shakeOffset = Vector2{ 0, 0 };
    }

    bool Framework_Camera_IsShaking() {
        return g_camState.shakeTimer > 0;
    }

    float Framework_Camera_GetShakeIntensity() {
        if (g_camState.shakeTimer <= 0) return 0;
        float progress = 1.0f - (g_camState.shakeTimer / g_camState.shakeDuration);
        float decay = 1.0f - (progress * g_camState.shakeDecay);
        return g_camState.shakeIntensity * decay;
    }

    // Bounds
    void Framework_Camera_SetBounds(float minX, float minY, float maxX, float maxY) {
        g_camState.boundsMinX = minX;
        g_camState.boundsMinY = minY;
        g_camState.boundsMaxX = maxX;
        g_camState.boundsMaxY = maxY;
    }

    void Framework_Camera_GetBounds(float* minX, float* minY, float* maxX, float* maxY) {
        if (minX) *minX = g_camState.boundsMinX;
        if (minY) *minY = g_camState.boundsMinY;
        if (maxX) *maxX = g_camState.boundsMaxX;
        if (maxY) *maxY = g_camState.boundsMaxY;
    }

    void Framework_Camera_SetBoundsEnabled(bool enabled) {
        g_camState.boundsEnabled = enabled;
    }

    bool Framework_Camera_IsBoundsEnabled() {
        return g_camState.boundsEnabled;
    }

    void Framework_Camera_ClearBounds() {
        g_camState.boundsEnabled = false;
        g_camState.boundsMinX = g_camState.boundsMinY = 0;
        g_camState.boundsMaxX = g_camState.boundsMaxY = 0;
    }

    // Zoom controls
    void Framework_Camera_SetZoomLimits(float minZoom, float maxZoom) {
        g_camState.minZoom = minZoom > 0.01f ? minZoom : 0.01f;
        g_camState.maxZoom = maxZoom > g_camState.minZoom ? maxZoom : g_camState.minZoom;
    }

    void Framework_Camera_ZoomTo(float targetZoom, float duration) {
        targetZoom = targetZoom < g_camState.minZoom ? g_camState.minZoom :
                    (targetZoom > g_camState.maxZoom ? g_camState.maxZoom : targetZoom);

        if (duration <= 0) {
            g_camera.zoom = targetZoom;
            g_camState.zoomTimer = 0;
        } else {
            g_camState.zoomFrom = g_camera.zoom;
            g_camState.zoomTo = targetZoom;
            g_camState.zoomDuration = duration;
            g_camState.zoomTimer = duration;
            g_camState.zoomAtPivot = false;
        }
    }

    void Framework_Camera_ZoomAt(float targetZoom, float worldX, float worldY, float duration) {
        targetZoom = targetZoom < g_camState.minZoom ? g_camState.minZoom :
                    (targetZoom > g_camState.maxZoom ? g_camState.maxZoom : targetZoom);

        g_camState.zoomFrom = g_camera.zoom;
        g_camState.zoomTo = targetZoom;
        g_camState.zoomDuration = duration > 0 ? duration : 0.001f;
        g_camState.zoomTimer = g_camState.zoomDuration;
        g_camState.zoomPivot = Vector2{ worldX, worldY };
        g_camState.zoomAtPivot = true;
    }

    // Rotation
    void Framework_Camera_RotateTo(float targetRotation, float duration) {
        if (duration <= 0) {
            g_camera.rotation = targetRotation;
            g_camState.rotationTimer = 0;
        } else {
            g_camState.rotationFrom = g_camera.rotation;
            g_camState.rotationTo = targetRotation;
            g_camState.rotationDuration = duration;
            g_camState.rotationTimer = duration;
        }
    }

    // Pan
    void Framework_Camera_PanTo(float worldX, float worldY, float duration) {
        if (duration <= 0) {
            g_camera.target = Vector2{ worldX, worldY };
            g_camState.panning = false;
            g_camState.panTimer = 0;
        } else {
            g_camState.panFrom = g_camera.target;
            g_camState.panTo = Vector2{ worldX, worldY };
            g_camState.panDuration = duration;
            g_camState.panTimer = duration;
            g_camState.panning = true;
        }
    }

    void Framework_Camera_PanBy(float deltaX, float deltaY, float duration) {
        float newX = g_camera.target.x + deltaX;
        float newY = g_camera.target.y + deltaY;
        Framework_Camera_PanTo(newX, newY, duration);
    }

    bool Framework_Camera_IsPanning() {
        return g_camState.panning && g_camState.panTimer > 0;
    }

    void Framework_Camera_StopPan() {
        g_camState.panning = false;
        g_camState.panTimer = 0;
    }

    // Flash effect
    void Framework_Camera_Flash(unsigned char r, unsigned char g, unsigned char b, unsigned char a, float duration) {
        g_camState.flashR = r;
        g_camState.flashG = g;
        g_camState.flashB = b;
        g_camState.flashA = a;
        g_camState.flashDuration = duration;
        g_camState.flashTimer = duration;
    }

    bool Framework_Camera_IsFlashing() {
        return g_camState.flashTimer > 0;
    }

    void Framework_Camera_DrawFlash() {
        if (g_camState.flashTimer <= 0) return;

        float alpha = g_camState.flashTimer / g_camState.flashDuration;
        unsigned char a = (unsigned char)(g_camState.flashA * alpha);

        DrawRectangle(0, 0, GetScreenWidth(), GetScreenHeight(),
            Color{ g_camState.flashR, g_camState.flashG, g_camState.flashB, a });
    }

    // Camera update - call each frame
    void Framework_Camera_Update(float dt) {
        Vector2 targetPos = g_camera.target;

        // Handle entity follow (legacy support)
        if (g_cameraFollowEntity != -1 && EcsIsAlive(g_cameraFollowEntity)) {
            Vector2 entityPos = GetWorldPositionInternal(g_cameraFollowEntity);
            g_camState.followTarget = entityPos;
            g_camState.followEnabled = true;
        }

        // Smooth follow with optional deadzone
        if (g_camState.followEnabled) {
            Vector2 diff = {
                g_camState.followTarget.x - targetPos.x,
                g_camState.followTarget.y - targetPos.y
            };

            // Apply deadzone if enabled
            if (g_camState.deadzoneEnabled) {
                float halfW = g_camState.deadzoneWidth / 2.0f;
                float halfH = g_camState.deadzoneHeight / 2.0f;

                if (fabsf(diff.x) < halfW) diff.x = 0;
                else diff.x -= (diff.x > 0 ? halfW : -halfW);

                if (fabsf(diff.y) < halfH) diff.y = 0;
                else diff.y -= (diff.y > 0 ? halfH : -halfH);
            }

            // Apply look-ahead if enabled
            if (g_camState.lookaheadEnabled && g_camState.lookaheadDistance > 0) {
                float velLen = sqrtf(g_camState.lookaheadVelocity.x * g_camState.lookaheadVelocity.x +
                                    g_camState.lookaheadVelocity.y * g_camState.lookaheadVelocity.y);
                if (velLen > 0.1f) {
                    Vector2 targetLookahead = {
                        (g_camState.lookaheadVelocity.x / velLen) * g_camState.lookaheadDistance,
                        (g_camState.lookaheadVelocity.y / velLen) * g_camState.lookaheadDistance
                    };
                    // Smooth the lookahead
                    g_camState.currentLookahead.x += (targetLookahead.x - g_camState.currentLookahead.x) * g_camState.lookaheadSmoothing;
                    g_camState.currentLookahead.y += (targetLookahead.y - g_camState.currentLookahead.y) * g_camState.lookaheadSmoothing;
                } else {
                    // Decay lookahead when stopped
                    g_camState.currentLookahead.x *= 0.95f;
                    g_camState.currentLookahead.y *= 0.95f;
                }
                diff.x += g_camState.currentLookahead.x;
                diff.y += g_camState.currentLookahead.y;
            }

            // Lerp towards target
            targetPos.x += diff.x * g_camState.followLerp;
            targetPos.y += diff.y * g_camState.followLerp;
        }

        // Pan transition (overrides follow while active)
        if (g_camState.panning && g_camState.panTimer > 0) {
            g_camState.panTimer -= dt;
            if (g_camState.panTimer <= 0) {
                targetPos = g_camState.panTo;
                g_camState.panning = false;
            } else {
                float t = 1.0f - (g_camState.panTimer / g_camState.panDuration);
                t = EaseInOutQuad(t);
                targetPos.x = g_camState.panFrom.x + (g_camState.panTo.x - g_camState.panFrom.x) * t;
                targetPos.y = g_camState.panFrom.y + (g_camState.panTo.y - g_camState.panFrom.y) * t;
            }
        }

        // Zoom transition
        if (g_camState.zoomTimer > 0) {
            g_camState.zoomTimer -= dt;
            float t = 1.0f - (g_camState.zoomTimer / g_camState.zoomDuration);
            t = EaseOutQuad(t);

            float newZoom = g_camState.zoomFrom + (g_camState.zoomTo - g_camState.zoomFrom) * t;

            // If zooming at a pivot point, adjust target to keep pivot stable
            if (g_camState.zoomAtPivot && g_camState.zoomTimer > 0) {
                Vector2 screenPivot = GetWorldToScreen2D(g_camState.zoomPivot, g_camera);
                g_camera.zoom = newZoom;
                Vector2 newWorldPivot = GetScreenToWorld2D(screenPivot, g_camera);
                targetPos.x += g_camState.zoomPivot.x - newWorldPivot.x;
                targetPos.y += g_camState.zoomPivot.y - newWorldPivot.y;
            } else {
                g_camera.zoom = newZoom;
            }

            if (g_camState.zoomTimer <= 0) {
                g_camera.zoom = g_camState.zoomTo;
            }
        }

        // Rotation transition
        if (g_camState.rotationTimer > 0) {
            g_camState.rotationTimer -= dt;
            float t = 1.0f - (g_camState.rotationTimer / g_camState.rotationDuration);
            t = EaseInOutQuad(t);
            g_camera.rotation = g_camState.rotationFrom + (g_camState.rotationTo - g_camState.rotationFrom) * t;

            if (g_camState.rotationTimer <= 0) {
                g_camera.rotation = g_camState.rotationTo;
            }
        }

        // Apply bounds constraints
        if (g_camState.boundsEnabled) {
            // Calculate visible area in world coords
            float viewW = (float)GetScreenWidth() / g_camera.zoom;
            float viewH = (float)GetScreenHeight() / g_camera.zoom;
            float halfW = viewW / 2.0f;
            float halfH = viewH / 2.0f;

            // Clamp target to keep view within bounds
            float boundsW = g_camState.boundsMaxX - g_camState.boundsMinX;
            float boundsH = g_camState.boundsMaxY - g_camState.boundsMinY;

            if (viewW < boundsW) {
                if (targetPos.x - halfW < g_camState.boundsMinX)
                    targetPos.x = g_camState.boundsMinX + halfW;
                if (targetPos.x + halfW > g_camState.boundsMaxX)
                    targetPos.x = g_camState.boundsMaxX - halfW;
            } else {
                targetPos.x = (g_camState.boundsMinX + g_camState.boundsMaxX) / 2.0f;
            }

            if (viewH < boundsH) {
                if (targetPos.y - halfH < g_camState.boundsMinY)
                    targetPos.y = g_camState.boundsMinY + halfH;
                if (targetPos.y + halfH > g_camState.boundsMaxY)
                    targetPos.y = g_camState.boundsMaxY - halfH;
            } else {
                targetPos.y = (g_camState.boundsMinY + g_camState.boundsMaxY) / 2.0f;
            }
        }

        // Screen shake
        g_camState.shakeOffset = Vector2{ 0, 0 };
        if (g_camState.shakeTimer > 0) {
            g_camState.shakeTimer -= dt;
            g_camState.shakeTime += dt;

            if (g_camState.shakeTimer > 0) {
                float progress = 1.0f - (g_camState.shakeTimer / g_camState.shakeDuration);
                float decay = 1.0f - (progress * g_camState.shakeDecay);
                float currentIntensity = g_camState.shakeIntensity * decay;

                // Use noise-based shake for more natural feel
                float t = g_camState.shakeTime * g_camState.shakeFrequency;
                g_camState.shakeOffset.x = ShakeNoise(t) * currentIntensity;
                g_camState.shakeOffset.y = ShakeNoise(t + 100.0f) * currentIntensity;
            }
        }

        // Apply final position with shake offset
        g_camera.target.x = targetPos.x + g_camState.shakeOffset.x;
        g_camera.target.y = targetPos.y + g_camState.shakeOffset.y;

        // Update flash
        if (g_camState.flashTimer > 0) {
            g_camState.flashTimer -= dt;
        }
    }

    // Reset camera to defaults
    void Framework_Camera_Reset() {
        g_camera.target = Vector2{ 0, 0 };
        g_camera.offset = Vector2{ (float)GetScreenWidth() / 2.0f, (float)GetScreenHeight() / 2.0f };
        g_camera.rotation = 0;
        g_camera.zoom = 1.0f;
        g_cameraFollowEntity = -1;
        g_camState = CameraState{};
    }

    // ========================================================================
    // AUDIO
    // ========================================================================
    bool Framework_InitAudio() {
        InitAudioDevice();
        return IsAudioDeviceReady();
    }

    void Framework_CloseAudio() {
        for (auto& kv : g_sounds) {
            if (kv.second.valid) UnloadSound(kv.second.snd);
        }
        g_sounds.clear();
        CloseAudioDevice();
    }

    void Framework_SetMasterVolume(float volume) {
        g_masterVolume = volume < 0.0f ? 0.0f : (volume > 1.0f ? 1.0f : volume);
        SetMasterVolume(g_masterVolume);
    }

    float Framework_GetMasterVolume() {
        return g_masterVolume;
    }

    void Framework_PauseAllAudio() {
        g_audioPaused = true;
        for (auto& kv : g_sounds) {
            if (kv.second.valid && IsSoundPlaying(kv.second.snd)) {
                PauseSound(kv.second.snd);
                kv.second.paused = true;
            }
        }
        for (auto& kv : g_musByHandle) {
            if (kv.second.playing) {
                PauseMusicStream(kv.second.mus);
            }
        }
    }

    void Framework_ResumeAllAudio() {
        g_audioPaused = false;
        for (auto& kv : g_sounds) {
            if (kv.second.valid && kv.second.paused) {
                ResumeSound(kv.second.snd);
                kv.second.paused = false;
            }
        }
        for (auto& kv : g_musByHandle) {
            if (kv.second.playing) {
                ResumeMusicStream(kv.second.mus);
            }
        }
    }

    int Framework_LoadSoundH(const char* file) {
        std::string path = ResolveAssetPath(file);
        Sound s = LoadSound(path.c_str());
        int id = g_nextSound++;
        SoundEntry entry;
        entry.snd = s;
        entry.valid = IsSoundValid(s);
        entry.paused = false;
        g_sounds[id] = entry;
        return id;
    }

    void Framework_UnloadSoundH(int h) {
        auto it = g_sounds.find(h);
        if (it != g_sounds.end()) {
            if (it->second.valid) UnloadSound(it->second.snd);
            g_sounds.erase(it);
        }
    }

    void Framework_PlaySoundH(int h) {
        auto it = g_sounds.find(h);
        if (it != g_sounds.end() && it->second.valid && !g_audioPaused) {
            PlaySound(it->second.snd);
        }
    }
    void Framework_StopSoundH(int h) { auto it = g_sounds.find(h); if (it != g_sounds.end() && it->second.valid) StopSound(it->second.snd); }
    void Framework_PauseSoundH(int h) { auto it = g_sounds.find(h); if (it != g_sounds.end() && it->second.valid) PauseSound(it->second.snd); }
    void Framework_ResumeSoundH(int h) { auto it = g_sounds.find(h); if (it != g_sounds.end() && it->second.valid) ResumeSound(it->second.snd); }
    void Framework_SetSoundVolumeH(int h, float v) { auto it = g_sounds.find(h); if (it != g_sounds.end() && it->second.valid) SetSoundVolume(it->second.snd, v); }
    void Framework_SetSoundPitchH(int h, float p) { auto it = g_sounds.find(h); if (it != g_sounds.end() && it->second.valid) SetSoundPitch(it->second.snd, p); }
    void Framework_SetSoundPanH(int h, float pan) { auto it = g_sounds.find(h); if (it != g_sounds.end() && it->second.valid) SetSoundPan(it->second.snd, pan); }

    // Music
    int  Framework_AcquireMusicH(const char* path) { return AcquireMusicH_Internal(path); }
    void Framework_ReleaseMusicH(int handle) { ReleaseMusicH_Internal(handle); }
    bool Framework_IsMusicValidH(int handle) { return GetMusicH_Internal(handle) != nullptr; }

    void Framework_PlayMusicH(int handle) {
        Music* m = GetMusicH_Internal(handle);
        if (m && !g_audioPaused) {
            PlayMusicStream(*m);
            g_musByHandle[handle].playing = true;
        }
    }

    void Framework_StopMusicH(int handle) {
        Music* m = GetMusicH_Internal(handle);
        if (m) {
            StopMusicStream(*m);
            g_musByHandle[handle].playing = false;
        }
    }

    void Framework_PauseMusicH(int handle) {
        Music* m = GetMusicH_Internal(handle);
        if (m) {
            PauseMusicStream(*m);
        }
    }

    void Framework_ResumeMusicH(int handle) {
        Music* m = GetMusicH_Internal(handle);
        if (m && !g_audioPaused) {
            ResumeMusicStream(*m);
        }
    }

    void Framework_SetMusicVolumeH(int handle, float v) {
        Music* m = GetMusicH_Internal(handle);
        if (m) SetMusicVolume(*m, v);
    }

    void Framework_SetMusicPitchH(int handle, float p) {
        Music* m = GetMusicH_Internal(handle);
        if (m) SetMusicPitch(*m, p);
    }

    void Framework_UpdateMusicH(int handle) {
        Music* m = GetMusicH_Internal(handle);
        if (m) UpdateMusicStream(*m);
    }

    void Framework_UpdateAllMusic() {
        if (g_audioPaused) return;
        for (auto& kv : g_musByHandle) {
            if (kv.second.playing) {
                UpdateMusicStream(kv.second.mus);
            }
        }
    }

    // ========================================================================
    // SHADERS
    // ========================================================================
    Shader Framework_LoadShaderF(const char* vsPath, const char* fsPath) {
        std::string vs = vsPath ? ResolveAssetPath(vsPath) : "";
        std::string fs = fsPath ? ResolveAssetPath(fsPath) : "";
        return LoadShader(vs.empty() ? nullptr : vs.c_str(), fs.empty() ? nullptr : fs.c_str());
    }

    void   Framework_UnloadShader(Shader sh) { UnloadShader(sh); }
    void   Framework_BeginShaderMode(Shader sh) { BeginShaderMode(sh); }
    void   Framework_EndShaderMode() { EndShaderMode(); }
    int    Framework_GetShaderLocation(Shader sh, const char* name) { return GetShaderLocation(sh, name); }

    void Framework_SetShaderValue1f(Shader sh, int loc, float v) {
        SetShaderValue(sh, loc, &v, SHADER_UNIFORM_FLOAT);
    }
    void Framework_SetShaderValue2f(Shader sh, int loc, float x, float y) {
        float a[2]{ x, y };
        SetShaderValue(sh, loc, a, SHADER_UNIFORM_VEC2);
    }
    void Framework_SetShaderValue3f(Shader sh, int loc, float x, float y, float z) {
        float a[3]{ x, y, z };
        SetShaderValue(sh, loc, a, SHADER_UNIFORM_VEC3);
    }
    void Framework_SetShaderValue4f(Shader sh, int loc, float x, float y, float z, float w) {
        float a[4]{ x, y, z, w };
        SetShaderValue(sh, loc, a, SHADER_UNIFORM_VEC4);
    }
    void Framework_SetShaderValue1i(Shader sh, int loc, int v) {
        SetShaderValue(sh, loc, &v, SHADER_UNIFORM_INT);
    }

    // ========================================================================
    // ASSET CACHE
    // ========================================================================
    void Framework_SetAssetRoot(const char* path) {
        if (path) {
            strncpy_s(g_assetRoot, FW_PATH_MAX, path, _TRUNCATE);
        } else {
            g_assetRoot[0] = '\0';
        }
    }

    const char* Framework_GetAssetRoot() {
        return g_assetRoot;
    }

    int  Framework_AcquireTextureH(const char* path) { return AcquireTextureH_Internal(path); }
    void Framework_ReleaseTextureH(int handle) { ReleaseTextureH_Internal(handle); }
    bool Framework_IsTextureValidH(int handle) { return GetTextureH_Internal(handle) != nullptr; }

    void Framework_DrawTextureH(int handle, int x, int y,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        const Texture2D* tex = GetTextureH_Internal(handle);
        if (tex) DrawTexture(*tex, x, y, Color{ r, g, b, a });
    }

    void Framework_DrawTextureVH(int handle, Vector2 pos,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        const Texture2D* tex = GetTextureH_Internal(handle);
        if (tex) DrawTextureV(*tex, pos, Color{ r, g, b, a });
    }

    void Framework_DrawTextureExH(int handle, Vector2 pos, float rotation, float scale,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        const Texture2D* tex = GetTextureH_Internal(handle);
        if (tex) DrawTextureEx(*tex, pos, rotation, scale, Color{ r, g, b, a });
    }

    void Framework_DrawTextureRecH(int handle, Rectangle src, Vector2 pos,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        const Texture2D* tex = GetTextureH_Internal(handle);
        if (tex) DrawTextureRec(*tex, src, pos, Color{ r, g, b, a });
    }

    void Framework_DrawTextureProH(int handle, Rectangle src, Rectangle dst, Vector2 origin, float rotation,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        const Texture2D* tex = GetTextureH_Internal(handle);
        if (tex) DrawTexturePro(*tex, src, dst, origin, rotation, Color{ r, g, b, a });
    }

    int Framework_GetTextureWidth(int handle) {
        const Texture2D* tex = GetTextureH_Internal(handle);
        return tex ? tex->width : 0;
    }

    int Framework_GetTextureHeight(int handle) {
        const Texture2D* tex = GetTextureH_Internal(handle);
        return tex ? tex->height : 0;
    }

    int  Framework_AcquireFontH(const char* path, int fontSize) { return AcquireFontH_Internal(path, fontSize); }
    void Framework_ReleaseFontH(int handle) { ReleaseFontH_Internal(handle); }
    bool Framework_IsFontValidH(int handle) { return GetFontH_Internal(handle) != nullptr; }

    void Framework_DrawTextExH(int handle, const char* text, Vector2 pos, float fontSize, float spacing,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        const Font* f = GetFontH_Internal(handle);
        if (f) DrawTextEx(*f, text, pos, fontSize, spacing, Color{ r, g, b, a });
    }

    // ========================================================================
    // SCENE SYSTEM
    // ========================================================================
    int Framework_CreateScriptScene(SceneCallbacks cb) {
        int h = g_nextSceneHandle++;
        g_scenes[h] = ScriptScene{ cb };
        return h;
    }

    void Framework_DestroyScene(int sceneHandle) {
        for (int i = (int)g_sceneStack.size() - 1; i >= 0; --i) {
            if (g_sceneStack[i] == sceneHandle) {
                if (i == (int)g_sceneStack.size() - 1) {
                    if (auto sc = GetScene(sceneHandle); sc && sc->cb.onExit) {
                        sc->cb.onExit();
                    }
                }
                g_sceneStack.erase(g_sceneStack.begin() + i);
            }
        }
        g_scenes.erase(sceneHandle);
    }

    void Framework_SceneChange(int sceneHandle) {
        if (!g_sceneStack.empty()) {
            if (auto sc = TopScene(); sc && sc->cb.onExit) sc->cb.onExit();
            g_sceneStack.pop_back();
        }
        g_sceneStack.push_back(sceneHandle);
        if (auto sc = TopScene(); sc && sc->cb.onEnter) sc->cb.onEnter();
    }

    void Framework_ScenePush(int sceneHandle) {
        g_sceneStack.push_back(sceneHandle);
        if (auto sc = TopScene(); sc && sc->cb.onEnter) sc->cb.onEnter();
    }

    void Framework_ScenePop() {
        if (g_sceneStack.empty()) return;
        if (auto sc = TopScene(); sc && sc->cb.onExit) sc->cb.onExit();
        g_sceneStack.pop_back();
        if (auto sc = TopScene(); sc && sc->cb.onResume) sc->cb.onResume();
    }

    bool Framework_SceneHas() {
        return !g_sceneStack.empty();
    }

    int Framework_SceneGetCurrent() {
        return g_sceneStack.empty() ? -1 : g_sceneStack.back();
    }

    void Framework_SceneTick() {
        if (g_engineState == ENGINE_RUNNING) {
            while (Framework_StepFixed()) {
                auto sc = TopScene();
                if (!sc) return;
                if (sc->cb.onUpdateFixed) {
                    sc->cb.onUpdateFixed(Framework_GetFixedStep());
                }
            }
        }

        // Frame update runs even when paused (for UI)
        if (auto sc = TopScene(); sc && sc->cb.onUpdateFrame) {
            float dt = (g_engineState == ENGINE_RUNNING) ? Framework_GetDeltaTime() : 0.0f;
            sc->cb.onUpdateFrame(dt);
        }

        if (auto sc = TopScene(); sc && sc->cb.onDraw) {
            sc->cb.onDraw();
        }
    }

    // ========================================================================
    // SCENE MANAGER - Transitions & Loading Screens
    // ========================================================================
    void Framework_Scene_SetTransition(int transitionType, float duration) {
        g_sceneManager.transitionType = (SceneTransitionType)transitionType;
        g_sceneManager.transitionDuration = duration;
    }

    void Framework_Scene_SetTransitionEx(int transitionType, float duration, int easing) {
        g_sceneManager.transitionType = (SceneTransitionType)transitionType;
        g_sceneManager.transitionDuration = duration;
        g_sceneManager.transitionEasing = (TransitionEasing)easing;
    }

    void Framework_Scene_SetTransitionColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        g_sceneManager.transitionColor = { r, g, b, a };
    }

    int Framework_Scene_GetTransitionType() {
        return (int)g_sceneManager.transitionType;
    }

    float Framework_Scene_GetTransitionDuration() {
        return g_sceneManager.transitionDuration;
    }

    int Framework_Scene_GetTransitionEasing() {
        return (int)g_sceneManager.transitionEasing;
    }

    void Framework_Scene_ChangeWithTransition(int sceneHandle) {
        if (g_sceneManager.transitionState != TRANS_STATE_NONE) return;  // Already transitioning

        g_sceneManager.pendingScene = sceneHandle;
        g_sceneManager.pendingIsPush = false;
        g_sceneManager.pendingIsPop = false;

        if (g_sceneManager.transitionType == TRANSITION_NONE || g_sceneManager.transitionDuration <= 0.0f) {
            // No transition, switch immediately
            PerformSceneSwitch();
        }
        else {
            // Start transition out
            g_sceneManager.transitionState = TRANS_STATE_OUT;
            g_sceneManager.transitionTimer = 0.0f;
            EnsureTransitionRenderTexture();
        }
    }

    void Framework_Scene_ChangeWithTransitionEx(int sceneHandle, int transitionType, float duration) {
        g_sceneManager.transitionType = (SceneTransitionType)transitionType;
        g_sceneManager.transitionDuration = duration;
        Framework_Scene_ChangeWithTransition(sceneHandle);
    }

    void Framework_Scene_PushWithTransition(int sceneHandle) {
        if (g_sceneManager.transitionState != TRANS_STATE_NONE) return;

        g_sceneManager.pendingScene = sceneHandle;
        g_sceneManager.pendingIsPush = true;
        g_sceneManager.pendingIsPop = false;

        if (g_sceneManager.transitionType == TRANSITION_NONE || g_sceneManager.transitionDuration <= 0.0f) {
            PerformSceneSwitch();
        }
        else {
            g_sceneManager.transitionState = TRANS_STATE_OUT;
            g_sceneManager.transitionTimer = 0.0f;
            EnsureTransitionRenderTexture();
        }
    }

    void Framework_Scene_PopWithTransition() {
        if (g_sceneManager.transitionState != TRANS_STATE_NONE) return;
        if (g_sceneStack.empty()) return;

        g_sceneManager.pendingScene = -1;
        g_sceneManager.pendingIsPush = false;
        g_sceneManager.pendingIsPop = true;

        if (g_sceneManager.transitionType == TRANSITION_NONE || g_sceneManager.transitionDuration <= 0.0f) {
            PerformSceneSwitch();
        }
        else {
            g_sceneManager.transitionState = TRANS_STATE_OUT;
            g_sceneManager.transitionTimer = 0.0f;
            EnsureTransitionRenderTexture();
        }
    }

    bool Framework_Scene_IsTransitioning() {
        return g_sceneManager.transitionState != TRANS_STATE_NONE;
    }

    int Framework_Scene_GetTransitionState() {
        return (int)g_sceneManager.transitionState;
    }

    float Framework_Scene_GetTransitionProgress() {
        if (g_sceneManager.transitionDuration <= 0.0f) return 1.0f;
        float rawProgress = g_sceneManager.transitionTimer / g_sceneManager.transitionDuration;
        return ApplyEasing(rawProgress < 0.0f ? 0.0f : (rawProgress > 1.0f ? 1.0f : rawProgress), g_sceneManager.transitionEasing);
    }

    void Framework_Scene_SkipTransition() {
        if (g_sceneManager.transitionState == TRANS_STATE_NONE) return;

        // Skip to the end
        if (g_sceneManager.transitionState == TRANS_STATE_OUT || g_sceneManager.transitionState == TRANS_STATE_LOADING) {
            PerformSceneSwitch();
        }
        g_sceneManager.transitionState = TRANS_STATE_NONE;
        g_sceneManager.transitionTimer = 0.0f;
        g_sceneManager.loadingTimer = 0.0f;
        g_sceneManager.loadingProgress = 0.0f;
    }

    void Framework_Scene_SetLoadingEnabled(bool enabled) {
        g_sceneManager.loadingEnabled = enabled;
    }

    bool Framework_Scene_IsLoadingEnabled() {
        return g_sceneManager.loadingEnabled;
    }

    void Framework_Scene_SetLoadingMinDuration(float seconds) {
        g_sceneManager.loadingMinDuration = seconds;
    }

    float Framework_Scene_GetLoadingMinDuration() {
        return g_sceneManager.loadingMinDuration;
    }

    void Framework_Scene_SetLoadingCallback(LoadingCallback callback) {
        g_sceneManager.loadingCallback = callback;
    }

    void Framework_Scene_SetLoadingDrawCallback(LoadingDrawCallback callback) {
        g_sceneManager.loadingDrawCallback = callback;
    }

    void Framework_Scene_SetLoadingProgress(float progress) {
        g_sceneManager.loadingProgress = progress < 0.0f ? 0.0f : (progress > 1.0f ? 1.0f : progress);
    }

    float Framework_Scene_GetLoadingProgress() {
        return g_sceneManager.loadingProgress;
    }

    bool Framework_Scene_IsLoading() {
        return g_sceneManager.transitionState == TRANS_STATE_LOADING;
    }

    int Framework_Scene_GetStackSize() {
        return (int)g_sceneStack.size();
    }

    int Framework_Scene_GetSceneAt(int index) {
        if (index < 0 || index >= (int)g_sceneStack.size()) return -1;
        return g_sceneStack[index];
    }

    int Framework_Scene_GetPreviousScene() {
        if (g_sceneStack.size() < 2) return -1;
        return g_sceneStack[g_sceneStack.size() - 2];
    }

    void Framework_Scene_Update(float dt) {
        switch (g_sceneManager.transitionState) {
            case TRANS_STATE_NONE:
                // Normal scene tick
                Framework_SceneTick();
                break;

            case TRANS_STATE_OUT:
                // Transitioning out of current scene
                g_sceneManager.transitionTimer += dt;
                if (g_sceneManager.transitionTimer >= g_sceneManager.transitionDuration) {
                    // Transition out complete
                    if (g_sceneManager.loadingEnabled) {
                        // Go to loading state
                        g_sceneManager.transitionState = TRANS_STATE_LOADING;
                        g_sceneManager.loadingTimer = 0.0f;
                        g_sceneManager.loadingProgress = 0.0f;
                    }
                    else {
                        // Skip loading, do scene switch
                        PerformSceneSwitch();
                        g_sceneManager.transitionState = TRANS_STATE_IN;
                        g_sceneManager.transitionTimer = 0.0f;
                    }
                }
                break;

            case TRANS_STATE_LOADING:
                // Loading screen active
                g_sceneManager.loadingTimer += dt;
                if (g_sceneManager.loadingCallback) {
                    g_sceneManager.loadingCallback(g_sceneManager.loadingProgress);
                }
                // Check if loading is complete
                if (g_sceneManager.loadingProgress >= 1.0f &&
                    g_sceneManager.loadingTimer >= g_sceneManager.loadingMinDuration) {
                    // Perform scene switch and start transition in
                    PerformSceneSwitch();
                    g_sceneManager.transitionState = TRANS_STATE_IN;
                    g_sceneManager.transitionTimer = 0.0f;
                }
                break;

            case TRANS_STATE_IN:
                // Transitioning into new scene
                g_sceneManager.transitionTimer += dt;
                if (g_sceneManager.transitionTimer >= g_sceneManager.transitionDuration) {
                    // Transition complete
                    g_sceneManager.transitionState = TRANS_STATE_NONE;
                    g_sceneManager.transitionTimer = 0.0f;
                }
                // Update the new scene even during transition in
                Framework_SceneTick();
                break;
        }
    }

    void Framework_Scene_Draw() {
        if (g_sceneManager.transitionState == TRANS_STATE_NONE) return;

        int screenWidth = GetScreenWidth();
        int screenHeight = GetScreenHeight();
        float progress = Framework_Scene_GetTransitionProgress();

        // For transition OUT, progress goes 0->1 (fade in the effect)
        // For transition IN, progress goes 0->1 (fade out the effect)
        float effectAlpha = 0.0f;
        if (g_sceneManager.transitionState == TRANS_STATE_OUT) {
            effectAlpha = progress;  // 0 -> 1
        }
        else if (g_sceneManager.transitionState == TRANS_STATE_IN) {
            effectAlpha = 1.0f - progress;  // 1 -> 0
        }
        else if (g_sceneManager.transitionState == TRANS_STATE_LOADING) {
            effectAlpha = 1.0f;  // Fully covered during loading
        }

        Color col = g_sceneManager.transitionColor;

        switch (g_sceneManager.transitionType) {
            case TRANSITION_NONE:
                break;

            case TRANSITION_FADE:
            case TRANSITION_FADE_WHITE:
                if (g_sceneManager.transitionType == TRANSITION_FADE_WHITE) {
                    col = { 255, 255, 255, 255 };
                }
                col.a = (unsigned char)(effectAlpha * 255.0f);
                DrawRectangle(0, 0, screenWidth, screenHeight, col);
                break;

            case TRANSITION_SLIDE_LEFT:
                DrawRectangle((int)((1.0f - effectAlpha) * screenWidth), 0, screenWidth, screenHeight, col);
                break;

            case TRANSITION_SLIDE_RIGHT:
                DrawRectangle((int)(-screenWidth + effectAlpha * screenWidth), 0, screenWidth, screenHeight, col);
                break;

            case TRANSITION_SLIDE_UP:
                DrawRectangle(0, (int)((1.0f - effectAlpha) * screenHeight), screenWidth, screenHeight, col);
                break;

            case TRANSITION_SLIDE_DOWN:
                DrawRectangle(0, (int)(-screenHeight + effectAlpha * screenHeight), screenWidth, screenHeight, col);
                break;

            case TRANSITION_WIPE_LEFT:
                DrawRectangle(0, 0, (int)(effectAlpha * screenWidth), screenHeight, col);
                break;

            case TRANSITION_WIPE_RIGHT:
                DrawRectangle((int)((1.0f - effectAlpha) * screenWidth), 0, (int)(effectAlpha * screenWidth), screenHeight, col);
                break;

            case TRANSITION_WIPE_UP:
                DrawRectangle(0, 0, screenWidth, (int)(effectAlpha * screenHeight), col);
                break;

            case TRANSITION_WIPE_DOWN:
                DrawRectangle(0, (int)((1.0f - effectAlpha) * screenHeight), screenWidth, (int)(effectAlpha * screenHeight), col);
                break;

            case TRANSITION_CIRCLE_IN: {
                // Circular iris closing
                float maxRadius = sqrtf((float)(screenWidth * screenWidth + screenHeight * screenHeight)) / 2.0f;
                float radius = maxRadius * (1.0f - effectAlpha);
                // Draw four rects around a circle (simple approximation)
                // For proper circle mask, would need shaders
                DrawRectangle(0, 0, screenWidth, screenHeight, col);
                if (radius > 0) {
                    DrawCircle(screenWidth / 2, screenHeight / 2, radius, { 0, 0, 0, 0 });  // Won't work as expected without shaders
                    // Simple workaround: just fade
                    col.a = (unsigned char)(effectAlpha * 255.0f);
                    DrawRectangle(0, 0, screenWidth, screenHeight, col);
                }
                break;
            }

            case TRANSITION_CIRCLE_OUT: {
                // Circular iris opening - inverse of circle in
                float maxRadius = sqrtf((float)(screenWidth * screenWidth + screenHeight * screenHeight)) / 2.0f;
                float radius = maxRadius * effectAlpha;
                col.a = (unsigned char)(effectAlpha * 255.0f);
                DrawRectangle(0, 0, screenWidth, screenHeight, col);
                break;
            }

            case TRANSITION_PIXELATE:
            case TRANSITION_DISSOLVE:
                // These would require shaders for proper implementation
                // Fall back to fade
                col.a = (unsigned char)(effectAlpha * 255.0f);
                DrawRectangle(0, 0, screenWidth, screenHeight, col);
                break;
        }

        // Draw loading screen if in loading state
        if (g_sceneManager.transitionState == TRANS_STATE_LOADING) {
            if (g_sceneManager.loadingDrawCallback) {
                g_sceneManager.loadingDrawCallback();
            }
            else {
                // Default loading screen
                int barWidth = 400;
                int barHeight = 20;
                int barX = (screenWidth - barWidth) / 2;
                int barY = (screenHeight - barHeight) / 2 + 50;

                // Background bar
                DrawRectangle(barX, barY, barWidth, barHeight, DARKGRAY);
                // Progress bar
                DrawRectangle(barX, barY, (int)(barWidth * g_sceneManager.loadingProgress), barHeight, WHITE);
                // Border
                DrawRectangleLines(barX, barY, barWidth, barHeight, WHITE);

                // Loading text
                const char* loadingText = "Loading...";
                int textWidth = MeasureText(loadingText, 30);
                DrawText(loadingText, (screenWidth - textWidth) / 2, barY - 50, 30, WHITE);
            }
        }
    }

    void Framework_Scene_PreloadStart(int sceneHandle) {
        g_sceneManager.isPreloading = true;
        g_sceneManager.preloadScene = sceneHandle;
        g_sceneManager.loadingProgress = 0.0f;
    }

    bool Framework_Scene_IsPreloading() {
        return g_sceneManager.isPreloading;
    }

    void Framework_Scene_PreloadCancel() {
        g_sceneManager.isPreloading = false;
        g_sceneManager.preloadScene = -1;
        g_sceneManager.loadingProgress = 0.0f;
    }

    // ========================================================================
    // ECS - ENTITIES
    // ========================================================================
    constexpr int MAX_ENTITIES = 100000;  // Prevent runaway entity creation

    int Framework_Ecs_CreateEntity() {
        // Prevent excessive entity creation that could exhaust memory
        if ((int)g_entities.size() >= MAX_ENTITIES) {
            return -1;  // Return invalid entity ID
        }
        Entity e = g_nextEntityId++;
        g_entities.insert(e);
        g_enabled[e] = EnabledComponent{ true };
        return e;
    }

    void Framework_Ecs_DestroyEntity(int entity) {
        if (!EcsIsAlive(entity)) return;
        DestroyEntityRecursive(entity);
    }

    bool Framework_Ecs_IsAlive(int entity) {
        return EcsIsAlive(entity);
    }

    void Framework_Ecs_ClearAll() {
        EcsClearAllInternal();
    }

    int Framework_Ecs_GetEntityCount() {
        return (int)g_entities.size();
    }

    int Framework_Ecs_GetAllEntities(int* buffer, int bufferSize) {
        if (!buffer || bufferSize <= 0) return 0;
        int count = 0;
        for (Entity e : g_entities) {
            if (count >= bufferSize) break;
            buffer[count++] = e;
        }
        return count;
    }

    // ========================================================================
    // ECS - NAME COMPONENT
    // ========================================================================
    void Framework_Ecs_SetName(int entity, const char* name) {
        if (!EcsIsAlive(entity)) return;
        NameComponent nc;
        memset(nc.name, 0, FW_NAME_MAX);
        if (name) {
            strncpy_s(nc.name, FW_NAME_MAX, name, _TRUNCATE);
        }
        g_name[entity] = nc;
    }

    const char* Framework_Ecs_GetName(int entity) {
        auto it = g_name.find(entity);
        if (it == g_name.end()) return "";
        return it->second.name;
    }

    bool Framework_Ecs_HasName(int entity) {
        return g_name.find(entity) != g_name.end();
    }

    int Framework_Ecs_FindByName(const char* name) {
        if (!name) return -1;
        for (auto& kv : g_name) {
            if (strcmp(kv.second.name, name) == 0) {
                return kv.first;
            }
        }
        return -1;
    }

    // ========================================================================
    // ECS - TAG COMPONENT
    // ========================================================================
    void Framework_Ecs_SetTag(int entity, const char* tag) {
        if (!EcsIsAlive(entity)) return;
        TagComponent tc;
        memset(tc.tag, 0, FW_TAG_MAX);
        if (tag) {
            strncpy_s(tc.tag, FW_TAG_MAX, tag, _TRUNCATE);
        }
        g_tag[entity] = tc;
    }

    const char* Framework_Ecs_GetTag(int entity) {
        auto it = g_tag.find(entity);
        if (it == g_tag.end()) return "";
        return it->second.tag;
    }

    bool Framework_Ecs_HasTag(int entity) {
        return g_tag.find(entity) != g_tag.end();
    }

    int Framework_Ecs_FindAllByTag(const char* tag, int* buffer, int bufferSize) {
        if (!tag || !buffer || bufferSize <= 0) return 0;
        int count = 0;
        for (auto& kv : g_tag) {
            if (count >= bufferSize) break;
            if (strcmp(kv.second.tag, tag) == 0) {
                buffer[count++] = kv.first;
            }
        }
        return count;
    }

    // ========================================================================
    // ECS - ENABLED COMPONENT
    // ========================================================================
    void Framework_Ecs_SetEnabled(int entity, bool enabled) {
        if (!EcsIsAlive(entity)) return;
        g_enabled[entity].enabled = enabled;
    }

    bool Framework_Ecs_IsEnabled(int entity) {
        auto it = g_enabled.find(entity);
        if (it == g_enabled.end()) return true;
        return it->second.enabled;
    }

    bool Framework_Ecs_IsActiveInHierarchy(int entity) {
        if (!EcsIsAlive(entity)) return false;
        return IsActiveInHierarchyInternal(entity);
    }

    // ========================================================================
    // ECS - HIERARCHY COMPONENT
    // ========================================================================
    void Framework_Ecs_SetParent(int entity, int parent) {
        if (!EcsIsAlive(entity)) return;
        if (parent != -1 && !EcsIsAlive(parent)) return;
        if (entity == parent) return;

        RemoveFromParent(entity);

        if (g_hierarchy.find(entity) == g_hierarchy.end()) {
            g_hierarchy[entity] = HierarchyComponent{};
        }

        if (parent == -1) return;

        if (g_hierarchy.find(parent) == g_hierarchy.end()) {
            g_hierarchy[parent] = HierarchyComponent{};
        }

        HierarchyComponent& h = g_hierarchy[entity];
        HierarchyComponent& ph = g_hierarchy[parent];

        h.parent = parent;
        h.nextSibling = ph.firstChild;
        h.prevSibling = -1;

        if (ph.firstChild != -1) {
            auto fcIt = g_hierarchy.find(ph.firstChild);
            if (fcIt != g_hierarchy.end()) {
                fcIt->second.prevSibling = entity;
            }
        }

        ph.firstChild = entity;
    }

    int Framework_Ecs_GetParent(int entity) {
        auto it = g_hierarchy.find(entity);
        if (it == g_hierarchy.end()) return -1;
        return it->second.parent;
    }

    int Framework_Ecs_GetFirstChild(int entity) {
        auto it = g_hierarchy.find(entity);
        if (it == g_hierarchy.end()) return -1;
        return it->second.firstChild;
    }

    int Framework_Ecs_GetNextSibling(int entity) {
        auto it = g_hierarchy.find(entity);
        if (it == g_hierarchy.end()) return -1;
        return it->second.nextSibling;
    }

    int Framework_Ecs_GetChildCount(int entity) {
        auto it = g_hierarchy.find(entity);
        if (it == g_hierarchy.end()) return 0;

        int count = 0;
        int child = it->second.firstChild;
        while (child != -1) {
            count++;
            auto cIt = g_hierarchy.find(child);
            if (cIt == g_hierarchy.end()) break;
            child = cIt->second.nextSibling;
        }
        return count;
    }

    int Framework_Ecs_GetChildren(int entity, int* buffer, int bufferSize) {
        if (!buffer || bufferSize <= 0) return 0;

        auto it = g_hierarchy.find(entity);
        if (it == g_hierarchy.end()) return 0;

        int count = 0;
        int child = it->second.firstChild;
        while (child != -1 && count < bufferSize) {
            buffer[count++] = child;
            auto cIt = g_hierarchy.find(child);
            if (cIt == g_hierarchy.end()) break;
            child = cIt->second.nextSibling;
        }
        return count;
    }

    void Framework_Ecs_DetachFromParent(int entity) {
        RemoveFromParent(entity);
    }

    // ========================================================================
    // ECS - TRANSFORM2D COMPONENT
    // ========================================================================
    void Framework_Ecs_AddTransform2D(int entity, float x, float y, float rotation, float sx, float sy) {
        if (!EcsIsAlive(entity)) return;
        Transform2D t;
        t.position = Vector2{ x, y };
        t.rotation = rotation;
        t.scale = Vector2{ sx, sy };
        g_transform2D[entity] = t;
    }

    bool Framework_Ecs_HasTransform2D(int entity) {
        return g_transform2D.find(entity) != g_transform2D.end();
    }

    void Framework_Ecs_SetTransformPosition(int entity, float x, float y) {
        auto it = g_transform2D.find(entity);
        if (it == g_transform2D.end()) return;
        it->second.position = Vector2{ x, y };
    }

    void Framework_Ecs_SetTransformRotation(int entity, float rotation) {
        auto it = g_transform2D.find(entity);
        if (it == g_transform2D.end()) return;
        it->second.rotation = rotation;
    }

    void Framework_Ecs_SetTransformScale(int entity, float sx, float sy) {
        auto it = g_transform2D.find(entity);
        if (it == g_transform2D.end()) return;
        it->second.scale = Vector2{ sx, sy };
    }

    Vector2 Framework_Ecs_GetTransformPosition(int entity) {
        auto it = g_transform2D.find(entity);
        if (it == g_transform2D.end()) return Vector2{ 0.0f, 0.0f };
        return it->second.position;
    }

    Vector2 Framework_Ecs_GetTransformScale(int entity) {
        auto it = g_transform2D.find(entity);
        if (it == g_transform2D.end()) return Vector2{ 1.0f, 1.0f };
        return it->second.scale;
    }

    float Framework_Ecs_GetTransformRotation(int entity) {
        auto it = g_transform2D.find(entity);
        if (it == g_transform2D.end()) return 0.0f;
        return it->second.rotation;
    }

    Vector2 Framework_Ecs_GetWorldPosition(int entity) {
        if (!EcsIsAlive(entity)) return Vector2{ 0, 0 };
        return GetWorldPositionInternal(entity);
    }

    float Framework_Ecs_GetWorldRotation(int entity) {
        if (!EcsIsAlive(entity)) return 0.0f;
        return GetWorldRotationInternal(entity);
    }

    Vector2 Framework_Ecs_GetWorldScale(int entity) {
        if (!EcsIsAlive(entity)) return Vector2{ 1, 1 };
        return GetWorldScaleInternal(entity);
    }

    // ========================================================================
    // ECS - VELOCITY2D COMPONENT
    // ========================================================================
    void Framework_Ecs_AddVelocity2D(int entity, float vx, float vy) {
        if (!EcsIsAlive(entity)) return;
        g_velocity2D[entity] = Velocity2D{ vx, vy };
    }

    bool Framework_Ecs_HasVelocity2D(int entity) {
        return g_velocity2D.find(entity) != g_velocity2D.end();
    }

    void Framework_Ecs_SetVelocity(int entity, float vx, float vy) {
        auto it = g_velocity2D.find(entity);
        if (it == g_velocity2D.end()) return;
        it->second.vx = vx;
        it->second.vy = vy;
    }

    Vector2 Framework_Ecs_GetVelocity(int entity) {
        auto it = g_velocity2D.find(entity);
        if (it == g_velocity2D.end()) return Vector2{ 0, 0 };
        return Vector2{ it->second.vx, it->second.vy };
    }

    void Framework_Ecs_RemoveVelocity2D(int entity) {
        g_velocity2D.erase(entity);
    }

    // ========================================================================
    // ECS - BOXCOLLIDER2D COMPONENT
    // ========================================================================
    void Framework_Ecs_AddBoxCollider2D(int entity, float offsetX, float offsetY, float width, float height, bool isTrigger) {
        if (!EcsIsAlive(entity)) return;
        g_boxCollider2D[entity] = BoxCollider2D{ offsetX, offsetY, width, height, isTrigger };
    }

    bool Framework_Ecs_HasBoxCollider2D(int entity) {
        return g_boxCollider2D.find(entity) != g_boxCollider2D.end();
    }

    void Framework_Ecs_SetBoxCollider(int entity, float offsetX, float offsetY, float width, float height) {
        auto it = g_boxCollider2D.find(entity);
        if (it == g_boxCollider2D.end()) return;
        it->second.offsetX = offsetX;
        it->second.offsetY = offsetY;
        it->second.width = width;
        it->second.height = height;
    }

    void Framework_Ecs_SetBoxColliderTrigger(int entity, bool isTrigger) {
        auto it = g_boxCollider2D.find(entity);
        if (it == g_boxCollider2D.end()) return;
        it->second.isTrigger = isTrigger;
    }

    Rectangle Framework_Ecs_GetBoxColliderWorldBounds(int entity) {
        return GetBoxColliderWorldBoundsInternal(entity);
    }

    void Framework_Ecs_RemoveBoxCollider2D(int entity) {
        g_boxCollider2D.erase(entity);
    }

    // ========================================================================
    // ECS - SPRITE2D COMPONENT
    // ========================================================================
    void Framework_Ecs_AddSprite2D(int entity, int textureHandle,
        float srcX, float srcY, float srcW, float srcH,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a,
        int layer) {
        if (!EcsIsAlive(entity)) return;
        Sprite2D sp;
        sp.textureHandle = textureHandle;
        sp.source = Rectangle{ srcX, srcY, srcW, srcH };
        sp.tint = Color{ r, g, b, a };
        sp.layer = layer;
        sp.visible = true;
        g_sprite2D[entity] = sp;
    }

    bool Framework_Ecs_HasSprite2D(int entity) {
        return g_sprite2D.find(entity) != g_sprite2D.end();
    }

    void Framework_Ecs_SetSpriteTint(int entity, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto it = g_sprite2D.find(entity);
        if (it == g_sprite2D.end()) return;
        it->second.tint = Color{ r, g, b, a };
    }

    void Framework_Ecs_SetSpriteVisible(int entity, bool visible) {
        auto it = g_sprite2D.find(entity);
        if (it == g_sprite2D.end()) return;
        it->second.visible = visible;
    }

    void Framework_Ecs_SetSpriteLayer(int entity, int layer) {
        auto it = g_sprite2D.find(entity);
        if (it == g_sprite2D.end()) return;
        it->second.layer = layer;
    }

    void Framework_Ecs_SetSpriteSource(int entity, float srcX, float srcY, float srcW, float srcH) {
        auto it = g_sprite2D.find(entity);
        if (it == g_sprite2D.end()) return;
        it->second.source = Rectangle{ srcX, srcY, srcW, srcH };
    }

    void Framework_Ecs_SetSpriteTexture(int entity, int textureHandle) {
        auto it = g_sprite2D.find(entity);
        if (it == g_sprite2D.end()) return;
        it->second.textureHandle = textureHandle;
    }

    void Framework_Ecs_RemoveSprite2D(int entity) {
        g_sprite2D.erase(entity);
    }

    // ========================================================================
    // ECS - SYSTEMS
    // ========================================================================
    void Framework_Ecs_UpdateVelocities(float dt) {
        for (auto& kv : g_velocity2D) {
            Entity e = kv.first;
            if (!IsActiveInHierarchyInternal(e)) continue;

            auto tIt = g_transform2D.find(e);
            if (tIt == g_transform2D.end()) continue;

            tIt->second.position.x += kv.second.vx * dt;
            tIt->second.position.y += kv.second.vy * dt;
        }
    }

    void Framework_Ecs_DrawSprites() {
        EcsDrawSpritesInternal();
    }

    // ========================================================================
    // PHYSICS - OVERLAP QUERIES
    // ========================================================================
    int Framework_Physics_OverlapBox(float x, float y, float w, float h, int* buffer, int bufferSize) {
        if (!buffer || bufferSize <= 0) return 0;

        Rectangle query = { x, y, w, h };
        int count = 0;

        for (auto& kv : g_boxCollider2D) {
            if (count >= bufferSize) break;
            Rectangle bounds = GetBoxColliderWorldBoundsInternal(kv.first);
            if (CheckCollisionRecs(query, bounds)) {
                buffer[count++] = kv.first;
            }
        }

        return count;
    }

    int Framework_Physics_OverlapCircle(float x, float y, float radius, int* buffer, int bufferSize) {
        if (!buffer || bufferSize <= 0) return 0;

        Vector2 center = { x, y };
        int count = 0;

        for (auto& kv : g_boxCollider2D) {
            if (count >= bufferSize) break;
            Rectangle bounds = GetBoxColliderWorldBoundsInternal(kv.first);
            if (CheckCollisionCircleRec(center, radius, bounds)) {
                buffer[count++] = kv.first;
            }
        }

        return count;
    }

    bool Framework_Physics_CheckEntityOverlap(int entityA, int entityB) {
        if (!EcsIsAlive(entityA) || !EcsIsAlive(entityB)) return false;

        auto aIt = g_boxCollider2D.find(entityA);
        auto bIt = g_boxCollider2D.find(entityB);
        if (aIt == g_boxCollider2D.end() || bIt == g_boxCollider2D.end()) return false;

        Rectangle boundsA = GetBoxColliderWorldBoundsInternal(entityA);
        Rectangle boundsB = GetBoxColliderWorldBoundsInternal(entityB);

        return CheckCollisionRecs(boundsA, boundsB);
    }

    int Framework_Physics_GetOverlappingEntities(int entity, int* buffer, int bufferSize) {
        if (!buffer || bufferSize <= 0) return 0;
        if (!EcsIsAlive(entity)) return 0;

        auto eIt = g_boxCollider2D.find(entity);
        if (eIt == g_boxCollider2D.end()) return 0;

        Rectangle bounds = GetBoxColliderWorldBoundsInternal(entity);
        int count = 0;

        for (auto& kv : g_boxCollider2D) {
            if (count >= bufferSize) break;
            if (kv.first == entity) continue;

            Rectangle otherBounds = GetBoxColliderWorldBoundsInternal(kv.first);
            if (CheckCollisionRecs(bounds, otherBounds)) {
                buffer[count++] = kv.first;
            }
        }

        return count;
    }

    // ========================================================================
    // INTROSPECTION
    // ========================================================================
    int Framework_Entity_GetComponentCount(int entity) {
        if (!EcsIsAlive(entity)) return 0;
        int count = 0;
        if (g_transform2D.find(entity) != g_transform2D.end()) count++;
        if (g_sprite2D.find(entity) != g_sprite2D.end()) count++;
        if (g_name.find(entity) != g_name.end()) count++;
        if (g_tag.find(entity) != g_tag.end()) count++;
        if (g_hierarchy.find(entity) != g_hierarchy.end()) count++;
        if (g_velocity2D.find(entity) != g_velocity2D.end()) count++;
        if (g_boxCollider2D.find(entity) != g_boxCollider2D.end()) count++;
        if (g_enabled.find(entity) != g_enabled.end()) count++;
        return count;
    }

    int Framework_Entity_GetComponentTypeAt(int entity, int index) {
        if (!EcsIsAlive(entity)) return COMP_NONE;
        int current = 0;
        if (g_transform2D.find(entity) != g_transform2D.end()) { if (current == index) return COMP_TRANSFORM2D; current++; }
        if (g_sprite2D.find(entity) != g_sprite2D.end()) { if (current == index) return COMP_SPRITE2D; current++; }
        if (g_name.find(entity) != g_name.end()) { if (current == index) return COMP_NAME; current++; }
        if (g_tag.find(entity) != g_tag.end()) { if (current == index) return COMP_TAG; current++; }
        if (g_hierarchy.find(entity) != g_hierarchy.end()) { if (current == index) return COMP_HIERARCHY; current++; }
        if (g_velocity2D.find(entity) != g_velocity2D.end()) { if (current == index) return COMP_VELOCITY2D; current++; }
        if (g_boxCollider2D.find(entity) != g_boxCollider2D.end()) { if (current == index) return COMP_BOXCOLLIDER2D; current++; }
        if (g_enabled.find(entity) != g_enabled.end()) { if (current == index) return COMP_ENABLED; current++; }
        return COMP_NONE;
    }

    bool Framework_Entity_HasComponent(int entity, int compType) {
        if (!EcsIsAlive(entity)) return false;
        switch (compType) {
            case COMP_TRANSFORM2D: return g_transform2D.find(entity) != g_transform2D.end();
            case COMP_SPRITE2D: return g_sprite2D.find(entity) != g_sprite2D.end();
            case COMP_NAME: return g_name.find(entity) != g_name.end();
            case COMP_TAG: return g_tag.find(entity) != g_tag.end();
            case COMP_HIERARCHY: return g_hierarchy.find(entity) != g_hierarchy.end();
            case COMP_VELOCITY2D: return g_velocity2D.find(entity) != g_velocity2D.end();
            case COMP_BOXCOLLIDER2D: return g_boxCollider2D.find(entity) != g_boxCollider2D.end();
            case COMP_ENABLED: return g_enabled.find(entity) != g_enabled.end();
            default: return false;
        }
    }

    // Field metadata
    static const char* s_transform2DFields[] = { "posX", "posY", "rotation", "scaleX", "scaleY" };
    static const char* s_sprite2DFields[] = { "textureHandle", "srcX", "srcY", "srcW", "srcH", "tintR", "tintG", "tintB", "tintA", "layer", "visible" };
    static const char* s_nameFields[] = { "name" };
    static const char* s_tagFields[] = { "tag" };
    static const char* s_hierarchyFields[] = { "parent", "firstChild", "nextSibling" };
    static const char* s_velocity2DFields[] = { "vx", "vy" };
    static const char* s_boxCollider2DFields[] = { "offsetX", "offsetY", "width", "height", "isTrigger" };
    static const char* s_enabledFields[] = { "enabled" };

    int Framework_Component_GetFieldCount(int compType) {
        switch (compType) {
            case COMP_TRANSFORM2D: return 5;
            case COMP_SPRITE2D: return 11;
            case COMP_NAME: return 1;
            case COMP_TAG: return 1;
            case COMP_HIERARCHY: return 3;
            case COMP_VELOCITY2D: return 2;
            case COMP_BOXCOLLIDER2D: return 5;
            case COMP_ENABLED: return 1;
            default: return 0;
        }
    }

    const char* Framework_Component_GetFieldName(int compType, int fieldIndex) {
        switch (compType) {
            case COMP_TRANSFORM2D: return (fieldIndex >= 0 && fieldIndex < 5) ? s_transform2DFields[fieldIndex] : "";
            case COMP_SPRITE2D: return (fieldIndex >= 0 && fieldIndex < 11) ? s_sprite2DFields[fieldIndex] : "";
            case COMP_NAME: return (fieldIndex == 0) ? s_nameFields[0] : "";
            case COMP_TAG: return (fieldIndex == 0) ? s_tagFields[0] : "";
            case COMP_HIERARCHY: return (fieldIndex >= 0 && fieldIndex < 3) ? s_hierarchyFields[fieldIndex] : "";
            case COMP_VELOCITY2D: return (fieldIndex >= 0 && fieldIndex < 2) ? s_velocity2DFields[fieldIndex] : "";
            case COMP_BOXCOLLIDER2D: return (fieldIndex >= 0 && fieldIndex < 5) ? s_boxCollider2DFields[fieldIndex] : "";
            case COMP_ENABLED: return (fieldIndex == 0) ? s_enabledFields[0] : "";
            default: return "";
        }
    }

    int Framework_Component_GetFieldType(int compType, int fieldIndex) {
        // 0=float, 1=int, 2=bool, 3=string
        switch (compType) {
            case COMP_TRANSFORM2D: return 0; // all floats
            case COMP_SPRITE2D:
                if (fieldIndex == 0 || fieldIndex == 9) return 1; // textureHandle, layer = int
                if (fieldIndex == 10) return 2; // visible = bool
                return 0; // rest are floats
            case COMP_NAME: return 3;
            case COMP_TAG: return 3;
            case COMP_HIERARCHY: return 1; // all ints
            case COMP_VELOCITY2D: return 0;
            case COMP_BOXCOLLIDER2D:
                if (fieldIndex == 4) return 2; // isTrigger = bool
                return 0;
            case COMP_ENABLED: return 2;
            default: return 0;
        }
    }

    float Framework_Component_GetFieldFloat(int entity, int compType, int fieldIndex) {
        switch (compType) {
            case COMP_TRANSFORM2D: {
                auto it = g_transform2D.find(entity);
                if (it == g_transform2D.end()) return 0.0f;
                switch (fieldIndex) {
                    case 0: return it->second.position.x;
                    case 1: return it->second.position.y;
                    case 2: return it->second.rotation;
                    case 3: return it->second.scale.x;
                    case 4: return it->second.scale.y;
                }
                break;
            }
            case COMP_SPRITE2D: {
                auto it = g_sprite2D.find(entity);
                if (it == g_sprite2D.end()) return 0.0f;
                switch (fieldIndex) {
                    case 1: return it->second.source.x;
                    case 2: return it->second.source.y;
                    case 3: return it->second.source.width;
                    case 4: return it->second.source.height;
                    case 5: return (float)it->second.tint.r;
                    case 6: return (float)it->second.tint.g;
                    case 7: return (float)it->second.tint.b;
                    case 8: return (float)it->second.tint.a;
                }
                break;
            }
            case COMP_VELOCITY2D: {
                auto it = g_velocity2D.find(entity);
                if (it == g_velocity2D.end()) return 0.0f;
                switch (fieldIndex) {
                    case 0: return it->second.vx;
                    case 1: return it->second.vy;
                }
                break;
            }
            case COMP_BOXCOLLIDER2D: {
                auto it = g_boxCollider2D.find(entity);
                if (it == g_boxCollider2D.end()) return 0.0f;
                switch (fieldIndex) {
                    case 0: return it->second.offsetX;
                    case 1: return it->second.offsetY;
                    case 2: return it->second.width;
                    case 3: return it->second.height;
                }
                break;
            }
        }
        return 0.0f;
    }

    int Framework_Component_GetFieldInt(int entity, int compType, int fieldIndex) {
        switch (compType) {
            case COMP_SPRITE2D: {
                auto it = g_sprite2D.find(entity);
                if (it == g_sprite2D.end()) return 0;
                switch (fieldIndex) {
                    case 0: return it->second.textureHandle;
                    case 9: return it->second.layer;
                }
                break;
            }
            case COMP_HIERARCHY: {
                auto it = g_hierarchy.find(entity);
                if (it == g_hierarchy.end()) return -1;
                switch (fieldIndex) {
                    case 0: return it->second.parent;
                    case 1: return it->second.firstChild;
                    case 2: return it->second.nextSibling;
                }
                break;
            }
        }
        return 0;
    }

    bool Framework_Component_GetFieldBool(int entity, int compType, int fieldIndex) {
        switch (compType) {
            case COMP_SPRITE2D: {
                auto it = g_sprite2D.find(entity);
                if (it == g_sprite2D.end()) return false;
                if (fieldIndex == 10) return it->second.visible;
                break;
            }
            case COMP_BOXCOLLIDER2D: {
                auto it = g_boxCollider2D.find(entity);
                if (it == g_boxCollider2D.end()) return false;
                if (fieldIndex == 4) return it->second.isTrigger;
                break;
            }
            case COMP_ENABLED: {
                auto it = g_enabled.find(entity);
                if (it == g_enabled.end()) return true;
                if (fieldIndex == 0) return it->second.enabled;
                break;
            }
        }
        return false;
    }

    const char* Framework_Component_GetFieldString(int entity, int compType, int fieldIndex) {
        switch (compType) {
            case COMP_NAME: {
                auto it = g_name.find(entity);
                if (it == g_name.end()) return "";
                return it->second.name;
            }
            case COMP_TAG: {
                auto it = g_tag.find(entity);
                if (it == g_tag.end()) return "";
                return it->second.tag;
            }
        }
        return "";
    }

    void Framework_Component_SetFieldFloat(int entity, int compType, int fieldIndex, float value) {
        switch (compType) {
            case COMP_TRANSFORM2D: {
                auto it = g_transform2D.find(entity);
                if (it == g_transform2D.end()) return;
                switch (fieldIndex) {
                    case 0: it->second.position.x = value; break;
                    case 1: it->second.position.y = value; break;
                    case 2: it->second.rotation = value; break;
                    case 3: it->second.scale.x = value; break;
                    case 4: it->second.scale.y = value; break;
                }
                break;
            }
            case COMP_SPRITE2D: {
                auto it = g_sprite2D.find(entity);
                if (it == g_sprite2D.end()) return;
                switch (fieldIndex) {
                    case 1: it->second.source.x = value; break;
                    case 2: it->second.source.y = value; break;
                    case 3: it->second.source.width = value; break;
                    case 4: it->second.source.height = value; break;
                    case 5: it->second.tint.r = (unsigned char)value; break;
                    case 6: it->second.tint.g = (unsigned char)value; break;
                    case 7: it->second.tint.b = (unsigned char)value; break;
                    case 8: it->second.tint.a = (unsigned char)value; break;
                }
                break;
            }
            case COMP_VELOCITY2D: {
                auto it = g_velocity2D.find(entity);
                if (it == g_velocity2D.end()) return;
                switch (fieldIndex) {
                    case 0: it->second.vx = value; break;
                    case 1: it->second.vy = value; break;
                }
                break;
            }
            case COMP_BOXCOLLIDER2D: {
                auto it = g_boxCollider2D.find(entity);
                if (it == g_boxCollider2D.end()) return;
                switch (fieldIndex) {
                    case 0: it->second.offsetX = value; break;
                    case 1: it->second.offsetY = value; break;
                    case 2: it->second.width = value; break;
                    case 3: it->second.height = value; break;
                }
                break;
            }
        }
    }

    void Framework_Component_SetFieldInt(int entity, int compType, int fieldIndex, int value) {
        switch (compType) {
            case COMP_SPRITE2D: {
                auto it = g_sprite2D.find(entity);
                if (it == g_sprite2D.end()) return;
                switch (fieldIndex) {
                    case 0: it->second.textureHandle = value; break;
                    case 9: it->second.layer = value; break;
                }
                break;
            }
        }
    }

    void Framework_Component_SetFieldBool(int entity, int compType, int fieldIndex, bool value) {
        switch (compType) {
            case COMP_SPRITE2D: {
                auto it = g_sprite2D.find(entity);
                if (it == g_sprite2D.end()) return;
                if (fieldIndex == 10) it->second.visible = value;
                break;
            }
            case COMP_BOXCOLLIDER2D: {
                auto it = g_boxCollider2D.find(entity);
                if (it == g_boxCollider2D.end()) return;
                if (fieldIndex == 4) it->second.isTrigger = value;
                break;
            }
            case COMP_ENABLED: {
                auto it = g_enabled.find(entity);
                if (it == g_enabled.end()) return;
                if (fieldIndex == 0) it->second.enabled = value;
                break;
            }
        }
    }

    void Framework_Component_SetFieldString(int entity, int compType, int fieldIndex, const char* value) {
        switch (compType) {
            case COMP_NAME: {
                auto it = g_name.find(entity);
                if (it == g_name.end()) return;
                if (value) {
                    strncpy_s(it->second.name, FW_NAME_MAX, value, _TRUNCATE);
                }
                break;
            }
            case COMP_TAG: {
                auto it = g_tag.find(entity);
                if (it == g_tag.end()) return;
                if (value) {
                    strncpy_s(it->second.tag, FW_TAG_MAX, value, _TRUNCATE);
                }
                break;
            }
        }
    }

    // ========================================================================
    // DEBUG OVERLAY
    // ========================================================================
    void Framework_Debug_SetEnabled(bool enabled) {
        g_debugEnabled = enabled;
    }

    bool Framework_Debug_IsEnabled() {
        return g_debugEnabled;
    }

    void Framework_Debug_DrawEntityBounds(bool enabled) {
        g_debugDrawBounds = enabled;
    }

    void Framework_Debug_DrawHierarchy(bool enabled) {
        g_debugDrawHierarchy = enabled;
    }

    void Framework_Debug_DrawStats(bool enabled) {
        g_debugDrawStats = enabled;
    }

    void Framework_Debug_Render() {
        if (!g_debugEnabled) return;

        // Draw entity bounds
        if (g_debugDrawBounds) {
            for (auto& kv : g_boxCollider2D) {
                if (!IsActiveInHierarchyInternal(kv.first)) continue;
                Rectangle bounds = GetBoxColliderWorldBoundsInternal(kv.first);
                Color col = kv.second.isTrigger ? Color{ 0, 255, 0, 128 } : Color{ 255, 255, 0, 128 };
                DrawRectangleLinesEx(bounds, 1.0f, col);
            }
        }

        // Draw hierarchy lines
        if (g_debugDrawHierarchy) {
            for (auto& kv : g_hierarchy) {
                if (kv.second.parent == -1) continue;
                Vector2 childPos = GetWorldPositionInternal(kv.first);
                Vector2 parentPos = GetWorldPositionInternal(kv.second.parent);
                DrawLineV(childPos, parentPos, Color{ 128, 128, 255, 200 });
            }
        }

        // Draw stats
        if (g_debugDrawStats) {
            int y = 10;
            char buf[128];

            snprintf(buf, sizeof(buf), "FPS: %d", GetFPS());
            DrawText(buf, 10, y, 16, WHITE); y += 18;

            snprintf(buf, sizeof(buf), "Entities: %d", (int)g_entities.size());
            DrawText(buf, 10, y, 16, WHITE); y += 18;

            snprintf(buf, sizeof(buf), "Sprites: %d", (int)g_sprite2D.size());
            DrawText(buf, 10, y, 16, WHITE); y += 18;

            snprintf(buf, sizeof(buf), "Frame: %llu", g_frameCount);
            DrawText(buf, 10, y, 16, WHITE); y += 18;

            const char* stateStr = "UNKNOWN";
            switch (g_engineState) {
                case ENGINE_STOPPED: stateStr = "STOPPED"; break;
                case ENGINE_RUNNING: stateStr = "RUNNING"; break;
                case ENGINE_PAUSED: stateStr = "PAUSED"; break;
                case ENGINE_QUITTING: stateStr = "QUITTING"; break;
            }
            snprintf(buf, sizeof(buf), "State: %s", stateStr);
            DrawText(buf, 10, y, 16, WHITE);
        }
    }

    // ========================================================================
    // PROFILING & PERFORMANCE SYSTEM
    // ========================================================================

    struct PerfScope {
        std::string name;
        double startTime = 0;
        double lastTime = 0;
        double totalTime = 0;
        int callCount = 0;
    };

    struct ConsoleLine {
        std::string text;
        Color color;
    };

    struct DebugShape {
        enum Type { LINE, RECT, RECT_FILLED, CIRCLE, CIRCLE_FILLED, POINT, ARROW, TEXT, GRID, CROSS };
        Type type;
        float x1, y1, x2, y2;
        float size;
        Color color;
        std::string text;
    };

    // Performance state
    static std::vector<float> g_frameTimeHistory;
    static int g_perfSampleCount = 60;
    static int g_totalFrameCount = 0;
    static float g_currentFrameTime = 0;
    static double g_frameStartTime = 0;
    static int g_drawCallCount = 0;
    static int g_triangleCount = 0;

    // Profiling scopes
    static std::unordered_map<std::string, PerfScope> g_perfScopes;
    static std::vector<std::string> g_scopeStack;

    // Performance graph
    static bool g_perfGraphEnabled = false;
    static float g_perfGraphX = 10;
    static float g_perfGraphY = 100;
    static float g_perfGraphWidth = 200;
    static float g_perfGraphHeight = 60;

    // Logging
    static int g_logMinLevel = LOG_LEVEL_INFO;
    static std::ofstream g_logFile;
    static bool g_logFileOpen = false;

    // Console
    static bool g_consoleEnabled = false;
    static float g_consoleX = 10;
    static float g_consoleY = 200;
    static float g_consoleWidth = 400;
    static float g_consoleHeight = 200;
    static int g_consoleMaxLines = 50;
    static std::vector<ConsoleLine> g_consoleLines;

    // Debug drawing
    static bool g_debugDrawEnabled = false;
    static bool g_debugDrawPersistent = false;
    static std::vector<DebugShape> g_debugShapes;

    // Debug overlay flags
    static bool g_showFPS = true;
    static bool g_showFrameTime = false;
    static bool g_showDrawCalls = false;
    static bool g_showEntityCount = true;
    static bool g_showMemory = false;
    static bool g_showPhysics = false;
    static bool g_showColliders = false;
    static float g_overlayX = 10;
    static float g_overlayY = 10;
    static Color g_overlayColor = { 255, 255, 255, 255 };

    // Frame timing
    float Framework_Perf_GetFPS() {
        return (float)GetFPS();
    }

    float Framework_Perf_GetFrameTime() {
        return g_currentFrameTime;
    }

    float Framework_Perf_GetFrameTimeAvg() {
        if (g_frameTimeHistory.empty()) return 0;
        float sum = 0;
        for (float t : g_frameTimeHistory) sum += t;
        return sum / g_frameTimeHistory.size();
    }

    float Framework_Perf_GetFrameTimeMin() {
        if (g_frameTimeHistory.empty()) return 0;
        float minVal = g_frameTimeHistory[0];
        for (float t : g_frameTimeHistory) if (t < minVal) minVal = t;
        return minVal;
    }

    float Framework_Perf_GetFrameTimeMax() {
        if (g_frameTimeHistory.empty()) return 0;
        float maxVal = g_frameTimeHistory[0];
        for (float t : g_frameTimeHistory) if (t > maxVal) maxVal = t;
        return maxVal;
    }

    void Framework_Perf_SetSampleCount(int count) {
        if (count > 0) {
            g_perfSampleCount = count;
            while ((int)g_frameTimeHistory.size() > count) {
                g_frameTimeHistory.erase(g_frameTimeHistory.begin());
            }
        }
    }

    int Framework_Perf_GetFrameCount() {
        return g_totalFrameCount;
    }

    // Draw call tracking
    int Framework_Perf_GetDrawCalls() {
        return g_drawCallCount;
    }

    int Framework_Perf_GetTriangleCount() {
        return g_triangleCount;
    }

    void Framework_Perf_ResetDrawStats() {
        g_drawCallCount = 0;
        g_triangleCount = 0;
    }

    // Memory tracking
    int Framework_Perf_GetEntityCount() {
        return (int)g_entities.size();
    }

    int Framework_Perf_GetTextureCount() {
        return (int)g_texByHandle.size();
    }

    int Framework_Perf_GetSoundCount() {
        return (int)g_sounds.size();
    }

    int Framework_Perf_GetFontCount() {
        return (int)g_fontByHandle.size();
    }

    long long Framework_Perf_GetTextureMemory() {
        long long total = 0;
        for (auto& kv : g_texByHandle) {
            if (kv.second.valid) {
                total += kv.second.tex.width * kv.second.tex.height * 4;  // Assume RGBA
            }
        }
        return total;
    }

    // Profiling scopes
    void Framework_Perf_BeginScope(const char* name) {
        if (!name) return;
        g_scopeStack.push_back(name);
        g_perfScopes[name].name = name;
        g_perfScopes[name].startTime = GetTime();
    }

    void Framework_Perf_EndScope() {
        if (g_scopeStack.empty()) return;
        std::string name = g_scopeStack.back();
        g_scopeStack.pop_back();

        auto it = g_perfScopes.find(name);
        if (it != g_perfScopes.end()) {
            double elapsed = (GetTime() - it->second.startTime) * 1000.0;  // Convert to ms
            it->second.lastTime = elapsed;
            it->second.totalTime += elapsed;
            it->second.callCount++;
        }
    }

    float Framework_Perf_GetScopeTime(const char* name) {
        if (!name) return 0;
        auto it = g_perfScopes.find(name);
        return (it != g_perfScopes.end()) ? (float)it->second.lastTime : 0;
    }

    float Framework_Perf_GetScopeTimeAvg(const char* name) {
        if (!name) return 0;
        auto it = g_perfScopes.find(name);
        if (it == g_perfScopes.end() || it->second.callCount == 0) return 0;
        return (float)(it->second.totalTime / it->second.callCount);
    }

    int Framework_Perf_GetScopeCallCount(const char* name) {
        if (!name) return 0;
        auto it = g_perfScopes.find(name);
        return (it != g_perfScopes.end()) ? it->second.callCount : 0;
    }

    void Framework_Perf_ResetScopes() {
        g_perfScopes.clear();
        g_scopeStack.clear();
    }

    // Performance graphs
    void Framework_Perf_SetGraphEnabled(bool enabled) {
        g_perfGraphEnabled = enabled;
    }

    void Framework_Perf_SetGraphPosition(float x, float y) {
        g_perfGraphX = x;
        g_perfGraphY = y;
    }

    void Framework_Perf_SetGraphSize(float width, float height) {
        g_perfGraphWidth = width;
        g_perfGraphHeight = height;
    }

    void Framework_Perf_DrawGraph() {
        if (!g_perfGraphEnabled || g_frameTimeHistory.empty()) return;

        // Background
        DrawRectangle((int)g_perfGraphX, (int)g_perfGraphY, (int)g_perfGraphWidth, (int)g_perfGraphHeight, Color{ 0, 0, 0, 180 });
        DrawRectangleLinesEx(Rectangle{ g_perfGraphX, g_perfGraphY, g_perfGraphWidth, g_perfGraphHeight }, 1, Color{ 100, 100, 100, 255 });

        // Find max frame time for scaling
        float maxTime = 16.67f;  // Minimum scale of 60 FPS target
        for (float t : g_frameTimeHistory) {
            if (t > maxTime) maxTime = t;
        }

        // Draw frame time bars
        int count = (int)g_frameTimeHistory.size();
        float barWidth = g_perfGraphWidth / g_perfSampleCount;

        for (int i = 0; i < count; i++) {
            float t = g_frameTimeHistory[i];
            float height = (t / maxTime) * g_perfGraphHeight;
            float x = g_perfGraphX + i * barWidth;
            float y = g_perfGraphY + g_perfGraphHeight - height;

            Color col = GREEN;
            if (t > 16.67f) col = YELLOW;
            if (t > 33.33f) col = RED;

            DrawRectangle((int)x, (int)y, (int)barWidth - 1, (int)height, col);
        }

        // Draw 60 FPS line
        float targetY = g_perfGraphY + g_perfGraphHeight - (16.67f / maxTime) * g_perfGraphHeight;
        DrawLine((int)g_perfGraphX, (int)targetY, (int)(g_perfGraphX + g_perfGraphWidth), (int)targetY, Color{ 0, 255, 0, 128 });

        // Labels
        char buf[64];
        snprintf(buf, sizeof(buf), "%.1f ms", g_currentFrameTime);
        DrawText(buf, (int)g_perfGraphX + 2, (int)g_perfGraphY + 2, 10, WHITE);
    }

    // Console/Logging
    void Framework_Log(int level, const char* message) {
        if (!message || level < g_logMinLevel) return;

        const char* levelStr = "INFO";
        switch (level) {
            case LOG_LEVEL_TRACE: levelStr = "TRACE"; break;
            case LOG_LEVEL_DEBUG: levelStr = "DEBUG"; break;
            case LOG_LEVEL_INFO: levelStr = "INFO"; break;
            case LOG_LEVEL_WARNING: levelStr = "WARN"; break;
            case LOG_LEVEL_ERROR: levelStr = "ERROR"; break;
            case LOG_LEVEL_FATAL: levelStr = "FATAL"; break;
        }

        char buf[512];
        snprintf(buf, sizeof(buf), "[%s] %s", levelStr, message);

        // Output to raylib log
        TraceLog(LOG_INFO, "%s", buf);

        // Output to file if open
        if (g_logFileOpen && g_logFile.is_open()) {
            g_logFile << buf << std::endl;
        }

        // Add to console
        Color col = WHITE;
        switch (level) {
            case LOG_LEVEL_TRACE: col = GRAY; break;
            case LOG_LEVEL_DEBUG: col = LIGHTGRAY; break;
            case LOG_LEVEL_INFO: col = WHITE; break;
            case LOG_LEVEL_WARNING: col = YELLOW; break;
            case LOG_LEVEL_ERROR: col = RED; break;
            case LOG_LEVEL_FATAL: col = MAROON; break;
        }
        Framework_Console_PrintColored(buf, col.r, col.g, col.b);
    }

    void Framework_Log_SetMinLevel(int level) {
        g_logMinLevel = level;
    }

    int Framework_Log_GetMinLevel() {
        return g_logMinLevel;
    }

    void Framework_Log_SetFileOutput(const char* filename) {
        if (g_logFileOpen) {
            g_logFile.close();
        }
        if (filename) {
            g_logFile.open(filename, std::ios::out | std::ios::app);
            g_logFileOpen = g_logFile.is_open();
        }
    }

    void Framework_Log_CloseFile() {
        if (g_logFileOpen) {
            g_logFile.close();
            g_logFileOpen = false;
        }
    }

    // On-screen console
    void Framework_Console_SetEnabled(bool enabled) {
        g_consoleEnabled = enabled;
    }

    bool Framework_Console_IsEnabled() {
        return g_consoleEnabled;
    }

    void Framework_Console_SetPosition(float x, float y) {
        g_consoleX = x;
        g_consoleY = y;
    }

    void Framework_Console_SetSize(float width, float height) {
        g_consoleWidth = width;
        g_consoleHeight = height;
    }

    void Framework_Console_SetMaxLines(int maxLines) {
        g_consoleMaxLines = maxLines;
        while ((int)g_consoleLines.size() > maxLines) {
            g_consoleLines.erase(g_consoleLines.begin());
        }
    }

    void Framework_Console_Clear() {
        g_consoleLines.clear();
    }

    void Framework_Console_Print(const char* message) {
        Framework_Console_PrintColored(message, 255, 255, 255);
    }

    void Framework_Console_PrintColored(const char* message, unsigned char r, unsigned char g, unsigned char b) {
        if (!message) return;

        ConsoleLine line;
        line.text = message;
        line.color = Color{ r, g, b, 255 };
        g_consoleLines.push_back(line);

        while ((int)g_consoleLines.size() > g_consoleMaxLines) {
            g_consoleLines.erase(g_consoleLines.begin());
        }
    }

    void Framework_Console_Draw() {
        if (!g_consoleEnabled) return;

        // Background
        DrawRectangle((int)g_consoleX, (int)g_consoleY, (int)g_consoleWidth, (int)g_consoleHeight, Color{ 0, 0, 0, 200 });
        DrawRectangleLinesEx(Rectangle{ g_consoleX, g_consoleY, g_consoleWidth, g_consoleHeight }, 1, Color{ 100, 100, 100, 255 });

        // Draw lines from bottom up
        int lineHeight = 12;
        int maxVisible = (int)(g_consoleHeight / lineHeight) - 1;
        int startLine = std::max(0, (int)g_consoleLines.size() - maxVisible);

        float y = g_consoleY + g_consoleHeight - lineHeight - 2;
        for (int i = (int)g_consoleLines.size() - 1; i >= startLine && y > g_consoleY; i--) {
            DrawText(g_consoleLines[i].text.c_str(), (int)g_consoleX + 4, (int)y, 10, g_consoleLines[i].color);
            y -= lineHeight;
        }
    }

    // Debug drawing
    void Framework_DebugDraw_Line(float x1, float y1, float x2, float y2, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        if (!g_debugDrawEnabled) return;
        DebugShape shape;
        shape.type = DebugShape::LINE;
        shape.x1 = x1; shape.y1 = y1;
        shape.x2 = x2; shape.y2 = y2;
        shape.color = Color{ r, g, b, a };
        g_debugShapes.push_back(shape);
    }

    void Framework_DebugDraw_Rect(float x, float y, float w, float h, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        if (!g_debugDrawEnabled) return;
        DebugShape shape;
        shape.type = DebugShape::RECT;
        shape.x1 = x; shape.y1 = y;
        shape.x2 = w; shape.y2 = h;
        shape.color = Color{ r, g, b, a };
        g_debugShapes.push_back(shape);
    }

    void Framework_DebugDraw_RectFilled(float x, float y, float w, float h, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        if (!g_debugDrawEnabled) return;
        DebugShape shape;
        shape.type = DebugShape::RECT_FILLED;
        shape.x1 = x; shape.y1 = y;
        shape.x2 = w; shape.y2 = h;
        shape.color = Color{ r, g, b, a };
        g_debugShapes.push_back(shape);
    }

    void Framework_DebugDraw_Circle(float x, float y, float radius, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        if (!g_debugDrawEnabled) return;
        DebugShape shape;
        shape.type = DebugShape::CIRCLE;
        shape.x1 = x; shape.y1 = y;
        shape.size = radius;
        shape.color = Color{ r, g, b, a };
        g_debugShapes.push_back(shape);
    }

    void Framework_DebugDraw_CircleFilled(float x, float y, float radius, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        if (!g_debugDrawEnabled) return;
        DebugShape shape;
        shape.type = DebugShape::CIRCLE_FILLED;
        shape.x1 = x; shape.y1 = y;
        shape.size = radius;
        shape.color = Color{ r, g, b, a };
        g_debugShapes.push_back(shape);
    }

    void Framework_DebugDraw_Point(float x, float y, float size, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        if (!g_debugDrawEnabled) return;
        DebugShape shape;
        shape.type = DebugShape::POINT;
        shape.x1 = x; shape.y1 = y;
        shape.size = size;
        shape.color = Color{ r, g, b, a };
        g_debugShapes.push_back(shape);
    }

    void Framework_DebugDraw_Arrow(float x1, float y1, float x2, float y2, float headSize, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        if (!g_debugDrawEnabled) return;
        DebugShape shape;
        shape.type = DebugShape::ARROW;
        shape.x1 = x1; shape.y1 = y1;
        shape.x2 = x2; shape.y2 = y2;
        shape.size = headSize;
        shape.color = Color{ r, g, b, a };
        g_debugShapes.push_back(shape);
    }

    void Framework_DebugDraw_Text(float x, float y, const char* text, unsigned char r, unsigned char g, unsigned char b) {
        if (!g_debugDrawEnabled || !text) return;
        DebugShape shape;
        shape.type = DebugShape::TEXT;
        shape.x1 = x; shape.y1 = y;
        shape.text = text;
        shape.color = Color{ r, g, b, 255 };
        g_debugShapes.push_back(shape);
    }

    void Framework_DebugDraw_Grid(float cellSize, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        if (!g_debugDrawEnabled) return;
        DebugShape shape;
        shape.type = DebugShape::GRID;
        shape.size = cellSize;
        shape.color = Color{ r, g, b, a };
        g_debugShapes.push_back(shape);
    }

    void Framework_DebugDraw_Cross(float x, float y, float size, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        if (!g_debugDrawEnabled) return;
        DebugShape shape;
        shape.type = DebugShape::CROSS;
        shape.x1 = x; shape.y1 = y;
        shape.size = size;
        shape.color = Color{ r, g, b, a };
        g_debugShapes.push_back(shape);
    }

    void Framework_DebugDraw_SetEnabled(bool enabled) {
        g_debugDrawEnabled = enabled;
    }

    bool Framework_DebugDraw_IsEnabled() {
        return g_debugDrawEnabled;
    }

    void Framework_DebugDraw_SetPersistent(bool persistent) {
        g_debugDrawPersistent = persistent;
    }

    void Framework_DebugDraw_Clear() {
        g_debugShapes.clear();
    }

    void Framework_DebugDraw_Flush() {
        if (!g_debugDrawEnabled) return;

        for (auto& shape : g_debugShapes) {
            switch (shape.type) {
                case DebugShape::LINE:
                    DrawLineV(Vector2{ shape.x1, shape.y1 }, Vector2{ shape.x2, shape.y2 }, shape.color);
                    break;
                case DebugShape::RECT:
                    DrawRectangleLinesEx(Rectangle{ shape.x1, shape.y1, shape.x2, shape.y2 }, 1, shape.color);
                    break;
                case DebugShape::RECT_FILLED:
                    DrawRectangle((int)shape.x1, (int)shape.y1, (int)shape.x2, (int)shape.y2, shape.color);
                    break;
                case DebugShape::CIRCLE:
                    DrawCircleLines((int)shape.x1, (int)shape.y1, shape.size, shape.color);
                    break;
                case DebugShape::CIRCLE_FILLED:
                    DrawCircle((int)shape.x1, (int)shape.y1, shape.size, shape.color);
                    break;
                case DebugShape::POINT:
                    DrawCircle((int)shape.x1, (int)shape.y1, shape.size, shape.color);
                    break;
                case DebugShape::ARROW: {
                    DrawLineV(Vector2{ shape.x1, shape.y1 }, Vector2{ shape.x2, shape.y2 }, shape.color);
                    // Draw arrow head
                    float dx = shape.x2 - shape.x1;
                    float dy = shape.y2 - shape.y1;
                    float len = sqrtf(dx * dx + dy * dy);
                    if (len > 0) {
                        dx /= len; dy /= len;
                        float px = -dy, py = dx;  // Perpendicular
                        float ax = shape.x2 - dx * shape.size;
                        float ay = shape.y2 - dy * shape.size;
                        DrawLineV(Vector2{ shape.x2, shape.y2 }, Vector2{ ax + px * shape.size * 0.5f, ay + py * shape.size * 0.5f }, shape.color);
                        DrawLineV(Vector2{ shape.x2, shape.y2 }, Vector2{ ax - px * shape.size * 0.5f, ay - py * shape.size * 0.5f }, shape.color);
                    }
                    break;
                }
                case DebugShape::TEXT:
                    DrawText(shape.text.c_str(), (int)shape.x1, (int)shape.y1, 10, shape.color);
                    break;
                case DebugShape::GRID: {
                    int screenW = GetScreenWidth();
                    int screenH = GetScreenHeight();
                    for (float x = 0; x < screenW; x += shape.size) {
                        DrawLine((int)x, 0, (int)x, screenH, shape.color);
                    }
                    for (float y = 0; y < screenH; y += shape.size) {
                        DrawLine(0, (int)y, screenW, (int)y, shape.color);
                    }
                    break;
                }
                case DebugShape::CROSS:
                    DrawLine((int)(shape.x1 - shape.size), (int)shape.y1, (int)(shape.x1 + shape.size), (int)shape.y1, shape.color);
                    DrawLine((int)shape.x1, (int)(shape.y1 - shape.size), (int)shape.x1, (int)(shape.y1 + shape.size), shape.color);
                    break;
            }
        }

        if (!g_debugDrawPersistent) {
            g_debugShapes.clear();
        }
    }

    // System overlays
    void Framework_Debug_SetShowFPS(bool show) { g_showFPS = show; }
    void Framework_Debug_SetShowFrameTime(bool show) { g_showFrameTime = show; }
    void Framework_Debug_SetShowDrawCalls(bool show) { g_showDrawCalls = show; }
    void Framework_Debug_SetShowEntityCount(bool show) { g_showEntityCount = show; }
    void Framework_Debug_SetShowMemory(bool show) { g_showMemory = show; }
    void Framework_Debug_SetShowPhysics(bool show) { g_showPhysics = show; }
    void Framework_Debug_SetShowColliders(bool show) { g_showColliders = show; }

    void Framework_Debug_SetOverlayPosition(float x, float y) {
        g_overlayX = x;
        g_overlayY = y;
    }

    void Framework_Debug_SetOverlayColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        g_overlayColor = Color{ r, g, b, a };
    }

    // Frame profiling
    void Framework_Perf_BeginFrame() {
        g_frameStartTime = GetTime();
        Framework_Perf_ResetDrawStats();
    }

    void Framework_Perf_EndFrame() {
        g_currentFrameTime = (float)((GetTime() - g_frameStartTime) * 1000.0);
        g_totalFrameCount++;

        // Add to history
        g_frameTimeHistory.push_back(g_currentFrameTime);
        while ((int)g_frameTimeHistory.size() > g_perfSampleCount) {
            g_frameTimeHistory.erase(g_frameTimeHistory.begin());
        }
    }

    // ========================================================================
    // PERFORMANCE OPTIMIZATION SYSTEM - Implementation
    // ========================================================================

    // Spatial Grid structure
    struct SpatialCell {
        std::unordered_set<int> entities;
    };

    struct SpatialGrid {
        int id = -1;
        float worldWidth = 0;
        float worldHeight = 0;
        float cellSize = 64;
        int cols = 0;
        int rows = 0;
        std::vector<SpatialCell> cells;
        std::unordered_map<int, std::pair<int, int>> entityCells;  // entity -> (col, row)
        bool debugDraw = false;
        bool valid = true;
    };
    static std::unordered_map<int, SpatialGrid> g_spatialGrids;
    static int g_nextSpatialGridId = 1;

    // Culling state
    static bool g_cullingEnabled = false;
    static float g_cullViewX = 0, g_cullViewY = 0;
    static float g_cullViewW = 800, g_cullViewH = 600;
    static float g_cullPadding = 64;
    static int g_visibleCount = 0;
    static int g_culledCount = 0;

    // Memory tracking state
    static bool g_memoryTracking = false;
    static long long g_memoryAllocated = 0;
    static long long g_memoryFreed = 0;
    static long long g_memoryPeak = 0;
    static int g_allocationCount = 0;
    static int g_freeCount = 0;
    static long long g_memoryWarningThreshold = 512 * 1024 * 1024;  // 512MB default

    // Frame budget state
    static int g_targetFPS = 60;
    static float g_budgetWarningPercent = 80.0f;
    static int g_overBudgetFrames = 0;

    // Async loading state
    struct AsyncLoadRequest {
        int id = -1;
        int type = 0;  // 0=texture, 1=sound, 2=font
        std::string path;
        int fontSize = 0;  // For fonts
        bool complete = false;
        bool failed = false;
        float progress = 0.0f;
        int resultHandle = -1;
    };
    static std::unordered_map<int, AsyncLoadRequest> g_asyncRequests;
    static int g_nextAsyncRequestId = 1;
    static int g_maxConcurrentLoads = 4;

    // Render stats
    static int g_batchCount = 0;
    static int g_spritesRendered = 0;
    static int g_textureSwaps = 0;
    static bool g_autoBatching = true;

    // Performance warnings
    static void (*g_perfWarningCallback)(const char*) = nullptr;
    static bool g_perfWarningsEnabled = false;
    static int g_entityWarningThreshold = 10000;
    static int g_drawCallWarningThreshold = 500;
    static long long g_memoryWarningThresholdPerf = 256 * 1024 * 1024;

    // Helper: Get cell index from world position
    static int GetCellIndex(const SpatialGrid& grid, float x, float y) {
        int col = (int)(x / grid.cellSize);
        int row = (int)(y / grid.cellSize);
        if (col < 0) col = 0;
        if (row < 0) row = 0;
        if (col >= grid.cols) col = grid.cols - 1;
        if (row >= grid.rows) row = grid.rows - 1;
        return row * grid.cols + col;
    }

    // Spatial Partitioning
    int Framework_Spatial_CreateGrid(float worldWidth, float worldHeight, float cellSize) {
        SpatialGrid grid;
        grid.id = g_nextSpatialGridId++;
        grid.worldWidth = worldWidth;
        grid.worldHeight = worldHeight;
        grid.cellSize = cellSize > 0 ? cellSize : 64;
        grid.cols = (int)ceilf(worldWidth / grid.cellSize);
        grid.rows = (int)ceilf(worldHeight / grid.cellSize);
        grid.cells.resize(grid.cols * grid.rows);
        g_spatialGrids[grid.id] = grid;
        return grid.id;
    }

    void Framework_Spatial_DestroyGrid(int gridId) {
        g_spatialGrids.erase(gridId);
    }

    void Framework_Spatial_Clear(int gridId) {
        auto it = g_spatialGrids.find(gridId);
        if (it == g_spatialGrids.end()) return;
        for (auto& cell : it->second.cells) {
            cell.entities.clear();
        }
        it->second.entityCells.clear();
    }

    void Framework_Spatial_InsertEntity(int gridId, int entity) {
        auto it = g_spatialGrids.find(gridId);
        if (it == g_spatialGrids.end()) return;

        auto trIt = g_transform2D.find(entity);
        if (trIt == g_transform2D.end()) return;

        float x = trIt->second.position.x;
        float y = trIt->second.position.y;
        int cellIdx = GetCellIndex(it->second, x, y);
        int col = cellIdx % it->second.cols;
        int row = cellIdx / it->second.cols;

        it->second.cells[cellIdx].entities.insert(entity);
        it->second.entityCells[entity] = { col, row };
    }

    void Framework_Spatial_RemoveEntity(int gridId, int entity) {
        auto it = g_spatialGrids.find(gridId);
        if (it == g_spatialGrids.end()) return;

        auto cellIt = it->second.entityCells.find(entity);
        if (cellIt != it->second.entityCells.end()) {
            int cellIdx = cellIt->second.second * it->second.cols + cellIt->second.first;
            it->second.cells[cellIdx].entities.erase(entity);
            it->second.entityCells.erase(entity);
        }
    }

    void Framework_Spatial_UpdateEntity(int gridId, int entity) {
        Framework_Spatial_RemoveEntity(gridId, entity);
        Framework_Spatial_InsertEntity(gridId, entity);
    }

    void Framework_Spatial_UpdateAll(int gridId) {
        auto it = g_spatialGrids.find(gridId);
        if (it == g_spatialGrids.end()) return;

        // Collect all entities
        std::vector<int> entities;
        for (const auto& kv : it->second.entityCells) {
            entities.push_back(kv.first);
        }

        // Clear and reinsert
        Framework_Spatial_Clear(gridId);
        for (int e : entities) {
            Framework_Spatial_InsertEntity(gridId, e);
        }
    }

    int Framework_Spatial_QueryRect(int gridId, float x, float y, float w, float h, int* outEntities, int maxResults) {
        auto it = g_spatialGrids.find(gridId);
        if (it == g_spatialGrids.end() || !outEntities) return 0;

        int startCol = (int)(x / it->second.cellSize);
        int startRow = (int)(y / it->second.cellSize);
        int endCol = (int)((x + w) / it->second.cellSize);
        int endRow = (int)((y + h) / it->second.cellSize);

        if (startCol < 0) startCol = 0;
        if (startRow < 0) startRow = 0;
        if (endCol >= it->second.cols) endCol = it->second.cols - 1;
        if (endRow >= it->second.rows) endRow = it->second.rows - 1;

        int count = 0;
        std::unordered_set<int> added;
        for (int row = startRow; row <= endRow && count < maxResults; row++) {
            for (int col = startCol; col <= endCol && count < maxResults; col++) {
                int cellIdx = row * it->second.cols + col;
                for (int e : it->second.cells[cellIdx].entities) {
                    if (added.find(e) == added.end() && count < maxResults) {
                        outEntities[count++] = e;
                        added.insert(e);
                    }
                }
            }
        }
        return count;
    }

    int Framework_Spatial_QueryCircle(int gridId, float cx, float cy, float radius, int* outEntities, int maxResults) {
        return Framework_Spatial_QueryRect(gridId, cx - radius, cy - radius, radius * 2, radius * 2, outEntities, maxResults);
    }

    int Framework_Spatial_QueryPoint(int gridId, float x, float y, int* outEntities, int maxResults) {
        auto it = g_spatialGrids.find(gridId);
        if (it == g_spatialGrids.end() || !outEntities) return 0;

        int cellIdx = GetCellIndex(it->second, x, y);
        int count = 0;
        for (int e : it->second.cells[cellIdx].entities) {
            if (count < maxResults) {
                outEntities[count++] = e;
            }
        }
        return count;
    }

    int Framework_Spatial_GetNearestEntity(int gridId, float x, float y, float maxDist) {
        int entities[100];
        int count = Framework_Spatial_QueryCircle(gridId, x, y, maxDist, entities, 100);

        int nearest = -1;
        float nearestDist = maxDist * maxDist;
        for (int i = 0; i < count; i++) {
            auto trIt = g_transform2D.find(entities[i]);
            if (trIt != g_transform2D.end()) {
                float dx = trIt->second.position.x - x;
                float dy = trIt->second.position.y - y;
                float dist = dx * dx + dy * dy;
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = entities[i];
                }
            }
        }
        return nearest;
    }

    int Framework_Spatial_GetCellCount(int gridId) {
        auto it = g_spatialGrids.find(gridId);
        return (it != g_spatialGrids.end()) ? it->second.cols * it->second.rows : 0;
    }

    int Framework_Spatial_GetEntityCount(int gridId) {
        auto it = g_spatialGrids.find(gridId);
        return (it != g_spatialGrids.end()) ? (int)it->second.entityCells.size() : 0;
    }

    void Framework_Spatial_SetDebugDraw(int gridId, bool enabled) {
        auto it = g_spatialGrids.find(gridId);
        if (it != g_spatialGrids.end()) it->second.debugDraw = enabled;
    }

    // Viewport Culling
    void Framework_Culling_SetEnabled(bool enabled) { g_cullingEnabled = enabled; }
    bool Framework_Culling_IsEnabled() { return g_cullingEnabled; }

    void Framework_Culling_SetViewport(float x, float y, float width, float height) {
        g_cullViewX = x;
        g_cullViewY = y;
        g_cullViewW = width;
        g_cullViewH = height;
    }

    void Framework_Culling_SetPadding(float padding) { g_cullPadding = padding; }

    bool Framework_Culling_IsVisible(int entity) {
        if (!g_cullingEnabled) return true;

        auto trIt = g_transform2D.find(entity);
        if (trIt == g_transform2D.end()) return true;

        float ex = trIt->second.position.x;
        float ey = trIt->second.position.y;
        float size = 32.0f;  // Default size estimate

        auto sprIt = g_sprite2D.find(entity);
        if (sprIt != g_sprite2D.end()) {
            size = fmaxf(sprIt->second.source.width, sprIt->second.source.height) *
                   fmaxf(trIt->second.scale.x, trIt->second.scale.y);
        }

        return Framework_Culling_IsRectVisible(ex - size/2, ey - size/2, size, size);
    }

    bool Framework_Culling_IsRectVisible(float x, float y, float w, float h) {
        float vx = g_cullViewX - g_cullPadding;
        float vy = g_cullViewY - g_cullPadding;
        float vw = g_cullViewW + g_cullPadding * 2;
        float vh = g_cullViewH + g_cullPadding * 2;

        return !(x + w < vx || x > vx + vw || y + h < vy || y > vy + vh);
    }

    int Framework_Culling_GetVisibleCount() { return g_visibleCount; }
    int Framework_Culling_GetCulledCount() { return g_culledCount; }

    // Memory Tracking
    void Framework_Memory_BeginTracking() {
        g_memoryTracking = true;
        g_memoryAllocated = 0;
        g_memoryFreed = 0;
        g_memoryPeak = 0;
        g_allocationCount = 0;
        g_freeCount = 0;
    }

    void Framework_Memory_EndTracking() {
        g_memoryTracking = false;
    }

    long long Framework_Memory_GetTotalAllocated() { return g_memoryAllocated; }
    long long Framework_Memory_GetCurrentUsage() { return g_memoryAllocated - g_memoryFreed; }
    long long Framework_Memory_GetPeakUsage() { return g_memoryPeak; }
    int Framework_Memory_GetAllocationCount() { return g_allocationCount; }
    int Framework_Memory_GetActiveAllocations() { return g_allocationCount - g_freeCount; }
    void Framework_Memory_ResetPeak() { g_memoryPeak = g_memoryAllocated - g_memoryFreed; }

    void Framework_Memory_DumpLeaks() {
        TraceLog(LOG_WARNING, "MEMORY: Active allocations: %d", g_allocationCount - g_freeCount);
        TraceLog(LOG_WARNING, "MEMORY: Current usage: %lld bytes", g_memoryAllocated - g_memoryFreed);
    }

    void Framework_Memory_SetWarningThreshold(long long bytes) { g_memoryWarningThreshold = bytes; }
    bool Framework_Memory_IsOverBudget() { return (g_memoryAllocated - g_memoryFreed) > g_memoryWarningThreshold; }

    // Frame Budget System
    void Framework_Budget_SetTargetFPS(int fps) { g_targetFPS = fps > 0 ? fps : 60; }
    void Framework_Budget_SetWarningThreshold(float percent) { g_budgetWarningPercent = percent; }

    float Framework_Budget_GetTargetFrameTime() {
        return 1000.0f / (float)g_targetFPS;
    }

    float Framework_Budget_GetBudgetUsed() {
        float target = Framework_Budget_GetTargetFrameTime();
        return (g_currentFrameTime / target) * 100.0f;
    }

    float Framework_Budget_GetBudgetRemaining() {
        return Framework_Budget_GetTargetFrameTime() - g_currentFrameTime;
    }

    bool Framework_Budget_IsOverBudget() {
        return g_currentFrameTime > Framework_Budget_GetTargetFrameTime();
    }

    int Framework_Budget_GetOverBudgetFrames() { return g_overBudgetFrames; }
    void Framework_Budget_ResetStats() { g_overBudgetFrames = 0; }

    // Async Asset Loading (simplified - synchronous for now, tracks requests)
    int Framework_Async_LoadTexture(const char* path) {
        AsyncLoadRequest req;
        req.id = g_nextAsyncRequestId++;
        req.type = 0;
        req.path = path ? path : "";
        // For simplicity, load synchronously
        req.resultHandle = Framework_AcquireTextureH(path);
        req.complete = req.resultHandle > 0;
        req.failed = req.resultHandle <= 0;
        req.progress = 1.0f;
        g_asyncRequests[req.id] = req;
        return req.id;
    }

    int Framework_Async_LoadSound(const char* path) {
        AsyncLoadRequest req;
        req.id = g_nextAsyncRequestId++;
        req.type = 1;
        req.path = path ? path : "";
        req.resultHandle = Framework_Audio_LoadSound(path, AUDIO_GROUP_SFX);
        req.complete = req.resultHandle > 0;
        req.failed = req.resultHandle <= 0;
        req.progress = 1.0f;
        g_asyncRequests[req.id] = req;
        return req.id;
    }

    int Framework_Async_LoadFont(const char* path, int size) {
        AsyncLoadRequest req;
        req.id = g_nextAsyncRequestId++;
        req.type = 2;
        req.path = path ? path : "";
        req.fontSize = size;
        req.resultHandle = Framework_AcquireFontH(path, size);
        req.complete = req.resultHandle > 0;
        req.failed = req.resultHandle <= 0;
        req.progress = 1.0f;
        g_asyncRequests[req.id] = req;
        return req.id;
    }

    bool Framework_Async_IsComplete(int requestId) {
        auto it = g_asyncRequests.find(requestId);
        return (it != g_asyncRequests.end()) ? it->second.complete : false;
    }

    bool Framework_Async_IsFailed(int requestId) {
        auto it = g_asyncRequests.find(requestId);
        return (it != g_asyncRequests.end()) ? it->second.failed : true;
    }

    float Framework_Async_GetProgress(int requestId) {
        auto it = g_asyncRequests.find(requestId);
        return (it != g_asyncRequests.end()) ? it->second.progress : 0.0f;
    }

    int Framework_Async_GetResult(int requestId) {
        auto it = g_asyncRequests.find(requestId);
        return (it != g_asyncRequests.end() && it->second.complete) ? it->second.resultHandle : -1;
    }

    void Framework_Async_Cancel(int requestId) {
        g_asyncRequests.erase(requestId);
    }

    void Framework_Async_CancelAll() {
        g_asyncRequests.clear();
    }

    int Framework_Async_GetPendingCount() {
        int count = 0;
        for (const auto& kv : g_asyncRequests) {
            if (!kv.second.complete && !kv.second.failed) count++;
        }
        return count;
    }

    void Framework_Async_SetMaxConcurrent(int maxLoads) { g_maxConcurrentLoads = maxLoads; }
    void Framework_Async_Update() { /* For future async implementation */ }

    // Object Pooling Statistics - Forward declarations (implementations after pool system)
    long long Framework_Pool_GetTotalMemoryImpl();
    int Framework_Pool_GetActivePoolCountImpl();
    int Framework_Pool_GetTotalObjectCountImpl();
    int Framework_Pool_GetTotalAcquiredImpl();
    void Framework_Pool_ShrinkAllImpl();

    long long Framework_Pool_GetTotalMemory() {
        return Framework_Pool_GetTotalMemoryImpl();
    }

    int Framework_Pool_GetActivePoolCount() {
        return Framework_Pool_GetActivePoolCountImpl();
    }

    int Framework_Pool_GetTotalObjectCount() {
        return Framework_Pool_GetTotalObjectCountImpl();
    }

    int Framework_Pool_GetTotalAcquired() {
        return Framework_Pool_GetTotalAcquiredImpl();
    }

    float Framework_Pool_GetUtilization() {
        int total = Framework_Pool_GetTotalObjectCount();
        int acquired = Framework_Pool_GetTotalAcquired();
        return total > 0 ? (float)acquired / (float)total * 100.0f : 0.0f;
    }

    void Framework_Pool_ShrinkAll() {
        Framework_Pool_ShrinkAllImpl();
    }

    // Batch Rendering Statistics
    int Framework_Render_GetBatchCount() { return g_batchCount; }
    int Framework_Render_GetSpritesRendered() { return g_spritesRendered; }
    int Framework_Render_GetTextureSwaps() { return g_textureSwaps; }
    void Framework_Render_SetAutoBatching(bool enabled) { g_autoBatching = enabled; }
    bool Framework_Render_IsAutoBatching() { return g_autoBatching; }

    // Performance Warnings
    void Framework_Perf_SetWarningCallback(void (*callback)(const char* message)) {
        g_perfWarningCallback = callback;
    }

    void Framework_Perf_EnableWarnings(bool enabled) { g_perfWarningsEnabled = enabled; }
    void Framework_Perf_SetEntityWarningThreshold(int count) { g_entityWarningThreshold = count; }
    void Framework_Perf_SetDrawCallWarningThreshold(int count) { g_drawCallWarningThreshold = count; }
    void Framework_Perf_SetMemoryWarningThreshold(long long bytes) { g_memoryWarningThresholdPerf = bytes; }

    // ========================================================================
    // RESOURCE VALIDATION / LEAK DETECTION
    // ========================================================================

    // Resource tracking callbacks
    static ResourceCreatedCallback g_resourceCreatedCallback = nullptr;
    static ResourceDestroyedCallback g_resourceDestroyedCallback = nullptr;
    static bool g_resourceTrackingEnabled = false;

    // Snapshot storage for leak detection
    struct ResourceSnapshot {
        int entities = 0;
        int textures = 0;
        int sounds = 0;
        int fonts = 0;
        int uiElements = 0;
        int physicsBodies = 0;
        int tweens = 0;
        int timers = 0;
        int pools = 0;
        int fsms = 0;
        int events = 0;
        int dialogues = 0;
        int quests = 0;
        int lights = 0;
        int emitters = 0;
        int batches = 0;
        int atlases = 0;
        int levels = 0;
        int skeletons = 0;
        int behaviorTrees = 0;
        int joints = 0;
        int spatialGrids = 0;
    };
    static ResourceSnapshot g_resourceSnapshot;
    static bool g_snapshotTaken = false;

    // Forward declarations for count functions (some resources defined later)
    int GetUIElementCountImpl();
    int GetTimerCountImpl();
    int GetTweenCountImpl();
    int GetPoolCountImpl();
    int GetFSMCountImpl();
    int GetEventCountImpl();
    int GetDialogueCountImpl();
    int GetQuestCountImpl();
    int GetLightCountImpl();
    int GetEmitterCountImpl();
    int GetBatchCountImpl();
    int GetAtlasCountImpl();
    int GetLevelCountImpl();
    int GetSkeletonCountImpl();
    int GetBehaviorTreeCountImpl();
    int GetJointCountImpl();
    int GetTextureCountImpl();
    int GetSoundCountImpl();
    int GetFontCountImpl();
    int GetPhysicsBodyCountImpl();
    int GetAnimClipCountImpl();
    int GetTilesetCountImpl();
    int GetInventoryCountImpl();

    // Resource counts by type
    int Framework_Resource_GetEntityCount() {
        return (int)g_entities.size();
    }

    int Framework_Resource_GetTextureCount() {
        return GetTextureCountImpl();
    }

    int Framework_Resource_GetSoundCount() {
        return GetSoundCountImpl();
    }

    int Framework_Resource_GetFontCount() {
        return GetFontCountImpl();
    }

    int Framework_Resource_GetUIElementCount() {
        return GetUIElementCountImpl();
    }

    int Framework_Resource_GetPhysicsBodyCount() {
        return GetPhysicsBodyCountImpl();
    }

    int Framework_Resource_GetAnimClipCount() {
        return GetAnimClipCountImpl();
    }

    int Framework_Resource_GetTilesetCount() {
        return GetTilesetCountImpl();
    }

    int Framework_Resource_GetInventoryCount() {
        return GetInventoryCountImpl();
    }

    int Framework_Resource_GetTweenCount() {
        return GetTweenCountImpl();
    }

    int Framework_Resource_GetTimerCount() {
        return GetTimerCountImpl();
    }

    int Framework_Resource_GetPoolCount() {
        return GetPoolCountImpl();
    }

    int Framework_Resource_GetFSMCount() {
        return GetFSMCountImpl();
    }

    int Framework_Resource_GetEventCount() {
        return GetEventCountImpl();
    }

    int Framework_Resource_GetDialogueCount() {
        return GetDialogueCountImpl();
    }

    int Framework_Resource_GetQuestCount() {
        return GetQuestCountImpl();
    }

    int Framework_Resource_GetLightCount() {
        return GetLightCountImpl();
    }

    int Framework_Resource_GetEmitterCount() {
        return GetEmitterCountImpl();
    }

    int Framework_Resource_GetBatchCount() {
        return GetBatchCountImpl();
    }

    int Framework_Resource_GetAtlasCount() {
        return GetAtlasCountImpl();
    }

    int Framework_Resource_GetLevelCount() {
        return GetLevelCountImpl();
    }

    int Framework_Resource_GetSkeletonCount() {
        return GetSkeletonCountImpl();
    }

    int Framework_Resource_GetBehaviorTreeCount() {
        return GetBehaviorTreeCountImpl();
    }

    int Framework_Resource_GetJointCount() {
        return GetJointCountImpl();
    }

    int Framework_Resource_GetSpatialGridCount() {
        return (int)g_spatialGrids.size();
    }

    // Total active resources
    int Framework_Resource_GetTotalActiveCount() {
        return Framework_Resource_GetEntityCount() +
               Framework_Resource_GetTextureCount() +
               Framework_Resource_GetSoundCount() +
               Framework_Resource_GetFontCount() +
               Framework_Resource_GetUIElementCount() +
               Framework_Resource_GetPhysicsBodyCount() +
               Framework_Resource_GetTweenCount() +
               Framework_Resource_GetTimerCount() +
               Framework_Resource_GetPoolCount() +
               Framework_Resource_GetFSMCount() +
               Framework_Resource_GetEventCount() +
               Framework_Resource_GetDialogueCount() +
               Framework_Resource_GetQuestCount() +
               Framework_Resource_GetLightCount() +
               Framework_Resource_GetEmitterCount() +
               Framework_Resource_GetBatchCount() +
               Framework_Resource_GetAtlasCount() +
               Framework_Resource_GetLevelCount() +
               Framework_Resource_GetSkeletonCount() +
               Framework_Resource_GetBehaviorTreeCount() +
               Framework_Resource_GetJointCount() +
               Framework_Resource_GetSpatialGridCount();
    }

    // Check if any resources are still active (potential leaks)
    bool Framework_Resource_HasLeaks() {
        return Framework_Resource_GetTotalActiveCount() > 0;
    }

    // Validate all resources (returns true if no leaks)
    bool Framework_Resource_ValidateAll() {
        return !Framework_Resource_HasLeaks();
    }

    // Log detailed resource report
    void Framework_Resource_DumpReport() {
        TraceLog(LOG_INFO, "========================================");
        TraceLog(LOG_INFO, "RESOURCE REPORT");
        TraceLog(LOG_INFO, "========================================");
        TraceLog(LOG_INFO, "Entities:       %d", Framework_Resource_GetEntityCount());
        TraceLog(LOG_INFO, "Textures:       %d", Framework_Resource_GetTextureCount());
        TraceLog(LOG_INFO, "Sounds:         %d", Framework_Resource_GetSoundCount());
        TraceLog(LOG_INFO, "Fonts:          %d", Framework_Resource_GetFontCount());
        TraceLog(LOG_INFO, "UI Elements:    %d", Framework_Resource_GetUIElementCount());
        TraceLog(LOG_INFO, "Physics Bodies: %d", Framework_Resource_GetPhysicsBodyCount());
        TraceLog(LOG_INFO, "Tweens:         %d", Framework_Resource_GetTweenCount());
        TraceLog(LOG_INFO, "Timers:         %d", Framework_Resource_GetTimerCount());
        TraceLog(LOG_INFO, "Pools:          %d", Framework_Resource_GetPoolCount());
        TraceLog(LOG_INFO, "FSMs:           %d", Framework_Resource_GetFSMCount());
        TraceLog(LOG_INFO, "Events:         %d", Framework_Resource_GetEventCount());
        TraceLog(LOG_INFO, "Dialogues:      %d", Framework_Resource_GetDialogueCount());
        TraceLog(LOG_INFO, "Quests:         %d", Framework_Resource_GetQuestCount());
        TraceLog(LOG_INFO, "Lights:         %d", Framework_Resource_GetLightCount());
        TraceLog(LOG_INFO, "Emitters:       %d", Framework_Resource_GetEmitterCount());
        TraceLog(LOG_INFO, "Batches:        %d", Framework_Resource_GetBatchCount());
        TraceLog(LOG_INFO, "Atlases:        %d", Framework_Resource_GetAtlasCount());
        TraceLog(LOG_INFO, "Levels:         %d", Framework_Resource_GetLevelCount());
        TraceLog(LOG_INFO, "Skeletons:      %d", Framework_Resource_GetSkeletonCount());
        TraceLog(LOG_INFO, "BehaviorTrees:  %d", Framework_Resource_GetBehaviorTreeCount());
        TraceLog(LOG_INFO, "Joints:         %d", Framework_Resource_GetJointCount());
        TraceLog(LOG_INFO, "SpatialGrids:   %d", Framework_Resource_GetSpatialGridCount());
        TraceLog(LOG_INFO, "----------------------------------------");
        TraceLog(LOG_INFO, "TOTAL ACTIVE:   %d", Framework_Resource_GetTotalActiveCount());
        TraceLog(LOG_INFO, "========================================");
    }

    // Log only if there are leaks
    void Framework_Resource_DumpLeakReport() {
        if (Framework_Resource_HasLeaks()) {
            TraceLog(LOG_WARNING, "========================================");
            TraceLog(LOG_WARNING, "POTENTIAL RESOURCE LEAKS DETECTED");
            TraceLog(LOG_WARNING, "========================================");
            if (Framework_Resource_GetEntityCount() > 0)
                TraceLog(LOG_WARNING, "  Entities:       %d LEAKED", Framework_Resource_GetEntityCount());
            if (Framework_Resource_GetTextureCount() > 0)
                TraceLog(LOG_WARNING, "  Textures:       %d LEAKED", Framework_Resource_GetTextureCount());
            if (Framework_Resource_GetSoundCount() > 0)
                TraceLog(LOG_WARNING, "  Sounds:         %d LEAKED", Framework_Resource_GetSoundCount());
            if (Framework_Resource_GetFontCount() > 0)
                TraceLog(LOG_WARNING, "  Fonts:          %d LEAKED", Framework_Resource_GetFontCount());
            if (Framework_Resource_GetUIElementCount() > 0)
                TraceLog(LOG_WARNING, "  UI Elements:    %d LEAKED", Framework_Resource_GetUIElementCount());
            if (Framework_Resource_GetPhysicsBodyCount() > 0)
                TraceLog(LOG_WARNING, "  Physics Bodies: %d LEAKED", Framework_Resource_GetPhysicsBodyCount());
            if (Framework_Resource_GetTweenCount() > 0)
                TraceLog(LOG_WARNING, "  Tweens:         %d LEAKED", Framework_Resource_GetTweenCount());
            if (Framework_Resource_GetTimerCount() > 0)
                TraceLog(LOG_WARNING, "  Timers:         %d LEAKED", Framework_Resource_GetTimerCount());
            if (Framework_Resource_GetPoolCount() > 0)
                TraceLog(LOG_WARNING, "  Pools:          %d LEAKED", Framework_Resource_GetPoolCount());
            if (Framework_Resource_GetFSMCount() > 0)
                TraceLog(LOG_WARNING, "  FSMs:           %d LEAKED", Framework_Resource_GetFSMCount());
            if (Framework_Resource_GetEventCount() > 0)
                TraceLog(LOG_WARNING, "  Events:         %d LEAKED", Framework_Resource_GetEventCount());
            if (Framework_Resource_GetDialogueCount() > 0)
                TraceLog(LOG_WARNING, "  Dialogues:      %d LEAKED", Framework_Resource_GetDialogueCount());
            if (Framework_Resource_GetQuestCount() > 0)
                TraceLog(LOG_WARNING, "  Quests:         %d LEAKED", Framework_Resource_GetQuestCount());
            if (Framework_Resource_GetLightCount() > 0)
                TraceLog(LOG_WARNING, "  Lights:         %d LEAKED", Framework_Resource_GetLightCount());
            if (Framework_Resource_GetEmitterCount() > 0)
                TraceLog(LOG_WARNING, "  Emitters:       %d LEAKED", Framework_Resource_GetEmitterCount());
            if (Framework_Resource_GetBatchCount() > 0)
                TraceLog(LOG_WARNING, "  Batches:        %d LEAKED", Framework_Resource_GetBatchCount());
            if (Framework_Resource_GetAtlasCount() > 0)
                TraceLog(LOG_WARNING, "  Atlases:        %d LEAKED", Framework_Resource_GetAtlasCount());
            if (Framework_Resource_GetLevelCount() > 0)
                TraceLog(LOG_WARNING, "  Levels:         %d LEAKED", Framework_Resource_GetLevelCount());
            if (Framework_Resource_GetSkeletonCount() > 0)
                TraceLog(LOG_WARNING, "  Skeletons:      %d LEAKED", Framework_Resource_GetSkeletonCount());
            if (Framework_Resource_GetBehaviorTreeCount() > 0)
                TraceLog(LOG_WARNING, "  BehaviorTrees:  %d LEAKED", Framework_Resource_GetBehaviorTreeCount());
            if (Framework_Resource_GetJointCount() > 0)
                TraceLog(LOG_WARNING, "  Joints:         %d LEAKED", Framework_Resource_GetJointCount());
            if (Framework_Resource_GetSpatialGridCount() > 0)
                TraceLog(LOG_WARNING, "  SpatialGrids:   %d LEAKED", Framework_Resource_GetSpatialGridCount());
            TraceLog(LOG_WARNING, "========================================");
        }
    }

    // Snapshot-based leak detection
    void Framework_Resource_TakeSnapshot() {
        g_resourceSnapshot.entities = Framework_Resource_GetEntityCount();
        g_resourceSnapshot.textures = Framework_Resource_GetTextureCount();
        g_resourceSnapshot.sounds = Framework_Resource_GetSoundCount();
        g_resourceSnapshot.fonts = Framework_Resource_GetFontCount();
        g_resourceSnapshot.uiElements = Framework_Resource_GetUIElementCount();
        g_resourceSnapshot.physicsBodies = Framework_Resource_GetPhysicsBodyCount();
        g_resourceSnapshot.tweens = Framework_Resource_GetTweenCount();
        g_resourceSnapshot.timers = Framework_Resource_GetTimerCount();
        g_resourceSnapshot.pools = Framework_Resource_GetPoolCount();
        g_resourceSnapshot.fsms = Framework_Resource_GetFSMCount();
        g_resourceSnapshot.events = Framework_Resource_GetEventCount();
        g_resourceSnapshot.dialogues = Framework_Resource_GetDialogueCount();
        g_resourceSnapshot.quests = Framework_Resource_GetQuestCount();
        g_resourceSnapshot.lights = Framework_Resource_GetLightCount();
        g_resourceSnapshot.emitters = Framework_Resource_GetEmitterCount();
        g_resourceSnapshot.batches = Framework_Resource_GetBatchCount();
        g_resourceSnapshot.atlases = Framework_Resource_GetAtlasCount();
        g_resourceSnapshot.levels = Framework_Resource_GetLevelCount();
        g_resourceSnapshot.skeletons = Framework_Resource_GetSkeletonCount();
        g_resourceSnapshot.behaviorTrees = Framework_Resource_GetBehaviorTreeCount();
        g_resourceSnapshot.joints = Framework_Resource_GetJointCount();
        g_resourceSnapshot.spatialGrids = Framework_Resource_GetSpatialGridCount();
        g_snapshotTaken = true;
    }

    bool Framework_Resource_CompareSnapshot() {
        if (!g_snapshotTaken) return true;
        return Framework_Resource_GetEntityCount() == g_resourceSnapshot.entities &&
               Framework_Resource_GetTextureCount() == g_resourceSnapshot.textures &&
               Framework_Resource_GetSoundCount() == g_resourceSnapshot.sounds &&
               Framework_Resource_GetFontCount() == g_resourceSnapshot.fonts &&
               Framework_Resource_GetUIElementCount() == g_resourceSnapshot.uiElements &&
               Framework_Resource_GetPhysicsBodyCount() == g_resourceSnapshot.physicsBodies &&
               Framework_Resource_GetTweenCount() == g_resourceSnapshot.tweens &&
               Framework_Resource_GetTimerCount() == g_resourceSnapshot.timers &&
               Framework_Resource_GetPoolCount() == g_resourceSnapshot.pools &&
               Framework_Resource_GetFSMCount() == g_resourceSnapshot.fsms &&
               Framework_Resource_GetEventCount() == g_resourceSnapshot.events &&
               Framework_Resource_GetDialogueCount() == g_resourceSnapshot.dialogues &&
               Framework_Resource_GetQuestCount() == g_resourceSnapshot.quests &&
               Framework_Resource_GetLightCount() == g_resourceSnapshot.lights &&
               Framework_Resource_GetEmitterCount() == g_resourceSnapshot.emitters &&
               Framework_Resource_GetBatchCount() == g_resourceSnapshot.batches &&
               Framework_Resource_GetAtlasCount() == g_resourceSnapshot.atlases &&
               Framework_Resource_GetLevelCount() == g_resourceSnapshot.levels &&
               Framework_Resource_GetSkeletonCount() == g_resourceSnapshot.skeletons &&
               Framework_Resource_GetBehaviorTreeCount() == g_resourceSnapshot.behaviorTrees &&
               Framework_Resource_GetJointCount() == g_resourceSnapshot.joints &&
               Framework_Resource_GetSpatialGridCount() == g_resourceSnapshot.spatialGrids;
    }

    void Framework_Resource_DumpSnapshotDiff() {
        if (!g_snapshotTaken) {
            TraceLog(LOG_WARNING, "No snapshot taken - call Framework_Resource_TakeSnapshot() first");
            return;
        }

        int diff;
        bool hasChanges = false;
        TraceLog(LOG_INFO, "========================================");
        TraceLog(LOG_INFO, "RESOURCE SNAPSHOT DIFF");
        TraceLog(LOG_INFO, "========================================");

        #define DUMP_DIFF(name, getter, field) \
            diff = getter() - g_resourceSnapshot.field; \
            if (diff != 0) { \
                TraceLog(diff > 0 ? LOG_WARNING : LOG_INFO, "  %s: %+d (%d -> %d)", \
                    name, diff, g_resourceSnapshot.field, getter()); \
                hasChanges = true; \
            }

        DUMP_DIFF("Entities", Framework_Resource_GetEntityCount, entities);
        DUMP_DIFF("Textures", Framework_Resource_GetTextureCount, textures);
        DUMP_DIFF("Sounds", Framework_Resource_GetSoundCount, sounds);
        DUMP_DIFF("Fonts", Framework_Resource_GetFontCount, fonts);
        DUMP_DIFF("UI Elements", Framework_Resource_GetUIElementCount, uiElements);
        DUMP_DIFF("Physics Bodies", Framework_Resource_GetPhysicsBodyCount, physicsBodies);
        DUMP_DIFF("Tweens", Framework_Resource_GetTweenCount, tweens);
        DUMP_DIFF("Timers", Framework_Resource_GetTimerCount, timers);
        DUMP_DIFF("Pools", Framework_Resource_GetPoolCount, pools);
        DUMP_DIFF("FSMs", Framework_Resource_GetFSMCount, fsms);
        DUMP_DIFF("Events", Framework_Resource_GetEventCount, events);
        DUMP_DIFF("Dialogues", Framework_Resource_GetDialogueCount, dialogues);
        DUMP_DIFF("Quests", Framework_Resource_GetQuestCount, quests);
        DUMP_DIFF("Lights", Framework_Resource_GetLightCount, lights);
        DUMP_DIFF("Emitters", Framework_Resource_GetEmitterCount, emitters);
        DUMP_DIFF("Batches", Framework_Resource_GetBatchCount, batches);
        DUMP_DIFF("Atlases", Framework_Resource_GetAtlasCount, atlases);
        DUMP_DIFF("Levels", Framework_Resource_GetLevelCount, levels);
        DUMP_DIFF("Skeletons", Framework_Resource_GetSkeletonCount, skeletons);
        DUMP_DIFF("BehaviorTrees", Framework_Resource_GetBehaviorTreeCount, behaviorTrees);
        DUMP_DIFF("Joints", Framework_Resource_GetJointCount, joints);
        DUMP_DIFF("SpatialGrids", Framework_Resource_GetSpatialGridCount, spatialGrids);

        #undef DUMP_DIFF

        if (!hasChanges) {
            TraceLog(LOG_INFO, "  No changes since snapshot");
        }
        TraceLog(LOG_INFO, "========================================");
    }

    // Cleanup helpers - forward declare DestroyAll functions
    void Framework_UI_DestroyAll();
    void Framework_Physics_DestroyAllBodies();
    void Framework_Joint_DestroyAll();
    void Framework_Timer_CancelAll();
    void Framework_Tween_KillAll();
    void Framework_Pool_DestroyAll();
    void Framework_FSM_DestroyAll();
    void Framework_Event_Clear();
    void Framework_Light_DestroyAll();
    void Framework_Batch_DestroyAll();
    void Framework_Atlas_DestroyAll();
    void Framework_Level_DestroyAll();
    void Framework_Skeleton_DestroyAll();
    void Framework_BTree_DestroyAll();

    void Framework_Resource_DestroyAllEntities() {
        std::vector<Entity> entitiesToDestroy(g_entities.begin(), g_entities.end());
        for (Entity e : entitiesToDestroy) {
            Framework_Ecs_DestroyEntity(e);
        }
    }

    void Framework_Resource_DestroyAllUI() {
        Framework_UI_DestroyAll();
    }

    void Framework_Resource_DestroyAllPhysics() {
        Framework_Joint_DestroyAll();
        Framework_Physics_DestroyAllBodies();
    }

    void Framework_Resource_DestroyAllTimers() {
        Framework_Timer_CancelAll();
    }

    void Framework_Resource_DestroyAllTweens() {
        Framework_Tween_KillAll();
    }

    void Framework_Resource_DestroyAllPools() {
        Framework_Pool_DestroyAll();
    }

    void Framework_Resource_DestroyAllFSMs() {
        Framework_FSM_DestroyAll();
    }

    void Framework_Resource_DestroyAllEvents() {
        Framework_Event_Clear();
    }

    void Framework_Resource_DestroyAllLights() {
        Framework_Light_DestroyAll();
    }

    void Framework_Resource_DestroyAllEmitters() {
        // Particle emitters are entity components - they're destroyed with entities
        g_particleEmitter.clear();
    }

    void Framework_Resource_DestroyAllBatches() {
        Framework_Batch_DestroyAll();
    }

    void Framework_Resource_DestroyAllAtlases() {
        Framework_Atlas_DestroyAll();
    }

    void Framework_Resource_DestroyAllLevels() {
        Framework_Level_DestroyAll();
    }

    void Framework_Resource_CleanupAll() {
        // Destroy in reverse order of typical creation
        Framework_Resource_DestroyAllTimers();
        Framework_Resource_DestroyAllTweens();
        Framework_Resource_DestroyAllFSMs();
        Framework_Resource_DestroyAllPools();
        Framework_Resource_DestroyAllEvents();
        Framework_Resource_DestroyAllLights();
        Framework_Resource_DestroyAllEmitters();
        Framework_Resource_DestroyAllBatches();
        Framework_Resource_DestroyAllAtlases();
        Framework_Resource_DestroyAllLevels();
        Framework_Resource_DestroyAllUI();
        Framework_Resource_DestroyAllPhysics();
        Framework_Resource_DestroyAllEntities();

        // Clear spatial grids
        g_spatialGrids.clear();

        // Note: Textures, sounds, and fonts are typically managed by the user
        // and loaded/unloaded explicitly, so we don't auto-destroy them here
    }

    // Resource lifecycle callbacks
    void Framework_Resource_SetCreatedCallback(ResourceCreatedCallback callback) {
        g_resourceCreatedCallback = callback;
    }

    void Framework_Resource_SetDestroyedCallback(ResourceDestroyedCallback callback) {
        g_resourceDestroyedCallback = callback;
    }

    void Framework_Resource_EnableTracking(bool enabled) {
        g_resourceTrackingEnabled = enabled;
    }

    // Helper to notify callbacks (call from resource creation/destruction)
    void NotifyResourceCreated(const char* type, int id) {
        if (g_resourceTrackingEnabled && g_resourceCreatedCallback) {
            g_resourceCreatedCallback(type, id);
        }
    }

    void NotifyResourceDestroyed(const char* type, int id) {
        if (g_resourceTrackingEnabled && g_resourceDestroyedCallback) {
            g_resourceDestroyedCallback(type, id);
        }
    }

    // ========================================================================
    // PREFABS & SERIALIZATION (Basic implementation)
    // ========================================================================

    // Scene/Prefab binary format magic
    #define VGSE_MAGIC 0x45534756  // 'VGSE'
    #define VGSE_VERSION 1

    bool Framework_Scene_Save(const char* path) {
        if (!path) return false;

        std::ofstream file(path, std::ios::binary);
        if (!file) return false;

        // Header
        uint32_t magic = VGSE_MAGIC;
        uint16_t version = VGSE_VERSION;
        uint32_t entityCount = (uint32_t)g_entities.size();

        file.write((char*)&magic, sizeof(magic));
        file.write((char*)&version, sizeof(version));
        file.write((char*)&entityCount, sizeof(entityCount));

        // For each entity, write components
        for (Entity e : g_entities) {
            file.write((char*)&e, sizeof(e));

            // Flags for which components exist
            uint16_t compFlags = 0;
            if (g_transform2D.find(e) != g_transform2D.end()) compFlags |= (1 << COMP_TRANSFORM2D);
            if (g_sprite2D.find(e) != g_sprite2D.end()) compFlags |= (1 << COMP_SPRITE2D);
            if (g_name.find(e) != g_name.end()) compFlags |= (1 << COMP_NAME);
            if (g_tag.find(e) != g_tag.end()) compFlags |= (1 << COMP_TAG);
            if (g_hierarchy.find(e) != g_hierarchy.end()) compFlags |= (1 << COMP_HIERARCHY);
            if (g_velocity2D.find(e) != g_velocity2D.end()) compFlags |= (1 << COMP_VELOCITY2D);
            if (g_boxCollider2D.find(e) != g_boxCollider2D.end()) compFlags |= (1 << COMP_BOXCOLLIDER2D);
            if (g_enabled.find(e) != g_enabled.end()) compFlags |= (1 << COMP_ENABLED);

            file.write((char*)&compFlags, sizeof(compFlags));

            if (compFlags & (1 << COMP_TRANSFORM2D)) {
                file.write((char*)&g_transform2D[e], sizeof(Transform2D));
            }
            if (compFlags & (1 << COMP_SPRITE2D)) {
                file.write((char*)&g_sprite2D[e], sizeof(Sprite2D));
            }
            if (compFlags & (1 << COMP_NAME)) {
                file.write((char*)&g_name[e], sizeof(NameComponent));
            }
            if (compFlags & (1 << COMP_TAG)) {
                file.write((char*)&g_tag[e], sizeof(TagComponent));
            }
            if (compFlags & (1 << COMP_HIERARCHY)) {
                file.write((char*)&g_hierarchy[e], sizeof(HierarchyComponent));
            }
            if (compFlags & (1 << COMP_VELOCITY2D)) {
                file.write((char*)&g_velocity2D[e], sizeof(Velocity2D));
            }
            if (compFlags & (1 << COMP_BOXCOLLIDER2D)) {
                file.write((char*)&g_boxCollider2D[e], sizeof(BoxCollider2D));
            }
            if (compFlags & (1 << COMP_ENABLED)) {
                file.write((char*)&g_enabled[e], sizeof(EnabledComponent));
            }
        }

        return true;
    }

    bool Framework_Scene_Load(const char* path) {
        if (!path) return false;

        std::ifstream file(path, std::ios::binary);
        if (!file) return false;

        uint32_t magic;
        uint16_t version;
        uint32_t entityCount;

        file.read((char*)&magic, sizeof(magic));
        if (magic != VGSE_MAGIC) return false;

        file.read((char*)&version, sizeof(version));
        if (version != VGSE_VERSION) return false;

        file.read((char*)&entityCount, sizeof(entityCount));

        // Clear current scene
        EcsClearAllInternal();

        for (uint32_t i = 0; i < entityCount; i++) {
            Entity e;
            file.read((char*)&e, sizeof(e));

            g_entities.insert(e);
            if (e >= g_nextEntityId) g_nextEntityId = e + 1;

            uint16_t compFlags;
            file.read((char*)&compFlags, sizeof(compFlags));

            if (compFlags & (1 << COMP_TRANSFORM2D)) {
                Transform2D t;
                file.read((char*)&t, sizeof(t));
                g_transform2D[e] = t;
            }
            if (compFlags & (1 << COMP_SPRITE2D)) {
                Sprite2D s;
                file.read((char*)&s, sizeof(s));
                g_sprite2D[e] = s;
            }
            if (compFlags & (1 << COMP_NAME)) {
                NameComponent n;
                file.read((char*)&n, sizeof(n));
                g_name[e] = n;
            }
            if (compFlags & (1 << COMP_TAG)) {
                TagComponent t;
                file.read((char*)&t, sizeof(t));
                g_tag[e] = t;
            }
            if (compFlags & (1 << COMP_HIERARCHY)) {
                HierarchyComponent h;
                file.read((char*)&h, sizeof(h));
                g_hierarchy[e] = h;
            }
            if (compFlags & (1 << COMP_VELOCITY2D)) {
                Velocity2D v;
                file.read((char*)&v, sizeof(v));
                g_velocity2D[e] = v;
            }
            if (compFlags & (1 << COMP_BOXCOLLIDER2D)) {
                BoxCollider2D b;
                file.read((char*)&b, sizeof(b));
                g_boxCollider2D[e] = b;
            }
            if (compFlags & (1 << COMP_ENABLED)) {
                EnabledComponent en;
                file.read((char*)&en, sizeof(en));
                g_enabled[e] = en;
            }
        }

        return true;
    }

    int Framework_Prefab_Load(const char* path) {
        if (!path) return 0;

        std::ifstream file(path, std::ios::binary | std::ios::ate);
        if (!file) return 0;

        std::streamsize size = file.tellg();
        file.seekg(0, std::ios::beg);

        PrefabData pd;
        pd.data.resize((size_t)size);
        if (!file.read((char*)pd.data.data(), size)) return 0;

        pd.valid = true;
        int h = g_nextPrefabHandle++;
        g_prefabs[h] = std::move(pd);
        return h;
    }

    int Framework_Prefab_Instantiate(int prefabH, int parentEntity, float x, float y) {
        auto it = g_prefabs.find(prefabH);
        if (it == g_prefabs.end() || !it->second.valid) return -1;

        // Parse prefab data and create entities
        // This is a simplified version - a full impl would need to remap entity IDs
        const uint8_t* data = it->second.data.data();
        size_t offset = 0;

        uint32_t magic = *(uint32_t*)(data + offset); offset += 4;
        if (magic != VGSE_MAGIC) return -1;

        uint16_t version = *(uint16_t*)(data + offset); offset += 2;
        if (version != VGSE_VERSION) return -1;

        uint32_t entityCount = *(uint32_t*)(data + offset); offset += 4;

        std::unordered_map<Entity, Entity> idRemap;
        Entity rootEntity = -1;

        // First pass: create entities and remap IDs
        for (uint32_t i = 0; i < entityCount; i++) {
            Entity oldId = *(Entity*)(data + offset); offset += sizeof(Entity);
            Entity newId = g_nextEntityId++;
            g_entities.insert(newId);
            idRemap[oldId] = newId;

            if (rootEntity == -1) rootEntity = newId;

            uint16_t compFlags = *(uint16_t*)(data + offset); offset += 2;

            if (compFlags & (1 << COMP_TRANSFORM2D)) {
                Transform2D t = *(Transform2D*)(data + offset);
                offset += sizeof(Transform2D);
                // Offset position for root entity
                if (newId == rootEntity) {
                    t.position.x += x;
                    t.position.y += y;
                }
                g_transform2D[newId] = t;
            }
            if (compFlags & (1 << COMP_SPRITE2D)) {
                Sprite2D s = *(Sprite2D*)(data + offset);
                offset += sizeof(Sprite2D);
                g_sprite2D[newId] = s;
            }
            if (compFlags & (1 << COMP_NAME)) {
                NameComponent n = *(NameComponent*)(data + offset);
                offset += sizeof(NameComponent);
                g_name[newId] = n;
            }
            if (compFlags & (1 << COMP_TAG)) {
                TagComponent t = *(TagComponent*)(data + offset);
                offset += sizeof(TagComponent);
                g_tag[newId] = t;
            }
            if (compFlags & (1 << COMP_HIERARCHY)) {
                HierarchyComponent h = *(HierarchyComponent*)(data + offset);
                offset += sizeof(HierarchyComponent);
                // Will fix up in second pass
                g_hierarchy[newId] = h;
            }
            if (compFlags & (1 << COMP_VELOCITY2D)) {
                Velocity2D v = *(Velocity2D*)(data + offset);
                offset += sizeof(Velocity2D);
                g_velocity2D[newId] = v;
            }
            if (compFlags & (1 << COMP_BOXCOLLIDER2D)) {
                BoxCollider2D b = *(BoxCollider2D*)(data + offset);
                offset += sizeof(BoxCollider2D);
                g_boxCollider2D[newId] = b;
            }
            if (compFlags & (1 << COMP_ENABLED)) {
                EnabledComponent en = *(EnabledComponent*)(data + offset);
                offset += sizeof(EnabledComponent);
                g_enabled[newId] = en;
            }
        }

        // Second pass: fix hierarchy references
        for (auto& kv : idRemap) {
            Entity newId = kv.second;
            auto hIt = g_hierarchy.find(newId);
            if (hIt != g_hierarchy.end()) {
                HierarchyComponent& h = hIt->second;
                if (h.parent != -1) {
                    auto pIt = idRemap.find(h.parent);
                    h.parent = (pIt != idRemap.end()) ? pIt->second : -1;
                }
                if (h.firstChild != -1) {
                    auto cIt = idRemap.find(h.firstChild);
                    h.firstChild = (cIt != idRemap.end()) ? cIt->second : -1;
                }
                if (h.nextSibling != -1) {
                    auto sIt = idRemap.find(h.nextSibling);
                    h.nextSibling = (sIt != idRemap.end()) ? sIt->second : -1;
                }
                if (h.prevSibling != -1) {
                    auto sIt = idRemap.find(h.prevSibling);
                    h.prevSibling = (sIt != idRemap.end()) ? sIt->second : -1;
                }
            }
        }

        // Set parent if specified
        if (parentEntity != -1 && EcsIsAlive(parentEntity) && rootEntity != -1) {
            Framework_Ecs_SetParent(rootEntity, parentEntity);
        }

        return rootEntity;
    }

    void Framework_Prefab_Unload(int prefabH) {
        g_prefabs.erase(prefabH);
    }

    bool Framework_Prefab_SaveEntity(int entity, const char* path) {
        if (!path || !EcsIsAlive(entity)) return false;

        // Collect entity and all descendants
        std::vector<Entity> entities;
        std::function<void(Entity)> collect = [&](Entity e) {
            entities.push_back(e);
            auto hIt = g_hierarchy.find(e);
            if (hIt != g_hierarchy.end()) {
                int child = hIt->second.firstChild;
                while (child != -1) {
                    collect(child);
                    auto chIt = g_hierarchy.find(child);
                    if (chIt == g_hierarchy.end()) break;
                    child = chIt->second.nextSibling;
                }
            }
        };
        collect(entity);

        std::ofstream file(path, std::ios::binary);
        if (!file) return false;

        uint32_t magic = VGSE_MAGIC;
        uint16_t version = VGSE_VERSION;
        uint32_t entityCount = (uint32_t)entities.size();

        file.write((char*)&magic, sizeof(magic));
        file.write((char*)&version, sizeof(version));
        file.write((char*)&entityCount, sizeof(entityCount));

        for (Entity e : entities) {
            file.write((char*)&e, sizeof(e));

            uint16_t compFlags = 0;
            if (g_transform2D.find(e) != g_transform2D.end()) compFlags |= (1 << COMP_TRANSFORM2D);
            if (g_sprite2D.find(e) != g_sprite2D.end()) compFlags |= (1 << COMP_SPRITE2D);
            if (g_name.find(e) != g_name.end()) compFlags |= (1 << COMP_NAME);
            if (g_tag.find(e) != g_tag.end()) compFlags |= (1 << COMP_TAG);
            if (g_hierarchy.find(e) != g_hierarchy.end()) compFlags |= (1 << COMP_HIERARCHY);
            if (g_velocity2D.find(e) != g_velocity2D.end()) compFlags |= (1 << COMP_VELOCITY2D);
            if (g_boxCollider2D.find(e) != g_boxCollider2D.end()) compFlags |= (1 << COMP_BOXCOLLIDER2D);
            if (g_enabled.find(e) != g_enabled.end()) compFlags |= (1 << COMP_ENABLED);

            file.write((char*)&compFlags, sizeof(compFlags));

            if (compFlags & (1 << COMP_TRANSFORM2D)) {
                file.write((char*)&g_transform2D[e], sizeof(Transform2D));
            }
            if (compFlags & (1 << COMP_SPRITE2D)) {
                file.write((char*)&g_sprite2D[e], sizeof(Sprite2D));
            }
            if (compFlags & (1 << COMP_NAME)) {
                file.write((char*)&g_name[e], sizeof(NameComponent));
            }
            if (compFlags & (1 << COMP_TAG)) {
                file.write((char*)&g_tag[e], sizeof(TagComponent));
            }
            if (compFlags & (1 << COMP_HIERARCHY)) {
                file.write((char*)&g_hierarchy[e], sizeof(HierarchyComponent));
            }
            if (compFlags & (1 << COMP_VELOCITY2D)) {
                file.write((char*)&g_velocity2D[e], sizeof(Velocity2D));
            }
            if (compFlags & (1 << COMP_BOXCOLLIDER2D)) {
                file.write((char*)&g_boxCollider2D[e], sizeof(BoxCollider2D));
            }
            if (compFlags & (1 << COMP_ENABLED)) {
                file.write((char*)&g_enabled[e], sizeof(EnabledComponent));
            }
        }

        return true;
    }

    // ========================================================================
    // TILEMAP SYSTEM
    // ========================================================================
    int Framework_Tileset_Create(int textureHandle, int tileWidth, int tileHeight, int columns) {
        Tileset ts;
        ts.textureHandle = textureHandle;
        ts.tileWidth = tileWidth > 0 ? tileWidth : 16;
        ts.tileHeight = tileHeight > 0 ? tileHeight : 16;
        ts.columns = columns > 0 ? columns : 1;
        ts.valid = true;
        int h = g_nextTilesetHandle++;
        g_tilesets[h] = ts;
        return h;
    }

    void Framework_Tileset_Destroy(int tilesetHandle) {
        g_tilesets.erase(tilesetHandle);
    }

    bool Framework_Tileset_IsValid(int tilesetHandle) {
        auto it = g_tilesets.find(tilesetHandle);
        return it != g_tilesets.end() && it->second.valid;
    }

    int Framework_Tileset_GetTileWidth(int tilesetHandle) {
        auto it = g_tilesets.find(tilesetHandle);
        return (it != g_tilesets.end()) ? it->second.tileWidth : 0;
    }

    int Framework_Tileset_GetTileHeight(int tilesetHandle) {
        auto it = g_tilesets.find(tilesetHandle);
        return (it != g_tilesets.end()) ? it->second.tileHeight : 0;
    }

    void Framework_Ecs_AddTilemap(int entity, int tilesetHandle, int mapWidth, int mapHeight) {
        if (!EcsIsAlive(entity)) return;
        TilemapComponent tm;
        tm.tilesetHandle = tilesetHandle;
        tm.mapWidth = mapWidth > 0 ? mapWidth : 1;
        tm.mapHeight = mapHeight > 0 ? mapHeight : 1;
        tm.tiles.resize(tm.mapWidth * tm.mapHeight, -1);
        g_tilemap[entity] = tm;
    }

    bool Framework_Ecs_HasTilemap(int entity) {
        return g_tilemap.find(entity) != g_tilemap.end();
    }

    void Framework_Ecs_RemoveTilemap(int entity) {
        g_tilemap.erase(entity);
    }

    void Framework_Ecs_SetTile(int entity, int x, int y, int tileIndex) {
        auto it = g_tilemap.find(entity);
        if (it == g_tilemap.end()) return;
        TilemapComponent& tm = it->second;
        if (x < 0 || x >= tm.mapWidth || y < 0 || y >= tm.mapHeight) return;
        tm.tiles[y * tm.mapWidth + x] = tileIndex;
    }

    int Framework_Ecs_GetTile(int entity, int x, int y) {
        auto it = g_tilemap.find(entity);
        if (it == g_tilemap.end()) return -1;
        const TilemapComponent& tm = it->second;
        if (x < 0 || x >= tm.mapWidth || y < 0 || y >= tm.mapHeight) return -1;
        return tm.tiles[y * tm.mapWidth + x];
    }

    void Framework_Ecs_FillTiles(int entity, int tileIndex) {
        auto it = g_tilemap.find(entity);
        if (it == g_tilemap.end()) return;
        std::fill(it->second.tiles.begin(), it->second.tiles.end(), tileIndex);
    }

    void Framework_Ecs_SetTileCollision(int entity, int tileIndex, bool solid) {
        auto it = g_tilemap.find(entity);
        if (it == g_tilemap.end()) return;
        if (solid) {
            it->second.solidTiles.insert(tileIndex);
        } else {
            it->second.solidTiles.erase(tileIndex);
        }
    }

    bool Framework_Ecs_GetTileCollision(int entity, int tileIndex) {
        auto it = g_tilemap.find(entity);
        if (it == g_tilemap.end()) return false;
        return it->second.solidTiles.count(tileIndex) > 0;
    }

    int Framework_Ecs_GetTilemapWidth(int entity) {
        auto it = g_tilemap.find(entity);
        return (it != g_tilemap.end()) ? it->second.mapWidth : 0;
    }

    int Framework_Ecs_GetTilemapHeight(int entity) {
        auto it = g_tilemap.find(entity);
        return (it != g_tilemap.end()) ? it->second.mapHeight : 0;
    }

    void Framework_Ecs_DrawTilemap(int entity) {
        auto tmIt = g_tilemap.find(entity);
        if (tmIt == g_tilemap.end()) return;

        const TilemapComponent& tm = tmIt->second;
        auto tsIt = g_tilesets.find(tm.tilesetHandle);
        if (tsIt == g_tilesets.end() || !tsIt->second.valid) return;

        const Tileset& ts = tsIt->second;
        auto texIt = g_texByHandle.find(ts.textureHandle);
        if (texIt == g_texByHandle.end() || !texIt->second.valid) return;

        // Get entity transform for position offset
        float offsetX = 0, offsetY = 0;
        auto trIt = g_transform2D.find(entity);
        if (trIt != g_transform2D.end()) {
            offsetX = trIt->second.position.x;
            offsetY = trIt->second.position.y;
        }

        const Texture2D& tex = texIt->second.tex;

        for (int y = 0; y < tm.mapHeight; y++) {
            for (int x = 0; x < tm.mapWidth; x++) {
                int tileIdx = tm.tiles[y * tm.mapWidth + x];
                if (tileIdx < 0) continue;

                int srcX = (tileIdx % ts.columns) * ts.tileWidth;
                int srcY = (tileIdx / ts.columns) * ts.tileHeight;

                Rectangle src = { (float)srcX, (float)srcY, (float)ts.tileWidth, (float)ts.tileHeight };
                Vector2 pos = { offsetX + x * ts.tileWidth, offsetY + y * ts.tileHeight };

                DrawTextureRec(tex, src, pos, WHITE);
            }
        }
    }

    void Framework_Tilemaps_Draw() {
        for (auto& kv : g_tilemap) {
            if (!EcsIsAlive(kv.first)) continue;
            auto enIt = g_enabled.find(kv.first);
            if (enIt != g_enabled.end() && !enIt->second.enabled) continue;
            Framework_Ecs_DrawTilemap(kv.first);
        }
    }

    bool Framework_Tilemap_PointSolid(int entity, float worldX, float worldY) {
        auto tmIt = g_tilemap.find(entity);
        if (tmIt == g_tilemap.end()) return false;

        const TilemapComponent& tm = tmIt->second;
        auto tsIt = g_tilesets.find(tm.tilesetHandle);
        if (tsIt == g_tilesets.end()) return false;

        float offsetX = 0, offsetY = 0;
        auto trIt = g_transform2D.find(entity);
        if (trIt != g_transform2D.end()) {
            offsetX = trIt->second.position.x;
            offsetY = trIt->second.position.y;
        }

        int tileX = (int)((worldX - offsetX) / tsIt->second.tileWidth);
        int tileY = (int)((worldY - offsetY) / tsIt->second.tileHeight);

        if (tileX < 0 || tileX >= tm.mapWidth || tileY < 0 || tileY >= tm.mapHeight) return false;

        int tileIdx = tm.tiles[tileY * tm.mapWidth + tileX];
        return tm.solidTiles.count(tileIdx) > 0;
    }

    bool Framework_Tilemap_BoxSolid(int entity, float worldX, float worldY, float w, float h) {
        // Check all four corners and center
        if (Framework_Tilemap_PointSolid(entity, worldX, worldY)) return true;
        if (Framework_Tilemap_PointSolid(entity, worldX + w, worldY)) return true;
        if (Framework_Tilemap_PointSolid(entity, worldX, worldY + h)) return true;
        if (Framework_Tilemap_PointSolid(entity, worldX + w, worldY + h)) return true;
        if (Framework_Tilemap_PointSolid(entity, worldX + w/2, worldY + h/2)) return true;
        return false;
    }

    // ========================================================================
    // ANIMATION SYSTEM
    // ========================================================================
    int Framework_AnimClip_Create(const char* name, int frameCount) {
        AnimClip clip;
        clip.name = name ? name : "";
        clip.frames.resize(frameCount > 0 ? frameCount : 1);
        clip.valid = true;
        int h = g_nextAnimClipHandle++;
        g_animClips[h] = clip;
        return h;
    }

    void Framework_AnimClip_Destroy(int clipHandle) {
        g_animClips.erase(clipHandle);
    }

    bool Framework_AnimClip_IsValid(int clipHandle) {
        auto it = g_animClips.find(clipHandle);
        return it != g_animClips.end() && it->second.valid;
    }

    void Framework_AnimClip_SetFrame(int clipHandle, int frameIndex,
        float srcX, float srcY, float srcW, float srcH, float duration) {
        auto it = g_animClips.find(clipHandle);
        if (it == g_animClips.end()) return;
        if (frameIndex < 0 || frameIndex >= (int)it->second.frames.size()) return;
        AnimFrame& f = it->second.frames[frameIndex];
        f.source = { srcX, srcY, srcW, srcH };
        f.duration = duration > 0 ? duration : 0.1f;
    }

    void Framework_AnimClip_SetLoopMode(int clipHandle, int loopMode) {
        auto it = g_animClips.find(clipHandle);
        if (it == g_animClips.end()) return;
        it->second.loopMode = loopMode;
    }

    int Framework_AnimClip_GetFrameCount(int clipHandle) {
        auto it = g_animClips.find(clipHandle);
        return (it != g_animClips.end()) ? (int)it->second.frames.size() : 0;
    }

    float Framework_AnimClip_GetTotalDuration(int clipHandle) {
        auto it = g_animClips.find(clipHandle);
        if (it == g_animClips.end()) return 0.0f;
        float total = 0.0f;
        for (const auto& f : it->second.frames) {
            total += f.duration;
        }
        return total;
    }

    int Framework_AnimClip_FindByName(const char* name) {
        if (!name) return -1;
        for (const auto& kv : g_animClips) {
            if (kv.second.name == name) return kv.first;
        }
        return -1;
    }

    void Framework_Ecs_AddAnimator(int entity) {
        if (!EcsIsAlive(entity)) return;
        g_animator[entity] = AnimatorComponent();
    }

    bool Framework_Ecs_HasAnimator(int entity) {
        return g_animator.find(entity) != g_animator.end();
    }

    void Framework_Ecs_RemoveAnimator(int entity) {
        g_animator.erase(entity);
    }

    void Framework_Ecs_SetAnimatorClip(int entity, int clipHandle) {
        auto it = g_animator.find(entity);
        if (it == g_animator.end()) return;
        it->second.clipHandle = clipHandle;
        it->second.currentFrame = 0;
        it->second.timer = 0.0f;
        it->second.pingpongReverse = false;
    }

    int Framework_Ecs_GetAnimatorClip(int entity) {
        auto it = g_animator.find(entity);
        return (it != g_animator.end()) ? it->second.clipHandle : -1;
    }

    void Framework_Ecs_AnimatorPlay(int entity) {
        auto it = g_animator.find(entity);
        if (it == g_animator.end()) return;
        it->second.playing = true;
    }

    void Framework_Ecs_AnimatorPause(int entity) {
        auto it = g_animator.find(entity);
        if (it == g_animator.end()) return;
        it->second.playing = false;
    }

    void Framework_Ecs_AnimatorStop(int entity) {
        auto it = g_animator.find(entity);
        if (it == g_animator.end()) return;
        it->second.playing = false;
        it->second.currentFrame = 0;
        it->second.timer = 0.0f;
        it->second.pingpongReverse = false;
    }

    void Framework_Ecs_AnimatorSetSpeed(int entity, float speed) {
        auto it = g_animator.find(entity);
        if (it == g_animator.end()) return;
        it->second.speed = speed;
    }

    bool Framework_Ecs_AnimatorIsPlaying(int entity) {
        auto it = g_animator.find(entity);
        return (it != g_animator.end()) ? it->second.playing : false;
    }

    int Framework_Ecs_AnimatorGetFrame(int entity) {
        auto it = g_animator.find(entity);
        return (it != g_animator.end()) ? it->second.currentFrame : 0;
    }

    void Framework_Ecs_AnimatorSetFrame(int entity, int frameIndex) {
        auto it = g_animator.find(entity);
        if (it == g_animator.end()) return;
        it->second.currentFrame = frameIndex;
        it->second.timer = 0.0f;
    }

    void Framework_Animators_Update(float dt) {
        for (auto& kv : g_animator) {
            if (!EcsIsAlive(kv.first)) continue;
            AnimatorComponent& anim = kv.second;
            if (!anim.playing) continue;

            auto clipIt = g_animClips.find(anim.clipHandle);
            if (clipIt == g_animClips.end() || clipIt->second.frames.empty()) continue;

            const AnimClip& clip = clipIt->second;
            const AnimFrame& frame = clip.frames[anim.currentFrame];

            anim.timer += dt * anim.speed;

            if (anim.timer >= frame.duration) {
                anim.timer -= frame.duration;

                int frameCount = (int)clip.frames.size();
                if (clip.loopMode == ANIM_LOOP_PINGPONG) {
                    if (anim.pingpongReverse) {
                        anim.currentFrame--;
                        if (anim.currentFrame <= 0) {
                            anim.currentFrame = 0;
                            anim.pingpongReverse = false;
                        }
                    } else {
                        anim.currentFrame++;
                        if (anim.currentFrame >= frameCount - 1) {
                            anim.currentFrame = frameCount - 1;
                            anim.pingpongReverse = true;
                        }
                    }
                } else {
                    anim.currentFrame++;
                    if (anim.currentFrame >= frameCount) {
                        if (clip.loopMode == ANIM_LOOP_REPEAT) {
                            anim.currentFrame = 0;
                        } else {
                            anim.currentFrame = frameCount - 1;
                            anim.playing = false;
                        }
                    }
                }
            }

            // Update sprite source rect if entity has a sprite
            auto sprIt = g_sprite2D.find(kv.first);
            if (sprIt != g_sprite2D.end()) {
                // Bounds check to prevent out-of-bounds access
                if (anim.currentFrame >= 0 && anim.currentFrame < (int)clip.frames.size()) {
                    sprIt->second.source = clip.frames[anim.currentFrame].source;
                }
            }
        }
    }

    // ========================================================================
    // SPRITE SHEET TOOLS
    // ========================================================================
    namespace {
        struct SpriteSheet {
            int textureHandle;
            int frameWidth, frameHeight;
            int columns, rows;
            int paddingX, paddingY;
            bool valid;
        };

        std::unordered_map<int, SpriteSheet> g_spriteSheets;
        int g_nextSpriteSheetId = 1;
    }

    int Framework_SpriteSheet_Create(int textureHandle, int frameWidth, int frameHeight, int columns, int rows, int paddingX, int paddingY) {
        if (textureHandle <= 0 || frameWidth <= 0 || frameHeight <= 0 || columns <= 0 || rows <= 0) {
            return -1;
        }

        int id = g_nextSpriteSheetId++;
        SpriteSheet& sheet = g_spriteSheets[id];
        sheet.textureHandle = textureHandle;
        sheet.frameWidth = frameWidth;
        sheet.frameHeight = frameHeight;
        sheet.columns = columns;
        sheet.rows = rows;
        sheet.paddingX = paddingX;
        sheet.paddingY = paddingY;
        sheet.valid = true;
        return id;
    }

    void Framework_SpriteSheet_Destroy(int sheetId) {
        auto it = g_spriteSheets.find(sheetId);
        if (it != g_spriteSheets.end()) {
            g_spriteSheets.erase(it);
        }
    }

    bool Framework_SpriteSheet_IsValid(int sheetId) {
        auto it = g_spriteSheets.find(sheetId);
        return it != g_spriteSheets.end() && it->second.valid;
    }

    int Framework_SpriteSheet_GetTextureHandle(int sheetId) {
        auto it = g_spriteSheets.find(sheetId);
        if (it == g_spriteSheets.end()) return -1;
        return it->second.textureHandle;
    }

    int Framework_SpriteSheet_GetFrameCount(int sheetId) {
        auto it = g_spriteSheets.find(sheetId);
        if (it == g_spriteSheets.end()) return 0;
        return it->second.columns * it->second.rows;
    }

    int Framework_SpriteSheet_GetColumns(int sheetId) {
        auto it = g_spriteSheets.find(sheetId);
        if (it == g_spriteSheets.end()) return 0;
        return it->second.columns;
    }

    int Framework_SpriteSheet_GetRows(int sheetId) {
        auto it = g_spriteSheets.find(sheetId);
        if (it == g_spriteSheets.end()) return 0;
        return it->second.rows;
    }

    void Framework_SpriteSheet_GetFrameSize(int sheetId, int* width, int* height) {
        auto it = g_spriteSheets.find(sheetId);
        if (it == g_spriteSheets.end()) {
            if (width) *width = 0;
            if (height) *height = 0;
            return;
        }
        if (width) *width = it->second.frameWidth;
        if (height) *height = it->second.frameHeight;
    }

    void Framework_SpriteSheet_GetFrameRect(int sheetId, int frameIndex, float* x, float* y, float* w, float* h) {
        auto it = g_spriteSheets.find(sheetId);
        if (it == g_spriteSheets.end() || frameIndex < 0) {
            if (x) *x = 0; if (y) *y = 0; if (w) *w = 0; if (h) *h = 0;
            return;
        }
        const SpriteSheet& sheet = it->second;
        int col = frameIndex % sheet.columns;
        int row = frameIndex / sheet.columns;
        if (row >= sheet.rows) {
            if (x) *x = 0; if (y) *y = 0; if (w) *w = 0; if (h) *h = 0;
            return;
        }
        float fx = (float)(col * (sheet.frameWidth + sheet.paddingX));
        float fy = (float)(row * (sheet.frameHeight + sheet.paddingY));
        if (x) *x = fx;
        if (y) *y = fy;
        if (w) *w = (float)sheet.frameWidth;
        if (h) *h = (float)sheet.frameHeight;
    }

    void Framework_SpriteSheet_GetFrameRectRC(int sheetId, int row, int col, float* x, float* y, float* w, float* h) {
        auto it = g_spriteSheets.find(sheetId);
        if (it == g_spriteSheets.end() || row < 0 || col < 0) {
            if (x) *x = 0; if (y) *y = 0; if (w) *w = 0; if (h) *h = 0;
            return;
        }
        const SpriteSheet& sheet = it->second;
        if (row >= sheet.rows || col >= sheet.columns) {
            if (x) *x = 0; if (y) *y = 0; if (w) *w = 0; if (h) *h = 0;
            return;
        }
        float fx = (float)(col * (sheet.frameWidth + sheet.paddingX));
        float fy = (float)(row * (sheet.frameHeight + sheet.paddingY));
        if (x) *x = fx;
        if (y) *y = fy;
        if (w) *w = (float)sheet.frameWidth;
        if (h) *h = (float)sheet.frameHeight;
    }

    int Framework_AnimClip_CreateFromSheet(const char* name, int sheetId, int startFrame, int frameCount, float frameDuration, int loopMode) {
        auto it = g_spriteSheets.find(sheetId);
        if (it == g_spriteSheets.end() || frameCount <= 0 || !name) return -1;

        int clipId = Framework_AnimClip_Create(name, frameCount);
        if (clipId <= 0) return -1;

        const SpriteSheet& sheet = it->second;
        int totalFrames = sheet.columns * sheet.rows;

        for (int i = 0; i < frameCount; i++) {
            int frameIndex = startFrame + i;
            if (frameIndex >= totalFrames) break;

            int col = frameIndex % sheet.columns;
            int row = frameIndex / sheet.columns;
            float fx = (float)(col * (sheet.frameWidth + sheet.paddingX));
            float fy = (float)(row * (sheet.frameHeight + sheet.paddingY));
            Framework_AnimClip_SetFrame(clipId, i, fx, fy, (float)sheet.frameWidth, (float)sheet.frameHeight, frameDuration);
        }

        Framework_AnimClip_SetLoopMode(clipId, loopMode);
        return clipId;
    }

    int Framework_AnimClip_CreateFromSheetRow(const char* name, int sheetId, int row, int startCol, int colCount, float frameDuration, int loopMode) {
        auto it = g_spriteSheets.find(sheetId);
        if (it == g_spriteSheets.end() || colCount <= 0 || !name || row < 0 || startCol < 0) return -1;

        const SpriteSheet& sheet = it->second;
        if (row >= sheet.rows) return -1;

        int actualCount = std::min(colCount, sheet.columns - startCol);
        if (actualCount <= 0) return -1;

        int clipId = Framework_AnimClip_Create(name, actualCount);
        if (clipId <= 0) return -1;

        for (int i = 0; i < actualCount; i++) {
            int col = startCol + i;
            float fx = (float)(col * (sheet.frameWidth + sheet.paddingX));
            float fy = (float)(row * (sheet.frameHeight + sheet.paddingY));
            Framework_AnimClip_SetFrame(clipId, i, fx, fy, (float)sheet.frameWidth, (float)sheet.frameHeight, frameDuration);
        }

        Framework_AnimClip_SetLoopMode(clipId, loopMode);
        return clipId;
    }

    void Framework_SpriteSheet_DrawFrame(int sheetId, int frameIndex, float x, float y, float scale, float rotation, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto it = g_spriteSheets.find(sheetId);
        if (it == g_spriteSheets.end()) return;

        const SpriteSheet& sheet = it->second;

        float srcX, srcY, srcW, srcH;
        Framework_SpriteSheet_GetFrameRect(sheetId, frameIndex, &srcX, &srcY, &srcW, &srcH);
        if (srcW <= 0 || srcH <= 0) return;

        Rectangle source = { srcX, srcY, srcW, srcH };
        Rectangle dest = { x, y, srcW * scale, srcH * scale };
        Vector2 origin = { dest.width * 0.5f, dest.height * 0.5f };

        Framework_DrawTextureProH(sheet.textureHandle, source, dest, origin, rotation, r, g, b, a);
    }

    int Framework_SpriteSheet_GetCount() {
        return (int)g_spriteSheets.size();
    }

    void Framework_SpriteSheet_DestroyAll() {
        g_spriteSheets.clear();
        g_nextSpriteSheetId = 1;
    }

    // ========================================================================
    // PARTICLE SYSTEM
    // ========================================================================
    namespace {
        float RandFloat(float minVal, float maxVal) {
            return minVal + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX / (maxVal - minVal)));
        }

        unsigned char LerpByte(unsigned char a, unsigned char b, float t) {
            return (unsigned char)(a + (b - a) * t);
        }
    }

    void Framework_Ecs_AddParticleEmitter(int entity, int textureHandle) {
        if (!EcsIsAlive(entity)) return;
        ParticleEmitterComponent pe;
        pe.textureHandle = textureHandle;
        pe.particles.resize(pe.maxParticles);
        g_particleEmitter[entity] = pe;
    }

    bool Framework_Ecs_HasParticleEmitter(int entity) {
        return g_particleEmitter.find(entity) != g_particleEmitter.end();
    }

    void Framework_Ecs_RemoveParticleEmitter(int entity) {
        g_particleEmitter.erase(entity);
    }

    void Framework_Ecs_SetEmitterRate(int entity, float particlesPerSecond) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.emissionRate = particlesPerSecond;
    }

    void Framework_Ecs_SetEmitterLifetime(int entity, float minLife, float maxLife) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.lifetimeMin = minLife;
        it->second.lifetimeMax = maxLife;
    }

    void Framework_Ecs_SetEmitterVelocity(int entity, float minVx, float minVy, float maxVx, float maxVy) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.velocityMinX = minVx;
        it->second.velocityMinY = minVy;
        it->second.velocityMaxX = maxVx;
        it->second.velocityMaxY = maxVy;
    }

    void Framework_Ecs_SetEmitterColorStart(int entity, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.colorStart = { r, g, b, a };
    }

    void Framework_Ecs_SetEmitterColorEnd(int entity, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.colorEnd = { r, g, b, a };
    }

    void Framework_Ecs_SetEmitterSize(int entity, float startSize, float endSize) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.sizeStart = startSize;
        it->second.sizeEnd = endSize;
    }

    void Framework_Ecs_SetEmitterGravity(int entity, float gx, float gy) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.gravityX = gx;
        it->second.gravityY = gy;
    }

    void Framework_Ecs_SetEmitterSpread(int entity, float angleDegrees) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.spreadAngle = angleDegrees;
    }

    void Framework_Ecs_SetEmitterDirection(int entity, float dirX, float dirY) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.directionX = dirX;
        it->second.directionY = dirY;
    }

    void Framework_Ecs_SetEmitterMaxParticles(int entity, int maxParticles) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.maxParticles = maxParticles > 0 ? maxParticles : 1;
        it->second.particles.resize(it->second.maxParticles);
    }

    void Framework_Ecs_SetEmitterSourceRect(int entity, float srcX, float srcY, float srcW, float srcH) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.sourceRect = { srcX, srcY, srcW, srcH };
    }

    void Framework_Ecs_EmitterStart(int entity) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.active = true;
    }

    void Framework_Ecs_EmitterStop(int entity) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.active = false;
    }

    void Framework_Ecs_EmitterBurst(int entity, int count) {
        auto peIt = g_particleEmitter.find(entity);
        if (peIt == g_particleEmitter.end()) return;

        ParticleEmitterComponent& pe = peIt->second;

        // Get emitter world position
        float emitX = 0, emitY = 0;
        auto trIt = g_transform2D.find(entity);
        if (trIt != g_transform2D.end()) {
            emitX = trIt->second.position.x;
            emitY = trIt->second.position.y;
        }

        float baseAngle = atan2f(pe.directionY, pe.directionX);
        float spreadRad = pe.spreadAngle * DEG2RAD;

        for (int i = 0; i < count; i++) {
            // Find inactive particle
            for (auto& p : pe.particles) {
                if (!p.active) {
                    p.active = true;
                    p.x = emitX;
                    p.y = emitY;
                    p.maxLife = RandFloat(pe.lifetimeMin, pe.lifetimeMax);
                    p.life = p.maxLife;
                    p.size = pe.sizeStart;

                    // Calculate velocity with spread
                    float angle = baseAngle + RandFloat(-spreadRad/2, spreadRad/2);
                    float speed = RandFloat(
                        sqrtf(pe.velocityMinX*pe.velocityMinX + pe.velocityMinY*pe.velocityMinY),
                        sqrtf(pe.velocityMaxX*pe.velocityMaxX + pe.velocityMaxY*pe.velocityMaxY)
                    );
                    p.vx = cosf(angle) * speed;
                    p.vy = sinf(angle) * speed;
                    break;
                }
            }
        }
    }

    bool Framework_Ecs_EmitterIsActive(int entity) {
        auto it = g_particleEmitter.find(entity);
        return (it != g_particleEmitter.end()) ? it->second.active : false;
    }

    int Framework_Ecs_EmitterGetParticleCount(int entity) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return 0;
        int count = 0;
        for (const auto& p : it->second.particles) {
            if (p.active) count++;
        }
        return count;
    }

    void Framework_Ecs_EmitterClear(int entity) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        for (auto& p : it->second.particles) {
            p.active = false;
        }
    }

    void Framework_Particles_Update(float dt) {
        for (auto& kv : g_particleEmitter) {
            if (!EcsIsAlive(kv.first)) continue;
            ParticleEmitterComponent& pe = kv.second;

            // Spawn new particles if active
            if (pe.active && pe.emissionRate > 0) {
                pe.emissionAccum += dt * pe.emissionRate;
                while (pe.emissionAccum >= 1.0f) {
                    pe.emissionAccum -= 1.0f;
                    Framework_Ecs_EmitterBurst(kv.first, 1);
                }
            }

            // Update existing particles
            for (auto& p : pe.particles) {
                if (!p.active) continue;

                p.life -= dt;
                if (p.life <= 0) {
                    p.active = false;
                    continue;
                }

                // Apply velocity and gravity
                p.vx += pe.gravityX * dt;
                p.vy += pe.gravityY * dt;
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // Interpolate size
                float t = 1.0f - (p.life / p.maxLife);
                p.size = pe.sizeStart + (pe.sizeEnd - pe.sizeStart) * t;
            }
        }
    }

    void Framework_Particles_Draw() {
        for (auto& kv : g_particleEmitter) {
            if (!EcsIsAlive(kv.first)) continue;
            ParticleEmitterComponent& pe = kv.second;

            // Get texture if available
            Texture2D* tex = nullptr;
            auto texIt = g_texByHandle.find(pe.textureHandle);
            if (texIt != g_texByHandle.end() && texIt->second.valid) {
                tex = &texIt->second.tex;
            }

            for (const auto& p : pe.particles) {
                if (!p.active) continue;

                // Calculate color
                float t = 1.0f - (p.life / p.maxLife);
                Color c;
                c.r = LerpByte(pe.colorStart.r, pe.colorEnd.r, t);
                c.g = LerpByte(pe.colorStart.g, pe.colorEnd.g, t);
                c.b = LerpByte(pe.colorStart.b, pe.colorEnd.b, t);
                c.a = LerpByte(pe.colorStart.a, pe.colorEnd.a, t);

                if (tex && pe.sourceRect.width > 0 && pe.sourceRect.height > 0) {
                    // Draw textured particle
                    Rectangle dest = { p.x - p.size/2, p.y - p.size/2, p.size, p.size };
                    DrawTexturePro(*tex, pe.sourceRect, dest, {0, 0}, 0, c);
                } else {
                    // Draw as circle
                    DrawCircle((int)p.x, (int)p.y, p.size/2, c);
                }
            }
        }
    }

    // ========================================================================
    // ENHANCED PARTICLE SYSTEM - Implementation
    // ========================================================================

    // Emitter shape configuration
    void Framework_Ecs_SetEmitterShape(int entity, int shape) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.shape = shape;
    }

    void Framework_Ecs_SetEmitterShapeRadius(int entity, float radius) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.shapeRadius = radius;
    }

    void Framework_Ecs_SetEmitterShapeSize(int entity, float width, float height) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.shapeWidth = width;
        it->second.shapeHeight = height;
    }

    void Framework_Ecs_SetEmitterShapeInnerRadius(int entity, float innerRadius) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.shapeInnerRadius = innerRadius;
    }

    void Framework_Ecs_SetEmitterShapeLine(int entity, float x1, float y1, float x2, float y2) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.shapeLine[0] = x1;
        it->second.shapeLine[1] = y1;
        it->second.shapeLine[2] = x2;
        it->second.shapeLine[3] = y2;
    }

    void Framework_Ecs_SetEmitterEdgeEmission(int entity, bool edgeOnly) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.edgeEmission = edgeOnly;
    }

    // Rotation/spin
    void Framework_Ecs_SetEmitterRotation(int entity, float startMin, float startMax) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.rotationMin = startMin;
        it->second.rotationMax = startMax;
    }

    void Framework_Ecs_SetEmitterSpin(int entity, float spinMin, float spinMax) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.spinMin = spinMin;
        it->second.spinMax = spinMax;
    }

    // Blend mode
    void Framework_Ecs_SetEmitterBlendMode(int entity, int blendMode) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.blendMode = blendMode;
    }

    // Color gradient
    void Framework_Ecs_SetEmitterColorGradient(int entity, int stopCount) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        if (stopCount < 2) stopCount = 2;
        if (stopCount > 4) stopCount = 4;
        it->second.colorStopCount = stopCount;
    }

    void Framework_Ecs_SetEmitterColorStop(int entity, int stopIndex, float time,
                                           unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        if (stopIndex < 0 || stopIndex >= 4) return;
        it->second.colorStops[stopIndex].time = time;
        it->second.colorStops[stopIndex].color = { r, g, b, a };
    }

    // Size over lifetime curve
    void Framework_Ecs_SetEmitterSizeOverLifetime(int entity, float t0Size, float t1Size, float t2Size, float t3Size) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.sizeCurve[0] = t0Size;
        it->second.sizeCurve[1] = t1Size;
        it->second.sizeCurve[2] = t2Size;
        it->second.sizeCurve[3] = t3Size;
        it->second.useSizeCurve = true;
    }

    // Velocity modifiers
    void Framework_Ecs_SetEmitterDrag(int entity, float drag) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.drag = drag;
    }

    void Framework_Ecs_SetEmitterAcceleration(int entity, float ax, float ay) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.accelX = ax;
        it->second.accelY = ay;
    }

    void Framework_Ecs_SetEmitterRadialAccel(int entity, float radialAccel) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.radialAccel = radialAccel;
    }

    void Framework_Ecs_SetEmitterTangentialAccel(int entity, float tangentAccel) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.tangentialAccel = tangentAccel;
    }

    // Noise
    void Framework_Ecs_SetEmitterNoise(int entity, float strength, float frequency, float scrollSpeed) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.noiseStrength = strength;
        it->second.noiseFrequency = frequency;
        it->second.noiseScrollSpeed = scrollSpeed;
    }

    // Particle attractors
    int Framework_Particle_CreateAttractor(float x, float y, float strength, float radius) {
        ParticleAttractor attr;
        attr.id = g_nextAttractorId++;
        attr.x = x;
        attr.y = y;
        attr.strength = strength;
        attr.radius = radius;
        attr.falloffPower = 1.0f;
        g_particleAttractors[attr.id] = attr;
        return attr.id;
    }

    void Framework_Particle_DestroyAttractor(int attractorId) {
        g_particleAttractors.erase(attractorId);
    }

    void Framework_Particle_SetAttractorPosition(int attractorId, float x, float y) {
        auto it = g_particleAttractors.find(attractorId);
        if (it == g_particleAttractors.end()) return;
        it->second.x = x;
        it->second.y = y;
    }

    void Framework_Particle_SetAttractorStrength(int attractorId, float strength) {
        auto it = g_particleAttractors.find(attractorId);
        if (it == g_particleAttractors.end()) return;
        it->second.strength = strength;
    }

    void Framework_Particle_SetAttractorRadius(int attractorId, float radius) {
        auto it = g_particleAttractors.find(attractorId);
        if (it == g_particleAttractors.end()) return;
        it->second.radius = radius;
    }

    void Framework_Particle_SetAttractorFalloff(int attractorId, float falloffPower) {
        auto it = g_particleAttractors.find(attractorId);
        if (it == g_particleAttractors.end()) return;
        it->second.falloffPower = falloffPower;
    }

    int Framework_Particle_GetAttractorCount() {
        return (int)g_particleAttractors.size();
    }

    // Sub-emitters
    void Framework_Ecs_SetEmitterSubEmitter(int entity, int subEmitterEntity) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.subEmitterOnDeath = subEmitterEntity;
    }

    void Framework_Ecs_SetEmitterSubEmitterOnBirth(int entity, int subEmitterEntity) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.subEmitterOnBirth = subEmitterEntity;
    }

    void Framework_Ecs_ClearSubEmitters(int entity) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.subEmitterOnDeath = -1;
        it->second.subEmitterOnBirth = -1;
    }

    // Trail
    void Framework_Ecs_SetEmitterTrail(int entity, bool enabled, int trailLength, float trailWidth) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.trailEnabled = enabled;
        it->second.trailLength = trailLength;
        it->second.trailWidth = trailWidth;
    }

    void Framework_Ecs_SetEmitterTrailColor(int entity, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.trailColor = { r, g, b, a };
    }

    // Collision
    void Framework_Ecs_SetEmitterCollision(int entity, bool enabled) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.collisionEnabled = enabled;
    }

    void Framework_Ecs_SetEmitterCollisionBounce(int entity, float bounciness) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.collisionBounce = bounciness;
    }

    void Framework_Ecs_SetEmitterCollisionFriction(int entity, float friction) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.collisionFriction = friction;
    }

    void Framework_Ecs_SetEmitterCollisionLifetimeLoss(int entity, float lifetimeLoss) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.collisionLifetimeLoss = lifetimeLoss;
    }

    void Framework_Ecs_SetEmitterCollisionKillOnCollide(int entity, bool kill) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.collisionKill = kill;
    }

    // Animation
    void Framework_Ecs_SetEmitterAnimation(int entity, int columns, int rows, float fps, bool randomStart) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.animColumns = columns > 0 ? columns : 1;
        it->second.animRows = rows > 0 ? rows : 1;
        it->second.animFPS = fps;
        it->second.animRandomStart = randomStart;
    }

    // Texture sheet
    void Framework_Ecs_SetEmitterTextureSheet(int entity, int textureHandle, int columns, int rows) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.textureHandle = textureHandle;
        it->second.animColumns = columns > 0 ? columns : 1;
        it->second.animRows = rows > 0 ? rows : 1;
    }

    void Framework_Ecs_SetEmitterRandomTexture(int entity, bool randomize) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.randomTexture = randomize;
    }

    // Sorting
    void Framework_Ecs_SetEmitterSortMode(int entity, int sortMode) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;
        it->second.sortMode = sortMode;
    }

    // Pre-warming
    void Framework_Ecs_EmitterPrewarm(int entity, float simulateTime) {
        auto it = g_particleEmitter.find(entity);
        if (it == g_particleEmitter.end()) return;

        // Temporarily activate emitter and simulate
        bool wasActive = it->second.active;
        it->second.active = true;

        // Simulate in small timesteps
        float dt = 1.0f / 60.0f;
        for (float t = 0; t < simulateTime; t += dt) {
            // Spawn particles based on emission rate
            it->second.emissionAccum += dt * it->second.emissionRate;
            while (it->second.emissionAccum >= 1.0f) {
                it->second.emissionAccum -= 1.0f;
                Framework_Ecs_EmitterBurst(entity, 1);
            }

            // Update particles
            ParticleEmitterComponent& pe = it->second;
            for (auto& p : pe.particles) {
                if (!p.active) continue;
                p.life -= dt;
                if (p.life <= 0) {
                    p.active = false;
                    continue;
                }
                p.vx += pe.gravityX * dt;
                p.vy += pe.gravityY * dt;
                p.x += p.vx * dt;
                p.y += p.vy * dt;
            }
        }

        it->second.active = wasActive;
    }

    // Pool statistics
    int Framework_Particles_GetTotalCount() {
        int total = 0;
        for (const auto& kv : g_particleEmitter) {
            for (const auto& p : kv.second.particles) {
                if (p.active) total++;
            }
        }
        return total;
    }

    int Framework_Particles_GetEmitterCount() {
        return (int)g_particleEmitter.size();
    }

    void Framework_Particles_SetGlobalTimeScale(float scale) {
        g_particleGlobalTimeScale = scale;
    }

    // ========================================================================
    // UI SYSTEM - Implementation
    // ========================================================================

    // UI Element structure
    struct UIElement {
        int id = -1;
        int type = UI_LABEL;
        int state = UI_STATE_NORMAL;
        int anchor = UI_ANCHOR_TOP_LEFT;
        int parent = -1;
        int layer = 0;

        // Position and size
        float x = 0, y = 0;
        float width = 100, height = 30;
        float padding[4] = {5, 5, 5, 5};  // left, top, right, bottom

        // Text properties
        std::string text;
        std::string placeholder;
        int fontHandle = 0;
        float fontSize = 20.0f;
        Color textColor = WHITE;
        int textAlign = UI_ANCHOR_CENTER_LEFT;

        // Colors
        Color bgColor = { 60, 60, 60, 255 };
        Color borderColor = { 100, 100, 100, 255 };
        Color hoverColor = { 80, 80, 80, 255 };
        Color pressedColor = { 40, 40, 40, 255 };
        Color disabledColor = { 40, 40, 40, 150 };
        float borderWidth = 1.0f;
        float cornerRadius = 0.0f;

        // Value properties (slider, progress, checkbox)
        float value = 0.0f;
        float minValue = 0.0f;
        float maxValue = 1.0f;
        bool checked = false;

        // TextInput specific
        int maxLength = 256;
        bool passwordMode = false;
        int cursorPos = 0;
        float cursorBlinkTimer = 0.0f;

        // Image specific
        int textureHandle = 0;
        Rectangle sourceRect = {0, 0, 0, 0};
        Color tint = WHITE;

        // State
        bool visible = true;
        bool enabled = true;
        bool valid = true;

        // Callbacks (stored as function pointers)
        UICallback onClick = nullptr;
        UICallback onHover = nullptr;
        UIValueCallback onValueChanged = nullptr;
        UITextCallback onTextChanged = nullptr;
    };

    // UI Storage
    static std::unordered_map<int, UIElement> g_uiElements;
    static int g_uiNextId = 1;
    static int g_uiFocusedId = -1;
    static int g_uiHoveredId = -1;

    // Helper: Get computed position based on anchor
    // depth parameter prevents infinite recursion on circular parent chains
    static Vector2 UI_GetAnchoredPosition(const UIElement& el, int depth = 0) {
        constexpr int MAX_UI_DEPTH = 32;  // Prevent stack overflow on circular parents

        float baseX = el.x;
        float baseY = el.y;

        // Get parent bounds or screen bounds
        float parentX = 0, parentY = 0;
        float parentW = (float)GetScreenWidth();
        float parentH = (float)GetScreenHeight();

        if (el.parent >= 0 && depth < MAX_UI_DEPTH) {
            auto pit = g_uiElements.find(el.parent);
            if (pit != g_uiElements.end() && pit->second.valid) {
                Vector2 ppos = UI_GetAnchoredPosition(pit->second, depth + 1);
                parentX = ppos.x;
                parentY = ppos.y;
                parentW = pit->second.width;
                parentH = pit->second.height;
            }
        }

        float anchorX = parentX, anchorY = parentY;
        switch (el.anchor) {
            case UI_ANCHOR_TOP_LEFT:      anchorX = parentX; anchorY = parentY; break;
            case UI_ANCHOR_TOP_CENTER:    anchorX = parentX + parentW/2 - el.width/2; anchorY = parentY; break;
            case UI_ANCHOR_TOP_RIGHT:     anchorX = parentX + parentW - el.width; anchorY = parentY; break;
            case UI_ANCHOR_CENTER_LEFT:   anchorX = parentX; anchorY = parentY + parentH/2 - el.height/2; break;
            case UI_ANCHOR_CENTER:        anchorX = parentX + parentW/2 - el.width/2; anchorY = parentY + parentH/2 - el.height/2; break;
            case UI_ANCHOR_CENTER_RIGHT:  anchorX = parentX + parentW - el.width; anchorY = parentY + parentH/2 - el.height/2; break;
            case UI_ANCHOR_BOTTOM_LEFT:   anchorX = parentX; anchorY = parentY + parentH - el.height; break;
            case UI_ANCHOR_BOTTOM_CENTER: anchorX = parentX + parentW/2 - el.width/2; anchorY = parentY + parentH - el.height; break;
            case UI_ANCHOR_BOTTOM_RIGHT:  anchorX = parentX + parentW - el.width; anchorY = parentY + parentH - el.height; break;
        }

        return { anchorX + baseX, anchorY + baseY };
    }

    // Helper: Point in rect
    static bool UI_PointInRect(float px, float py, float rx, float ry, float rw, float rh) {
        return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
    }

    // Helper: Draw rounded rectangle
    static void UI_DrawRoundedRect(float x, float y, float w, float h, float radius, Color color) {
        if (radius <= 0) {
            DrawRectangle((int)x, (int)y, (int)w, (int)h, color);
        } else {
            DrawRectangleRounded({x, y, w, h}, radius / (w < h ? w : h), 8, color);
        }
    }

    // Helper: Get font by handle (for UI)
    static Font UI_GetFontByHandle(int handle) {
        auto it = g_fontByHandle.find(handle);
        if (it != g_fontByHandle.end() && it->second.valid) {
            return it->second.font;
        }
        return GetFontDefault();
    }

    // Helper: Draw text with alignment
    static void UI_DrawAlignedText(const char* text, float x, float y, float w, float h, int fontH, float fontSize, int align, Color color) {
        Font font = UI_GetFontByHandle(fontH);
        Vector2 textSize = MeasureTextEx(font, text, fontSize, 1);

        float tx = x, ty = y;
        switch (align) {
            case UI_ANCHOR_TOP_LEFT:      tx = x; ty = y; break;
            case UI_ANCHOR_TOP_CENTER:    tx = x + w/2 - textSize.x/2; ty = y; break;
            case UI_ANCHOR_TOP_RIGHT:     tx = x + w - textSize.x; ty = y; break;
            case UI_ANCHOR_CENTER_LEFT:   tx = x; ty = y + h/2 - textSize.y/2; break;
            case UI_ANCHOR_CENTER:        tx = x + w/2 - textSize.x/2; ty = y + h/2 - textSize.y/2; break;
            case UI_ANCHOR_CENTER_RIGHT:  tx = x + w - textSize.x; ty = y + h/2 - textSize.y/2; break;
            case UI_ANCHOR_BOTTOM_LEFT:   tx = x; ty = y + h - textSize.y; break;
            case UI_ANCHOR_BOTTOM_CENTER: tx = x + w/2 - textSize.x/2; ty = y + h - textSize.y; break;
            case UI_ANCHOR_BOTTOM_RIGHT:  tx = x + w - textSize.x; ty = y + h - textSize.y; break;
        }

        DrawTextEx(font, text, {tx, ty}, fontSize, 1, color);
    }

    // Create functions
    int Framework_UI_CreateLabel(const char* text, float x, float y) {
        UIElement el;
        el.id = g_uiNextId++;
        el.type = UI_LABEL;
        el.x = x; el.y = y;
        el.text = text ? text : "";
        el.bgColor = {0, 0, 0, 0};  // Transparent by default
        el.borderWidth = 0;

        // Auto-size based on text
        Vector2 textSize = MeasureTextEx(GetFontDefault(), el.text.c_str(), el.fontSize, 1);
        el.width = textSize.x + el.padding[0] + el.padding[2];
        el.height = textSize.y + el.padding[1] + el.padding[3];

        g_uiElements[el.id] = el;
        return el.id;
    }

    int Framework_UI_CreateButton(const char* text, float x, float y, float width, float height) {
        UIElement el;
        el.id = g_uiNextId++;
        el.type = UI_BUTTON;
        el.x = x; el.y = y;
        el.width = width; el.height = height;
        el.text = text ? text : "";
        el.textAlign = UI_ANCHOR_CENTER;
        el.bgColor = { 70, 130, 180, 255 };  // Steel blue
        el.hoverColor = { 100, 149, 237, 255 };  // Cornflower blue
        el.pressedColor = { 30, 90, 140, 255 };
        el.cornerRadius = 4.0f;

        g_uiElements[el.id] = el;
        return el.id;
    }

    int Framework_UI_CreatePanel(float x, float y, float width, float height) {
        UIElement el;
        el.id = g_uiNextId++;
        el.type = UI_PANEL;
        el.x = x; el.y = y;
        el.width = width; el.height = height;
        el.bgColor = { 45, 45, 48, 240 };
        el.borderColor = { 80, 80, 80, 255 };
        el.cornerRadius = 8.0f;

        g_uiElements[el.id] = el;
        return el.id;
    }

    int Framework_UI_CreateSlider(float x, float y, float width, float minVal, float maxVal, float initialVal) {
        UIElement el;
        el.id = g_uiNextId++;
        el.type = UI_SLIDER;
        el.x = x; el.y = y;
        el.width = width; el.height = 20;
        el.minValue = minVal; el.maxValue = maxVal;
        el.value = initialVal;
        el.bgColor = { 60, 60, 60, 255 };
        el.hoverColor = { 70, 130, 180, 255 };  // Track fill color
        el.pressedColor = { 100, 149, 237, 255 };  // Handle color
        el.cornerRadius = 4.0f;

        g_uiElements[el.id] = el;
        return el.id;
    }

    int Framework_UI_CreateCheckbox(const char* text, float x, float y, bool initialState) {
        UIElement el;
        el.id = g_uiNextId++;
        el.type = UI_CHECKBOX;
        el.x = x; el.y = y;
        el.width = 24; el.height = 24;
        el.text = text ? text : "";
        el.checked = initialState;
        el.value = initialState ? 1.0f : 0.0f;
        el.bgColor = { 60, 60, 60, 255 };
        el.hoverColor = { 80, 80, 80, 255 };
        el.pressedColor = { 70, 130, 180, 255 };  // Checked color
        el.cornerRadius = 4.0f;

        g_uiElements[el.id] = el;
        return el.id;
    }

    int Framework_UI_CreateTextInput(float x, float y, float width, float height, const char* placeholder) {
        UIElement el;
        el.id = g_uiNextId++;
        el.type = UI_TEXTINPUT;
        el.x = x; el.y = y;
        el.width = width; el.height = height;
        el.placeholder = placeholder ? placeholder : "";
        el.bgColor = { 30, 30, 30, 255 };
        el.borderColor = { 100, 100, 100, 255 };
        el.hoverColor = { 70, 130, 180, 255 };  // Focus border color
        el.cornerRadius = 4.0f;
        el.textAlign = UI_ANCHOR_CENTER_LEFT;

        g_uiElements[el.id] = el;
        return el.id;
    }

    int Framework_UI_CreateProgressBar(float x, float y, float width, float height, float initialValue) {
        UIElement el;
        el.id = g_uiNextId++;
        el.type = UI_PROGRESSBAR;
        el.x = x; el.y = y;
        el.width = width; el.height = height;
        el.value = initialValue;
        el.bgColor = { 40, 40, 40, 255 };
        el.hoverColor = { 76, 175, 80, 255 };  // Fill color (green)
        el.cornerRadius = 4.0f;

        g_uiElements[el.id] = el;
        return el.id;
    }

    int Framework_UI_CreateImage(int textureHandle, float x, float y, float width, float height) {
        UIElement el;
        el.id = g_uiNextId++;
        el.type = UI_IMAGE;
        el.x = x; el.y = y;
        el.width = width; el.height = height;
        el.textureHandle = textureHandle;
        el.tint = WHITE;
        el.bgColor = {0, 0, 0, 0};

        g_uiElements[el.id] = el;
        return el.id;
    }

    void Framework_UI_Destroy(int elementId) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) {
            it->second.valid = false;
            g_uiElements.erase(it);
        }
        if (g_uiFocusedId == elementId) g_uiFocusedId = -1;
        if (g_uiHoveredId == elementId) g_uiHoveredId = -1;
    }

    void Framework_UI_DestroyAll() {
        g_uiElements.clear();
        g_uiFocusedId = -1;
        g_uiHoveredId = -1;
    }

    bool Framework_UI_IsValid(int elementId) {
        auto it = g_uiElements.find(elementId);
        return it != g_uiElements.end() && it->second.valid;
    }

    // Property setters - Common
    void Framework_UI_SetPosition(int elementId, float x, float y) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.x = x; it->second.y = y; }
    }

    void Framework_UI_SetSize(int elementId, float width, float height) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.width = width; it->second.height = height; }
    }

    void Framework_UI_SetAnchor(int elementId, int anchor) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.anchor = anchor; }
    }

    void Framework_UI_SetVisible(int elementId, bool visible) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.visible = visible; }
    }

    void Framework_UI_SetEnabled(int elementId, bool enabled) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) {
            it->second.enabled = enabled;
            it->second.state = enabled ? UI_STATE_NORMAL : UI_STATE_DISABLED;
        }
    }

    void Framework_UI_SetParent(int elementId, int parentId) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.parent = parentId; }
    }

    void Framework_UI_SetLayer(int elementId, int layer) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.layer = layer; }
    }

    float Framework_UI_GetX(int elementId) {
        auto it = g_uiElements.find(elementId);
        return (it != g_uiElements.end()) ? it->second.x : 0;
    }

    float Framework_UI_GetY(int elementId) {
        auto it = g_uiElements.find(elementId);
        return (it != g_uiElements.end()) ? it->second.y : 0;
    }

    float Framework_UI_GetWidth(int elementId) {
        auto it = g_uiElements.find(elementId);
        return (it != g_uiElements.end()) ? it->second.width : 0;
    }

    float Framework_UI_GetHeight(int elementId) {
        auto it = g_uiElements.find(elementId);
        return (it != g_uiElements.end()) ? it->second.height : 0;
    }

    int Framework_UI_GetState(int elementId) {
        auto it = g_uiElements.find(elementId);
        return (it != g_uiElements.end()) ? it->second.state : UI_STATE_NORMAL;
    }

    int Framework_UI_GetType(int elementId) {
        auto it = g_uiElements.find(elementId);
        return (it != g_uiElements.end()) ? it->second.type : UI_LABEL;
    }

    bool Framework_UI_IsVisible(int elementId) {
        auto it = g_uiElements.find(elementId);
        return (it != g_uiElements.end()) ? it->second.visible : false;
    }

    bool Framework_UI_IsEnabled(int elementId) {
        auto it = g_uiElements.find(elementId);
        return (it != g_uiElements.end()) ? it->second.enabled : false;
    }

    // Property setters - Text/Font
    void Framework_UI_SetText(int elementId, const char* text) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.text = text ? text : ""; }
    }

    const char* Framework_UI_GetText(int elementId) {
        auto it = g_uiElements.find(elementId);
        return (it != g_uiElements.end()) ? it->second.text.c_str() : "";
    }

    void Framework_UI_SetFont(int elementId, int fontHandle) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.fontHandle = fontHandle; }
    }

    void Framework_UI_SetFontSize(int elementId, float size) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.fontSize = size; }
    }

    void Framework_UI_SetTextColor(int elementId, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.textColor = {r, g, b, a}; }
    }

    void Framework_UI_SetTextAlign(int elementId, int anchor) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.textAlign = anchor; }
    }

    // Property setters - Colors
    void Framework_UI_SetBackgroundColor(int elementId, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.bgColor = {r, g, b, a}; }
    }

    void Framework_UI_SetBorderColor(int elementId, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.borderColor = {r, g, b, a}; }
    }

    void Framework_UI_SetHoverColor(int elementId, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.hoverColor = {r, g, b, a}; }
    }

    void Framework_UI_SetPressedColor(int elementId, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.pressedColor = {r, g, b, a}; }
    }

    void Framework_UI_SetDisabledColor(int elementId, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.disabledColor = {r, g, b, a}; }
    }

    void Framework_UI_SetBorderWidth(int elementId, float width) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.borderWidth = width; }
    }

    void Framework_UI_SetCornerRadius(int elementId, float radius) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.cornerRadius = radius; }
    }

    void Framework_UI_SetPadding(int elementId, float left, float top, float right, float bottom) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) {
            it->second.padding[0] = left;
            it->second.padding[1] = top;
            it->second.padding[2] = right;
            it->second.padding[3] = bottom;
        }
    }

    // Property setters - Value-based
    void Framework_UI_SetValue(int elementId, float value) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) {
            float clamped = fmaxf(it->second.minValue, fminf(it->second.maxValue, value));
            it->second.value = clamped;
        }
    }

    float Framework_UI_GetValue(int elementId) {
        auto it = g_uiElements.find(elementId);
        return (it != g_uiElements.end()) ? it->second.value : 0;
    }

    void Framework_UI_SetMinMax(int elementId, float minVal, float maxVal) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) {
            it->second.minValue = minVal;
            it->second.maxValue = maxVal;
        }
    }

    void Framework_UI_SetChecked(int elementId, bool checked) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) {
            it->second.checked = checked;
            it->second.value = checked ? 1.0f : 0.0f;
        }
    }

    bool Framework_UI_IsChecked(int elementId) {
        auto it = g_uiElements.find(elementId);
        return (it != g_uiElements.end()) ? it->second.checked : false;
    }

    // Property setters - TextInput specific
    void Framework_UI_SetPlaceholder(int elementId, const char* text) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.placeholder = text ? text : ""; }
    }

    void Framework_UI_SetMaxLength(int elementId, int maxLength) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.maxLength = maxLength; }
    }

    void Framework_UI_SetPasswordMode(int elementId, bool isPassword) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.passwordMode = isPassword; }
    }

    void Framework_UI_SetCursorPosition(int elementId, int position) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) {
            it->second.cursorPos = std::max(0, std::min(position, (int)it->second.text.length()));
        }
    }

    int Framework_UI_GetCursorPosition(int elementId) {
        auto it = g_uiElements.find(elementId);
        return (it != g_uiElements.end()) ? it->second.cursorPos : 0;
    }

    // Property setters - Image specific
    void Framework_UI_SetTexture(int elementId, int textureHandle) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.textureHandle = textureHandle; }
    }

    void Framework_UI_SetSourceRect(int elementId, float srcX, float srcY, float srcW, float srcH) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.sourceRect = {srcX, srcY, srcW, srcH}; }
    }

    void Framework_UI_SetTint(int elementId, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.tint = {r, g, b, a}; }
    }

    // Callbacks
    void Framework_UI_SetClickCallback(int elementId, UICallback callback) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.onClick = callback; }
    }

    void Framework_UI_SetHoverCallback(int elementId, UICallback callback) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.onHover = callback; }
    }

    void Framework_UI_SetValueChangedCallback(int elementId, UIValueCallback callback) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.onValueChanged = callback; }
    }

    void Framework_UI_SetTextChangedCallback(int elementId, UITextCallback callback) {
        auto it = g_uiElements.find(elementId);
        if (it != g_uiElements.end()) { it->second.onTextChanged = callback; }
    }

    // UI Update - Process input and states
    void Framework_UI_Update() {
        Vector2 mousePos = GetMousePosition();
        bool mousePressed = IsMouseButtonPressed(MOUSE_LEFT_BUTTON);
        bool mouseDown = IsMouseButtonDown(MOUSE_LEFT_BUTTON);
        bool mouseReleased = IsMouseButtonReleased(MOUSE_LEFT_BUTTON);

        int newHovered = -1;

        // Collect and sort elements by layer (higher layers on top), then by area (smaller on top)
        // This ensures children (usually smaller) are checked before parents at the same layer
        std::vector<std::pair<int, UIElement*>> sortedElements;
        for (auto& kv : g_uiElements) {
            if (kv.second.valid && kv.second.visible && kv.second.enabled) {
                sortedElements.push_back({kv.first, &kv.second});
            }
        }
        std::sort(sortedElements.begin(), sortedElements.end(),
            [](const auto& a, const auto& b) {
                // First by layer (higher layer = on top = checked first)
                if (a.second->layer != b.second->layer)
                    return a.second->layer > b.second->layer;
                // Then by area (smaller area = on top = checked first)
                float areaA = a.second->width * a.second->height;
                float areaB = b.second->width * b.second->height;
                return areaA < areaB;
            });

        // Find topmost hovered element
        for (auto& [id, el] : sortedElements) {
            Vector2 pos = UI_GetAnchoredPosition(*el);
            if (UI_PointInRect(mousePos.x, mousePos.y, pos.x, pos.y, el->width, el->height)) {
                newHovered = id;
                break;  // Topmost wins
            }
        }

        // Update hover state
        if (newHovered != g_uiHoveredId) {
            if (g_uiHoveredId >= 0) {
                auto it = g_uiElements.find(g_uiHoveredId);
                if (it != g_uiElements.end() && it->second.state == UI_STATE_HOVERED) {
                    it->second.state = UI_STATE_NORMAL;
                }
            }
            g_uiHoveredId = newHovered;
            if (newHovered >= 0) {
                auto it = g_uiElements.find(newHovered);
                if (it != g_uiElements.end()) {
                    it->second.state = UI_STATE_HOVERED;
                    if (it->second.onHover) it->second.onHover(newHovered);
                }
            }
        }

        // Process clicks
        if (mousePressed && newHovered >= 0) {
            auto it = g_uiElements.find(newHovered);
            if (it != g_uiElements.end()) {
                it->second.state = UI_STATE_PRESSED;

                // Set focus for text inputs
                if (it->second.type == UI_TEXTINPUT) {
                    g_uiFocusedId = newHovered;
                    it->second.state = UI_STATE_FOCUSED;
                }
            }
        }

        // Click outside clears focus
        if (mousePressed && newHovered < 0) {
            g_uiFocusedId = -1;
        }

        // Process release (click complete)
        if (mouseReleased && newHovered >= 0) {
            auto it = g_uiElements.find(newHovered);
            if (it != g_uiElements.end() && it->second.state == UI_STATE_PRESSED) {
                it->second.state = UI_STATE_HOVERED;

                // Handle click by type
                switch (it->second.type) {
                    case UI_BUTTON:
                        if (it->second.onClick) it->second.onClick(newHovered);
                        break;
                    case UI_CHECKBOX:
                        it->second.checked = !it->second.checked;
                        it->second.value = it->second.checked ? 1.0f : 0.0f;
                        if (it->second.onValueChanged) it->second.onValueChanged(newHovered, it->second.value);
                        break;
                }
            }
        }

        // Slider dragging
        for (auto& kv : g_uiElements) {
            if (kv.second.type == UI_SLIDER && kv.second.state == UI_STATE_PRESSED && mouseDown) {
                Vector2 pos = UI_GetAnchoredPosition(kv.second);
                float relX = mousePos.x - pos.x;
                float ratio = fmaxf(0, fminf(1, relX / kv.second.width));
                float newValue = kv.second.minValue + ratio * (kv.second.maxValue - kv.second.minValue);
                if (newValue != kv.second.value) {
                    kv.second.value = newValue;
                    if (kv.second.onValueChanged) kv.second.onValueChanged(kv.first, newValue);
                }
            }
        }

        // Text input handling
        if (g_uiFocusedId >= 0) {
            auto it = g_uiElements.find(g_uiFocusedId);
            if (it != g_uiElements.end() && it->second.type == UI_TEXTINPUT) {
                UIElement& el = it->second;
                el.cursorBlinkTimer += GetFrameTime();

                // Handle character input
                int key = GetCharPressed();
                while (key > 0) {
                    if ((int)el.text.length() < el.maxLength && key >= 32 && key <= 126) {
                        el.text.insert(el.cursorPos, 1, (char)key);
                        el.cursorPos++;
                        if (el.onTextChanged) el.onTextChanged(g_uiFocusedId, el.text.c_str());
                    }
                    key = GetCharPressed();
                }

                // Handle special keys
                if (IsKeyPressed(KEY_BACKSPACE) && el.cursorPos > 0) {
                    el.text.erase(el.cursorPos - 1, 1);
                    el.cursorPos--;
                    if (el.onTextChanged) el.onTextChanged(g_uiFocusedId, el.text.c_str());
                }
                if (IsKeyPressed(KEY_DELETE) && el.cursorPos < (int)el.text.length()) {
                    el.text.erase(el.cursorPos, 1);
                    if (el.onTextChanged) el.onTextChanged(g_uiFocusedId, el.text.c_str());
                }
                if (IsKeyPressed(KEY_LEFT) && el.cursorPos > 0) el.cursorPos--;
                if (IsKeyPressed(KEY_RIGHT) && el.cursorPos < (int)el.text.length()) el.cursorPos++;
                if (IsKeyPressed(KEY_HOME)) el.cursorPos = 0;
                if (IsKeyPressed(KEY_END)) el.cursorPos = (int)el.text.length();
            }
        }
    }

    // Helper: Check if element and all ancestors are visible
    static bool UI_IsEffectivelyVisible(const UIElement& el) {
        if (!el.visible) return false;
        if (el.parent >= 0) {
            auto pit = g_uiElements.find(el.parent);
            if (pit != g_uiElements.end()) {
                return UI_IsEffectivelyVisible(pit->second);
            }
        }
        return true;
    }

    // UI Draw
    void Framework_UI_Draw() {
        // Collect and sort elements by layer
        std::vector<std::pair<int, UIElement*>> sortedElements;
        for (auto& kv : g_uiElements) {
            if (kv.second.valid && UI_IsEffectivelyVisible(kv.second)) {
                sortedElements.push_back({kv.first, &kv.second});
            }
        }
        std::sort(sortedElements.begin(), sortedElements.end(),
            [](const auto& a, const auto& b) { return a.second->layer < b.second->layer; });

        for (auto& [id, el] : sortedElements) {
            Vector2 pos = UI_GetAnchoredPosition(*el);
            float x = pos.x, y = pos.y, w = el->width, h = el->height;

            Color bgColor = el->bgColor;
            if (!el->enabled) bgColor = el->disabledColor;
            else if (el->state == UI_STATE_PRESSED) bgColor = el->pressedColor;
            else if (el->state == UI_STATE_HOVERED) bgColor = el->hoverColor;
            else if (el->state == UI_STATE_FOCUSED) bgColor = el->bgColor;

            switch (el->type) {
                case UI_LABEL: {
                    if (bgColor.a > 0) UI_DrawRoundedRect(x, y, w, h, el->cornerRadius, bgColor);
                    UI_DrawAlignedText(el->text.c_str(), x + el->padding[0], y + el->padding[1],
                        w - el->padding[0] - el->padding[2], h - el->padding[1] - el->padding[3],
                        el->fontHandle, el->fontSize, el->textAlign, el->textColor);
                    break;
                }

                case UI_BUTTON: {
                    UI_DrawRoundedRect(x, y, w, h, el->cornerRadius, bgColor);
                    if (el->borderWidth > 0) {
                        DrawRectangleLinesEx({x, y, w, h}, el->borderWidth, el->borderColor);
                    }
                    UI_DrawAlignedText(el->text.c_str(), x, y, w, h, el->fontHandle, el->fontSize, el->textAlign, el->textColor);
                    break;
                }

                case UI_PANEL: {
                    UI_DrawRoundedRect(x, y, w, h, el->cornerRadius, bgColor);
                    if (el->borderWidth > 0) {
                        DrawRectangleLinesEx({x, y, w, h}, el->borderWidth, el->borderColor);
                    }
                    break;
                }

                case UI_SLIDER: {
                    // Track background
                    UI_DrawRoundedRect(x, y + h/2 - 4, w, 8, 4, el->bgColor);
                    // Filled portion
                    float ratio = (el->value - el->minValue) / (el->maxValue - el->minValue);
                    UI_DrawRoundedRect(x, y + h/2 - 4, w * ratio, 8, 4, el->hoverColor);
                    // Handle
                    float handleX = x + w * ratio - 8;
                    DrawCircle((int)(handleX + 8), (int)(y + h/2), 10, el->pressedColor);
                    break;
                }

                case UI_CHECKBOX: {
                    // Box
                    UI_DrawRoundedRect(x, y, 24, 24, el->cornerRadius, bgColor);
                    DrawRectangleLinesEx({x, y, 24, 24}, el->borderWidth, el->borderColor);
                    // Checkmark
                    if (el->checked) {
                        DrawLine((int)(x + 5), (int)(y + 12), (int)(x + 10), (int)(y + 18), el->pressedColor);
                        DrawLine((int)(x + 10), (int)(y + 18), (int)(x + 19), (int)(y + 6), el->pressedColor);
                    }
                    // Label
                    if (!el->text.empty()) {
                        UI_DrawAlignedText(el->text.c_str(), x + 30, y, w, 24, el->fontHandle, el->fontSize, UI_ANCHOR_CENTER_LEFT, el->textColor);
                    }
                    break;
                }

                case UI_TEXTINPUT: {
                    Color borderCol = (el->state == UI_STATE_FOCUSED) ? el->hoverColor : el->borderColor;
                    UI_DrawRoundedRect(x, y, w, h, el->cornerRadius, el->bgColor);
                    DrawRectangleLinesEx({x, y, w, h}, el->borderWidth, borderCol);

                    // Text or placeholder
                    const char* displayText = el->text.empty() ? el->placeholder.c_str() : el->text.c_str();
                    Color textCol = el->text.empty() ? Color{150, 150, 150, 255} : el->textColor;

                    std::string masked = el->text;
                    if (el->passwordMode && !el->text.empty()) {
                        masked = std::string(el->text.length(), '*');
                        displayText = masked.c_str();
                    }

                    UI_DrawAlignedText(displayText, x + el->padding[0], y, w - el->padding[0] - el->padding[2], h, el->fontHandle, el->fontSize, el->textAlign, textCol);

                    // Cursor
                    if (el->state == UI_STATE_FOCUSED && fmod(el->cursorBlinkTimer, 1.0f) < 0.5f) {
                        Font font = UI_GetFontByHandle(el->fontHandle);
                        std::string beforeCursor = el->passwordMode ? std::string(el->cursorPos, '*') : el->text.substr(0, el->cursorPos);
                        Vector2 textSize = MeasureTextEx(font, beforeCursor.c_str(), el->fontSize, 1);
                        float cursorX = x + el->padding[0] + textSize.x;
                        DrawLine((int)cursorX, (int)(y + 4), (int)cursorX, (int)(y + h - 4), el->textColor);
                    }
                    break;
                }

                case UI_PROGRESSBAR: {
                    UI_DrawRoundedRect(x, y, w, h, el->cornerRadius, el->bgColor);
                    float ratio = (el->value - el->minValue) / (el->maxValue - el->minValue);
                    if (ratio > 0) {
                        UI_DrawRoundedRect(x, y, w * ratio, h, el->cornerRadius, el->hoverColor);
                    }
                    if (el->borderWidth > 0) {
                        DrawRectangleLinesEx({x, y, w, h}, el->borderWidth, el->borderColor);
                    }
                    break;
                }

                case UI_IMAGE: {
                    auto texIt = g_texByHandle.find(el->textureHandle);
                    if (texIt != g_texByHandle.end() && texIt->second.valid) {
                        Rectangle src = el->sourceRect;
                        if (src.width <= 0) src = {0, 0, (float)texIt->second.tex.width, (float)texIt->second.tex.height};
                        Rectangle dest = {x, y, w, h};
                        DrawTexturePro(texIt->second.tex, src, dest, {0, 0}, 0, el->tint);
                    }
                    break;
                }
            }
        }
    }

    int Framework_UI_GetHovered() { return g_uiHoveredId; }
    int Framework_UI_GetFocused() { return g_uiFocusedId; }

    void Framework_UI_SetFocus(int elementId) {
        if (g_uiFocusedId >= 0) {
            auto it = g_uiElements.find(g_uiFocusedId);
            if (it != g_uiElements.end()) it->second.state = UI_STATE_NORMAL;
        }
        g_uiFocusedId = elementId;
        if (elementId >= 0) {
            auto it = g_uiElements.find(elementId);
            if (it != g_uiElements.end()) it->second.state = UI_STATE_FOCUSED;
        }
    }

    bool Framework_UI_HasFocus() { return g_uiFocusedId >= 0; }

    // Layout helpers
    void Framework_UI_LayoutVertical(int parentId, float spacing, float paddingX, float paddingY) {
        std::vector<UIElement*> children;
        for (auto& kv : g_uiElements) {
            if (kv.second.parent == parentId && kv.second.valid) {
                children.push_back(&kv.second);
            }
        }

        float currentY = paddingY;
        for (auto* child : children) {
            child->x = paddingX;
            child->y = currentY;
            currentY += child->height + spacing;
        }
    }

    void Framework_UI_LayoutHorizontal(int parentId, float spacing, float paddingX, float paddingY) {
        std::vector<UIElement*> children;
        for (auto& kv : g_uiElements) {
            if (kv.second.parent == parentId && kv.second.valid) {
                children.push_back(&kv.second);
            }
        }

        float currentX = paddingX;
        for (auto* child : children) {
            child->x = currentX;
            child->y = paddingY;
            currentX += child->width + spacing;
        }
    }

    // ========================================================================
    // PHYSICS SYSTEM - 2D Rigid Body Physics Implementation
    // ========================================================================

    // Physics body structure
    struct PhysicsBody {
        int handle = -1;
        int type = BODY_DYNAMIC;
        bool valid = true;

        // Transform
        float x = 0, y = 0;
        float rotation = 0;  // radians

        // Dynamics
        float vx = 0, vy = 0;
        float angularVelocity = 0;
        float forceX = 0, forceY = 0;
        float torque = 0;

        // Properties
        float mass = 1.0f;
        float invMass = 1.0f;  // 1/mass, 0 for static
        float inertia = 1.0f;
        float invInertia = 1.0f;
        float restitution = 0.2f;  // Bounciness
        float friction = 0.3f;
        float gravityScale = 1.0f;
        float linearDamping = 0.0f;
        float angularDamping = 0.0f;
        bool fixedRotation = false;
        bool sleepingAllowed = true;
        bool awake = true;

        // Shape
        int shapeType = SHAPE_BOX;
        float shapeRadius = 16.0f;  // For circle
        float shapeWidth = 32.0f;   // For box
        float shapeHeight = 32.0f;
        float shapeOffsetX = 0, shapeOffsetY = 0;
        std::vector<float> polygonVerts;  // x,y pairs for polygon

        // Collision filtering
        unsigned int layer = 1;
        unsigned int mask = 0xFFFFFFFF;
        bool isTrigger = false;

        // Entity binding
        int boundEntity = -1;
        int userData = 0;
    };

    // Physics world state
    static std::unordered_map<int, PhysicsBody> g_physicsBodies;

    // Forward declaration for joint constraints (defined in Physics Joints section)
    static void ApplyJointConstraints(float dt);
    static int g_physicsNextHandle = 1;
    static float g_gravityX = 0.0f;
    static float g_gravityY = 980.0f;  // Default gravity (pixels/s^2)
    static int g_velocityIterations = 8;
    static int g_positionIterations = 3;
    static bool g_physicsEnabled = true;
    static bool g_physicsDebugDraw = false;

    // Collision callbacks
    static PhysicsCollisionCallback g_onCollisionEnter = nullptr;
    static PhysicsCollisionCallback g_onCollisionStay = nullptr;
    static PhysicsCollisionCallback g_onCollisionExit = nullptr;
    static PhysicsCollisionCallback g_onTriggerEnter = nullptr;
    static PhysicsCollisionCallback g_onTriggerExit = nullptr;

    // Collision tracking for enter/stay/exit detection
    struct CollisionPair {
        int bodyA, bodyB;
        bool operator==(const CollisionPair& o) const { return (bodyA == o.bodyA && bodyB == o.bodyB) || (bodyA == o.bodyB && bodyB == o.bodyA); }
    };
    struct CollisionPairHash {
        size_t operator()(const CollisionPair& p) const {
            int a = p.bodyA < p.bodyB ? p.bodyA : p.bodyB;
            int b = p.bodyA < p.bodyB ? p.bodyB : p.bodyA;
            return std::hash<long long>()(((long long)a << 32) | b);
        }
    };
    static std::unordered_set<CollisionPair, CollisionPairHash> g_activeCollisions;
    static std::unordered_set<CollisionPair, CollisionPairHash> g_prevCollisions;

    // Entity-to-body mapping
    static std::unordered_map<int, int> g_entityToBody;

    // Physics helper functions
    namespace {
        float Physics_Dot(float ax, float ay, float bx, float by) {
            return ax * bx + ay * by;
        }

        float Physics_Cross(float ax, float ay, float bx, float by) {
            return ax * by - ay * bx;
        }

        float Physics_Length(float x, float y) {
            return sqrtf(x * x + y * y);
        }

        void Physics_Normalize(float& x, float& y) {
            float len = Physics_Length(x, y);
            if (len > 0.0001f) { x /= len; y /= len; }
        }

        // Get AABB bounds for a body
        void Physics_GetAABB(const PhysicsBody& body, float& minX, float& minY, float& maxX, float& maxY) {
            if (body.shapeType == SHAPE_CIRCLE) {
                minX = body.x + body.shapeOffsetX - body.shapeRadius;
                minY = body.y + body.shapeOffsetY - body.shapeRadius;
                maxX = body.x + body.shapeOffsetX + body.shapeRadius;
                maxY = body.y + body.shapeOffsetY + body.shapeRadius;
            } else {  // BOX or POLYGON (use box bounds)
                float hw = body.shapeWidth / 2;
                float hh = body.shapeHeight / 2;
                minX = body.x + body.shapeOffsetX - hw;
                minY = body.y + body.shapeOffsetY - hh;
                maxX = body.x + body.shapeOffsetX + hw;
                maxY = body.y + body.shapeOffsetY + hh;
            }
        }

        // Circle vs Circle collision
        bool Physics_CircleVsCircle(const PhysicsBody& a, const PhysicsBody& b,
            float& normalX, float& normalY, float& depth) {
            float ax = a.x + a.shapeOffsetX;
            float ay = a.y + a.shapeOffsetY;
            float bx = b.x + b.shapeOffsetX;
            float by = b.y + b.shapeOffsetY;

            float dx = bx - ax;
            float dy = by - ay;
            float dist = Physics_Length(dx, dy);
            float sumRadii = a.shapeRadius + b.shapeRadius;

            if (dist >= sumRadii) return false;

            if (dist > 0.0001f) {
                normalX = dx / dist;
                normalY = dy / dist;
            } else {
                normalX = 1; normalY = 0;
            }
            depth = sumRadii - dist;
            return true;
        }

        // Box vs Box collision (AABB)
        bool Physics_BoxVsBox(const PhysicsBody& a, const PhysicsBody& b,
            float& normalX, float& normalY, float& depth) {
            float aMinX, aMinY, aMaxX, aMaxY;
            float bMinX, bMinY, bMaxX, bMaxY;
            Physics_GetAABB(a, aMinX, aMinY, aMaxX, aMaxY);
            Physics_GetAABB(b, bMinX, bMinY, bMaxX, bMaxY);

            float overlapX = fminf(aMaxX, bMaxX) - fmaxf(aMinX, bMinX);
            float overlapY = fminf(aMaxY, bMaxY) - fmaxf(aMinY, bMinY);

            if (overlapX <= 0 || overlapY <= 0) return false;

            if (overlapX < overlapY) {
                normalX = (a.x < b.x) ? -1.0f : 1.0f;
                normalY = 0;
                depth = overlapX;
            } else {
                normalX = 0;
                normalY = (a.y < b.y) ? -1.0f : 1.0f;
                depth = overlapY;
            }
            return true;
        }

        // Circle vs Box collision
        bool Physics_CircleVsBox(const PhysicsBody& circle, const PhysicsBody& box,
            float& normalX, float& normalY, float& depth) {
            float cx = circle.x + circle.shapeOffsetX;
            float cy = circle.y + circle.shapeOffsetY;

            float bMinX, bMinY, bMaxX, bMaxY;
            Physics_GetAABB(box, bMinX, bMinY, bMaxX, bMaxY);

            // Find closest point on box to circle center
            float closestX = fmaxf(bMinX, fminf(cx, bMaxX));
            float closestY = fmaxf(bMinY, fminf(cy, bMaxY));

            float dx = cx - closestX;
            float dy = cy - closestY;
            float dist = Physics_Length(dx, dy);

            if (dist >= circle.shapeRadius) return false;

            if (dist > 0.0001f) {
                normalX = dx / dist;
                normalY = dy / dist;
            } else {
                // Circle center is inside box
                float toLeft = cx - bMinX;
                float toRight = bMaxX - cx;
                float toTop = cy - bMinY;
                float toBottom = bMaxY - cy;
                float minDist = fminf(fminf(toLeft, toRight), fminf(toTop, toBottom));
                if (minDist == toLeft) { normalX = -1; normalY = 0; }
                else if (minDist == toRight) { normalX = 1; normalY = 0; }
                else if (minDist == toTop) { normalX = 0; normalY = -1; }
                else { normalX = 0; normalY = 1; }
            }
            depth = circle.shapeRadius - dist;
            return true;
        }

        // Test collision between two bodies
        bool Physics_TestCollision(const PhysicsBody& a, const PhysicsBody& b,
            float& normalX, float& normalY, float& depth) {
            // Check layer masks
            if (!(a.layer & b.mask) || !(b.layer & a.mask)) return false;

            if (a.shapeType == SHAPE_CIRCLE && b.shapeType == SHAPE_CIRCLE) {
                return Physics_CircleVsCircle(a, b, normalX, normalY, depth);
            } else if (a.shapeType == SHAPE_BOX && b.shapeType == SHAPE_BOX) {
                return Physics_BoxVsBox(a, b, normalX, normalY, depth);
            } else if (a.shapeType == SHAPE_CIRCLE && b.shapeType == SHAPE_BOX) {
                return Physics_CircleVsBox(a, b, normalX, normalY, depth);
            } else if (a.shapeType == SHAPE_BOX && b.shapeType == SHAPE_CIRCLE) {
                bool result = Physics_CircleVsBox(b, a, normalX, normalY, depth);
                normalX = -normalX; normalY = -normalY;
                return result;
            }
            // Polygon collision would go here - using AABB approximation
            return Physics_BoxVsBox(a, b, normalX, normalY, depth);
        }

        // Resolve collision between two bodies
        void Physics_ResolveCollision(PhysicsBody& a, PhysicsBody& b,
            float normalX, float normalY, float depth) {
            // Skip triggers
            if (a.isTrigger || b.isTrigger) return;

            // Calculate inverse masses
            float invMassA = (a.type == BODY_STATIC) ? 0 : a.invMass;
            float invMassB = (b.type == BODY_STATIC) ? 0 : b.invMass;
            float totalInvMass = invMassA + invMassB;

            if (totalInvMass == 0) return;  // Both static

            // Separate bodies (positional correction)
            float correctionPercent = 0.8f;
            float slop = 0.01f;  // Small penetration allowed
            float correction = fmaxf(depth - slop, 0.0f) / totalInvMass * correctionPercent;

            if (a.type != BODY_STATIC) {
                a.x -= normalX * correction * invMassA;
                a.y -= normalY * correction * invMassA;
            }
            if (b.type != BODY_STATIC) {
                b.x += normalX * correction * invMassB;
                b.y += normalY * correction * invMassB;
            }

            // Calculate relative velocity
            float relVelX = b.vx - a.vx;
            float relVelY = b.vy - a.vy;
            float relVelNormal = Physics_Dot(relVelX, relVelY, normalX, normalY);

            // Don't resolve if velocities are separating
            if (relVelNormal > 0) return;

            // Calculate restitution (bounce)
            float e = fminf(a.restitution, b.restitution);

            // Calculate impulse scalar
            float j = -(1 + e) * relVelNormal / totalInvMass;

            // Apply impulse
            if (a.type != BODY_STATIC) {
                a.vx -= j * invMassA * normalX;
                a.vy -= j * invMassA * normalY;
            }
            if (b.type != BODY_STATIC) {
                b.vx += j * invMassB * normalX;
                b.vy += j * invMassB * normalY;
            }

            // Friction impulse
            float tangentX = relVelX - relVelNormal * normalX;
            float tangentY = relVelY - relVelNormal * normalY;
            float tangentLen = Physics_Length(tangentX, tangentY);

            if (tangentLen > 0.0001f) {
                tangentX /= tangentLen;
                tangentY /= tangentLen;

                float jt = -Physics_Dot(relVelX, relVelY, tangentX, tangentY) / totalInvMass;
                float mu = sqrtf(a.friction * b.friction);  // Friction coefficient

                // Clamp friction impulse
                float maxFriction = fabsf(j) * mu;
                jt = fmaxf(-maxFriction, fminf(maxFriction, jt));

                if (a.type != BODY_STATIC) {
                    a.vx -= jt * invMassA * tangentX;
                    a.vy -= jt * invMassA * tangentY;
                }
                if (b.type != BODY_STATIC) {
                    b.vx += jt * invMassB * tangentX;
                    b.vy += jt * invMassB * tangentY;
                }
            }
        }
    }

    // World settings
    void Framework_Physics_SetGravity(float gx, float gy) {
        g_gravityX = gx;
        g_gravityY = gy;
    }

    void Framework_Physics_GetGravity(float* gx, float* gy) {
        if (gx) *gx = g_gravityX;
        if (gy) *gy = g_gravityY;
    }

    void Framework_Physics_SetIterations(int velocityIterations, int positionIterations) {
        g_velocityIterations = velocityIterations > 0 ? velocityIterations : 1;
        g_positionIterations = positionIterations > 0 ? positionIterations : 1;
    }

    void Framework_Physics_SetEnabled(bool enabled) { g_physicsEnabled = enabled; }
    bool Framework_Physics_IsEnabled() { return g_physicsEnabled; }

    // Body creation/destruction
    constexpr int MAX_PHYSICS_BODIES = 10000;  // Prevent excessive body creation

    int Framework_Physics_CreateBody(int bodyType, float x, float y) {
        // Prevent excessive physics body creation
        if ((int)g_physicsBodies.size() >= MAX_PHYSICS_BODIES) {
            return -1;  // Return invalid handle
        }
        // Validate body type
        if (bodyType < BODY_STATIC || bodyType > BODY_KINEMATIC) {
            return -1;
        }
        PhysicsBody body;
        body.handle = g_physicsNextHandle++;
        body.type = bodyType;
        body.x = x;
        body.y = y;

        if (bodyType == BODY_STATIC) {
            body.invMass = 0;
            body.invInertia = 0;
        }

        g_physicsBodies[body.handle] = body;
        return body.handle;
    }

    void Framework_Physics_DestroyBody(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) {
            if (it->second.boundEntity >= 0) {
                g_entityToBody.erase(it->second.boundEntity);
            }
            g_physicsBodies.erase(it);
        }
    }

    bool Framework_Physics_IsBodyValid(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return it != g_physicsBodies.end() && it->second.valid;
    }

    void Framework_Physics_DestroyAllBodies() {
        g_physicsBodies.clear();
        g_entityToBody.clear();
        g_activeCollisions.clear();
        g_prevCollisions.clear();
    }

    // Body type
    void Framework_Physics_SetBodyType(int bodyHandle, int bodyType) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it == g_physicsBodies.end()) return;
        it->second.type = bodyType;
        if (bodyType == BODY_STATIC) {
            it->second.invMass = 0;
            it->second.invInertia = 0;
            it->second.vx = it->second.vy = 0;
        } else {
            it->second.invMass = 1.0f / it->second.mass;
            it->second.invInertia = 1.0f / it->second.inertia;
        }
    }

    int Framework_Physics_GetBodyType(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return (it != g_physicsBodies.end()) ? it->second.type : BODY_STATIC;
    }

    // Body transform
    void Framework_Physics_SetBodyPosition(int bodyHandle, float x, float y) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.x = x; it->second.y = y; }
    }

    void Framework_Physics_GetBodyPosition(int bodyHandle, float* x, float* y) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) {
            if (x) *x = it->second.x;
            if (y) *y = it->second.y;
        }
    }

    void Framework_Physics_SetBodyRotation(int bodyHandle, float radians) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.rotation = radians; }
    }

    float Framework_Physics_GetBodyRotation(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return (it != g_physicsBodies.end()) ? it->second.rotation : 0;
    }

    // Body dynamics
    void Framework_Physics_SetBodyVelocity(int bodyHandle, float vx, float vy) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.vx = vx; it->second.vy = vy; }
    }

    void Framework_Physics_GetBodyVelocity(int bodyHandle, float* vx, float* vy) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) {
            if (vx) *vx = it->second.vx;
            if (vy) *vy = it->second.vy;
        }
    }

    void Framework_Physics_SetBodyAngularVelocity(int bodyHandle, float omega) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.angularVelocity = omega; }
    }

    float Framework_Physics_GetBodyAngularVelocity(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return (it != g_physicsBodies.end()) ? it->second.angularVelocity : 0;
    }

    void Framework_Physics_ApplyForce(int bodyHandle, float fx, float fy) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end() && it->second.type != BODY_STATIC) {
            it->second.forceX += fx;
            it->second.forceY += fy;
            it->second.awake = true;
        }
    }

    void Framework_Physics_ApplyForceAtPoint(int bodyHandle, float fx, float fy, float px, float py) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it == g_physicsBodies.end() || it->second.type == BODY_STATIC) return;
        it->second.forceX += fx;
        it->second.forceY += fy;
        // Calculate torque from force at point
        float rx = px - it->second.x;
        float ry = py - it->second.y;
        it->second.torque += Physics_Cross(rx, ry, fx, fy);
        it->second.awake = true;
    }

    void Framework_Physics_ApplyImpulse(int bodyHandle, float ix, float iy) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end() && it->second.type != BODY_STATIC) {
            it->second.vx += ix * it->second.invMass;
            it->second.vy += iy * it->second.invMass;
            it->second.awake = true;
        }
    }

    void Framework_Physics_ApplyTorque(int bodyHandle, float torque) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end() && it->second.type != BODY_STATIC) {
            it->second.torque += torque;
            it->second.awake = true;
        }
    }

    // Body properties
    void Framework_Physics_SetBodyMass(int bodyHandle, float mass) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) {
            it->second.mass = mass > 0.0001f ? mass : 0.0001f;
            if (it->second.type != BODY_STATIC) {
                it->second.invMass = 1.0f / it->second.mass;
            }
        }
    }

    float Framework_Physics_GetBodyMass(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return (it != g_physicsBodies.end()) ? it->second.mass : 0;
    }

    void Framework_Physics_SetBodyRestitution(int bodyHandle, float restitution) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.restitution = fmaxf(0, fminf(1, restitution)); }
    }

    float Framework_Physics_GetBodyRestitution(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return (it != g_physicsBodies.end()) ? it->second.restitution : 0;
    }

    void Framework_Physics_SetBodyFriction(int bodyHandle, float friction) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.friction = fmaxf(0, fminf(1, friction)); }
    }

    float Framework_Physics_GetBodyFriction(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return (it != g_physicsBodies.end()) ? it->second.friction : 0;
    }

    void Framework_Physics_SetBodyGravityScale(int bodyHandle, float scale) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.gravityScale = scale; }
    }

    float Framework_Physics_GetBodyGravityScale(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return (it != g_physicsBodies.end()) ? it->second.gravityScale : 1.0f;
    }

    void Framework_Physics_SetBodyLinearDamping(int bodyHandle, float damping) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.linearDamping = fmaxf(0, damping); }
    }

    void Framework_Physics_SetBodyAngularDamping(int bodyHandle, float damping) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.angularDamping = fmaxf(0, damping); }
    }

    void Framework_Physics_SetBodyFixedRotation(int bodyHandle, bool fixed) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.fixedRotation = fixed; }
    }

    bool Framework_Physics_IsBodyFixedRotation(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return (it != g_physicsBodies.end()) ? it->second.fixedRotation : false;
    }

    void Framework_Physics_SetBodySleepingAllowed(int bodyHandle, bool allowed) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.sleepingAllowed = allowed; }
    }

    void Framework_Physics_WakeBody(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.awake = true; }
    }

    bool Framework_Physics_IsBodyAwake(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return (it != g_physicsBodies.end()) ? it->second.awake : false;
    }

    // Collision shapes
    void Framework_Physics_SetBodyCircle(int bodyHandle, float radius) {
        Framework_Physics_SetBodyCircleOffset(bodyHandle, radius, 0, 0);
    }

    void Framework_Physics_SetBodyCircleOffset(int bodyHandle, float radius, float offsetX, float offsetY) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it == g_physicsBodies.end()) return;
        it->second.shapeType = SHAPE_CIRCLE;
        it->second.shapeRadius = radius;
        it->second.shapeOffsetX = offsetX;
        it->second.shapeOffsetY = offsetY;
        // Update inertia for circle: I = 0.5 * m * r^2
        it->second.inertia = 0.5f * it->second.mass * radius * radius;
        if (it->second.type != BODY_STATIC) {
            it->second.invInertia = 1.0f / it->second.inertia;
        }
    }

    void Framework_Physics_SetBodyBox(int bodyHandle, float width, float height) {
        Framework_Physics_SetBodyBoxOffset(bodyHandle, width, height, 0, 0);
    }

    void Framework_Physics_SetBodyBoxOffset(int bodyHandle, float width, float height, float offsetX, float offsetY) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it == g_physicsBodies.end()) return;
        it->second.shapeType = SHAPE_BOX;
        it->second.shapeWidth = width;
        it->second.shapeHeight = height;
        it->second.shapeOffsetX = offsetX;
        it->second.shapeOffsetY = offsetY;
        // Update inertia for box: I = (1/12) * m * (w^2 + h^2)
        it->second.inertia = (1.0f / 12.0f) * it->second.mass * (width * width + height * height);
        if (it->second.type != BODY_STATIC) {
            it->second.invInertia = 1.0f / it->second.inertia;
        }
    }

    void Framework_Physics_SetBodyPolygon(int bodyHandle, const float* vertices, int vertexCount) {
        auto it = g_physicsBodies.find(bodyHandle);
        // Validate inputs: need at least 3 vertices, max 64 to prevent excessive memory
        constexpr int MAX_POLYGON_VERTS = 64;
        if (it == g_physicsBodies.end() || !vertices || vertexCount < 3 || vertexCount > MAX_POLYGON_VERTS) return;
        it->second.shapeType = SHAPE_POLYGON;
        it->second.polygonVerts.clear();
        it->second.polygonVerts.assign(vertices, vertices + vertexCount * 2);
        // Calculate bounding box for AABB approximation
        float minX = vertices[0], maxX = vertices[0];
        float minY = vertices[1], maxY = vertices[1];
        for (int i = 1; i < vertexCount; i++) {
            minX = fminf(minX, vertices[i * 2]);
            maxX = fmaxf(maxX, vertices[i * 2]);
            minY = fminf(minY, vertices[i * 2 + 1]);
            maxY = fmaxf(maxY, vertices[i * 2 + 1]);
        }
        it->second.shapeWidth = maxX - minX;
        it->second.shapeHeight = maxY - minY;
    }

    int Framework_Physics_GetBodyShapeType(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return (it != g_physicsBodies.end()) ? it->second.shapeType : SHAPE_BOX;
    }

    // Collision filtering
    void Framework_Physics_SetBodyLayer(int bodyHandle, unsigned int layer) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.layer = layer; }
    }

    void Framework_Physics_SetBodyMask(int bodyHandle, unsigned int mask) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.mask = mask; }
    }

    void Framework_Physics_SetBodyTrigger(int bodyHandle, bool isTrigger) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.isTrigger = isTrigger; }
    }

    bool Framework_Physics_IsBodyTrigger(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return (it != g_physicsBodies.end()) ? it->second.isTrigger : false;
    }

    // Entity binding
    void Framework_Physics_BindToEntity(int bodyHandle, int entityId) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it == g_physicsBodies.end()) return;
        // Validate entity exists before binding (unless unbinding with -1)
        if (entityId >= 0 && !EcsIsAlive(entityId)) return;
        // Unbind previous entity if any
        if (it->second.boundEntity >= 0) {
            g_entityToBody.erase(it->second.boundEntity);
        }
        it->second.boundEntity = entityId;
        if (entityId >= 0) {
            g_entityToBody[entityId] = bodyHandle;
        }
    }

    int Framework_Physics_GetBoundEntity(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return (it != g_physicsBodies.end()) ? it->second.boundEntity : -1;
    }

    int Framework_Physics_GetEntityBody(int entityId) {
        auto it = g_entityToBody.find(entityId);
        return (it != g_entityToBody.end()) ? it->second : -1;
    }

    // User data
    void Framework_Physics_SetBodyUserData(int bodyHandle, int userData) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it != g_physicsBodies.end()) { it->second.userData = userData; }
    }

    int Framework_Physics_GetBodyUserData(int bodyHandle) {
        auto it = g_physicsBodies.find(bodyHandle);
        return (it != g_physicsBodies.end()) ? it->second.userData : 0;
    }

    // Collision callbacks
    void Framework_Physics_SetCollisionEnterCallback(PhysicsCollisionCallback callback) { g_onCollisionEnter = callback; }
    void Framework_Physics_SetCollisionStayCallback(PhysicsCollisionCallback callback) { g_onCollisionStay = callback; }
    void Framework_Physics_SetCollisionExitCallback(PhysicsCollisionCallback callback) { g_onCollisionExit = callback; }
    void Framework_Physics_SetTriggerEnterCallback(PhysicsCollisionCallback callback) { g_onTriggerEnter = callback; }
    void Framework_Physics_SetTriggerExitCallback(PhysicsCollisionCallback callback) { g_onTriggerExit = callback; }

    // Physics queries
    int Framework_Physics_RaycastFirst(float startX, float startY, float dirX, float dirY, float maxDist,
        float* hitX, float* hitY, float* hitNormalX, float* hitNormalY) {
        Physics_Normalize(dirX, dirY);
        float closestT = maxDist;
        int closestBody = -1;
        float closestNX = 0, closestNY = 0;

        for (auto& kv : g_physicsBodies) {
            const PhysicsBody& body = kv.second;
            if (!body.valid) continue;

            // Simple ray-AABB intersection for now
            float minX, minY, maxX, maxY;
            Physics_GetAABB(body, minX, minY, maxX, maxY);

            float tmin = 0, tmax = maxDist;
            float nx = 0, ny = 0;

            // X slab
            if (fabsf(dirX) > 0.0001f) {
                float t1 = (minX - startX) / dirX;
                float t2 = (maxX - startX) / dirX;
                if (t1 > t2) { float tmp = t1; t1 = t2; t2 = tmp; }
                if (t1 > tmin) { tmin = t1; nx = -dirX / fabsf(dirX); ny = 0; }
                if (t2 < tmax) tmax = t2;
            } else if (startX < minX || startX > maxX) continue;

            // Y slab
            if (fabsf(dirY) > 0.0001f) {
                float t1 = (minY - startY) / dirY;
                float t2 = (maxY - startY) / dirY;
                if (t1 > t2) { float tmp = t1; t1 = t2; t2 = tmp; }
                if (t1 > tmin) { tmin = t1; nx = 0; ny = -dirY / fabsf(dirY); }
                if (t2 < tmax) tmax = t2;
            } else if (startY < minY || startY > maxY) continue;

            if (tmin <= tmax && tmin > 0 && tmin < closestT) {
                closestT = tmin;
                closestBody = kv.first;
                closestNX = nx;
                closestNY = ny;
            }
        }

        if (closestBody >= 0) {
            if (hitX) *hitX = startX + dirX * closestT;
            if (hitY) *hitY = startY + dirY * closestT;
            if (hitNormalX) *hitNormalX = closestNX;
            if (hitNormalY) *hitNormalY = closestNY;
        }
        return closestBody;
    }

    int Framework_Physics_RaycastAll(float startX, float startY, float dirX, float dirY, float maxDist,
        int* bodyBuffer, int bufferSize) {
        if (!bodyBuffer || bufferSize <= 0) return 0;
        Physics_Normalize(dirX, dirY);
        int count = 0;

        for (auto& kv : g_physicsBodies) {
            if (count >= bufferSize) break;
            const PhysicsBody& body = kv.second;
            if (!body.valid) continue;

            float minX, minY, maxX, maxY;
            Physics_GetAABB(body, minX, minY, maxX, maxY);

            // Ray-AABB test
            float tmin = 0, tmax = maxDist;
            if (fabsf(dirX) > 0.0001f) {
                float t1 = (minX - startX) / dirX;
                float t2 = (maxX - startX) / dirX;
                if (t1 > t2) { float tmp = t1; t1 = t2; t2 = tmp; }
                tmin = fmaxf(tmin, t1);
                tmax = fminf(tmax, t2);
            } else if (startX < minX || startX > maxX) continue;

            if (fabsf(dirY) > 0.0001f) {
                float t1 = (minY - startY) / dirY;
                float t2 = (maxY - startY) / dirY;
                if (t1 > t2) { float tmp = t1; t1 = t2; t2 = tmp; }
                tmin = fmaxf(tmin, t1);
                tmax = fminf(tmax, t2);
            } else if (startY < minY || startY > maxY) continue;

            if (tmin <= tmax && tmin > 0) {
                bodyBuffer[count++] = kv.first;
            }
        }
        return count;
    }

    int Framework_Physics_QueryCircle(float x, float y, float radius, int* bodyBuffer, int bufferSize) {
        if (!bodyBuffer || bufferSize <= 0) return 0;
        int count = 0;

        for (auto& kv : g_physicsBodies) {
            if (count >= bufferSize) break;
            const PhysicsBody& body = kv.second;
            if (!body.valid) continue;

            float minX, minY, maxX, maxY;
            Physics_GetAABB(body, minX, minY, maxX, maxY);

            // Expand AABB by radius and check point
            if (x >= minX - radius && x <= maxX + radius && y >= minY - radius && y <= maxY + radius) {
                bodyBuffer[count++] = kv.first;
            }
        }
        return count;
    }

    int Framework_Physics_QueryBox(float x, float y, float width, float height, int* bodyBuffer, int bufferSize) {
        if (!bodyBuffer || bufferSize <= 0) return 0;
        int count = 0;

        float qMinX = x - width / 2, qMinY = y - height / 2;
        float qMaxX = x + width / 2, qMaxY = y + height / 2;

        for (auto& kv : g_physicsBodies) {
            if (count >= bufferSize) break;
            const PhysicsBody& body = kv.second;
            if (!body.valid) continue;

            float minX, minY, maxX, maxY;
            Physics_GetAABB(body, minX, minY, maxX, maxY);

            if (qMaxX >= minX && qMinX <= maxX && qMaxY >= minY && qMinY <= maxY) {
                bodyBuffer[count++] = kv.first;
            }
        }
        return count;
    }

    bool Framework_Physics_TestOverlap(int bodyA, int bodyB) {
        auto itA = g_physicsBodies.find(bodyA);
        auto itB = g_physicsBodies.find(bodyB);
        if (itA == g_physicsBodies.end() || itB == g_physicsBodies.end()) return false;

        float nx, ny, depth;
        return Physics_TestCollision(itA->second, itB->second, nx, ny, depth);
    }

    // Simulation
    void Framework_Physics_Step(float dt) {
        if (!g_physicsEnabled || dt <= 0) return;

        // Use substeps for more stable simulation
        const float fixedStep = 1.0f / 120.0f;  // 120 Hz physics
        static float accumulator = 0.0f;
        accumulator += dt;

        // Limit accumulator to prevent spiral of death
        if (accumulator > 0.1f) accumulator = 0.1f;

        while (accumulator >= fixedStep) {
            accumulator -= fixedStep;

            // Integrate forces for dynamic bodies
            for (auto& kv : g_physicsBodies) {
                PhysicsBody& body = kv.second;
                if (!body.valid || body.type == BODY_STATIC || !body.awake) continue;

                if (body.type == BODY_DYNAMIC) {
                    // Apply gravity
                    body.vx += g_gravityX * body.gravityScale * fixedStep;
                    body.vy += g_gravityY * body.gravityScale * fixedStep;

                    // Apply accumulated forces
                    body.vx += body.forceX * body.invMass * fixedStep;
                    body.vy += body.forceY * body.invMass * fixedStep;
                    body.forceX = body.forceY = 0;

                    // Apply torque
                    if (!body.fixedRotation) {
                        body.angularVelocity += body.torque * body.invInertia * fixedStep;
                        body.torque = 0;
                    }

                    // Apply damping
                    body.vx *= 1.0f / (1.0f + body.linearDamping * fixedStep);
                    body.vy *= 1.0f / (1.0f + body.linearDamping * fixedStep);
                    body.angularVelocity *= 1.0f / (1.0f + body.angularDamping * fixedStep);
                }

                // Integrate velocity
                body.x += body.vx * fixedStep;
                body.y += body.vy * fixedStep;
                if (!body.fixedRotation) {
                    body.rotation += body.angularVelocity * fixedStep;
                }
            }

            // Apply joint constraints
            ApplyJointConstraints(fixedStep);

            // Collect active bodies
            std::vector<int> bodies;
            for (auto& kv : g_physicsBodies) {
                if (kv.second.valid) bodies.push_back(kv.first);
            }

            // Detect and resolve collisions
            g_activeCollisions.clear();

            for (int iter = 0; iter < g_positionIterations; iter++) {
                for (size_t i = 0; i < bodies.size(); i++) {
                    for (size_t j = i + 1; j < bodies.size(); j++) {
                        int hA = bodies[i], hB = bodies[j];
                        PhysicsBody& a = g_physicsBodies[hA];
                        PhysicsBody& b = g_physicsBodies[hB];

                        // Skip if both are static
                        if (a.type == BODY_STATIC && b.type == BODY_STATIC) continue;

                        float normalX, normalY, depth;
                        if (Physics_TestCollision(a, b, normalX, normalY, depth)) {
                            CollisionPair pair = {hA, hB};
                            g_activeCollisions.insert(pair);

                            // Fire callbacks on first detection (iter == 0)
                            if (iter == 0) {
                                bool wasColliding = g_prevCollisions.count(pair) > 0;

                                if (a.isTrigger || b.isTrigger) {
                                    if (!wasColliding && g_onTriggerEnter) {
                                        g_onTriggerEnter(hA, hB, normalX, normalY, depth);
                                    }
                                } else {
                                    if (!wasColliding && g_onCollisionEnter) {
                                        g_onCollisionEnter(hA, hB, normalX, normalY, depth);
                                    } else if (wasColliding && g_onCollisionStay) {
                                        g_onCollisionStay(hA, hB, normalX, normalY, depth);
                                    }
                                }
                            }

                            // Resolve collision
                            Physics_ResolveCollision(a, b, normalX, normalY, depth);
                        }
                    }
                }
            }

            // Fire exit callbacks
            for (const auto& pair : g_prevCollisions) {
                if (g_activeCollisions.count(pair) == 0) {
                    auto itA = g_physicsBodies.find(pair.bodyA);
                    auto itB = g_physicsBodies.find(pair.bodyB);
                    if (itA != g_physicsBodies.end() && itB != g_physicsBodies.end()) {
                        if (itA->second.isTrigger || itB->second.isTrigger) {
                            if (g_onTriggerExit) g_onTriggerExit(pair.bodyA, pair.bodyB, 0, 0, 0);
                        } else {
                            if (g_onCollisionExit) g_onCollisionExit(pair.bodyA, pair.bodyB, 0, 0, 0);
                        }
                    }
                }
            }

            g_prevCollisions = g_activeCollisions;
        }  // End while (accumulator >= fixedStep)
    }

    void Framework_Physics_SyncToEntities() {
        for (auto& kv : g_physicsBodies) {
            PhysicsBody& body = kv.second;
            if (!body.valid || body.boundEntity < 0) continue;

            // Update entity transform from physics body
            auto trIt = g_transform2D.find(body.boundEntity);
            if (trIt != g_transform2D.end()) {
                trIt->second.position.x = body.x;
                trIt->second.position.y = body.y;
                trIt->second.rotation = body.rotation * RAD2DEG;
            }
        }
    }

    // Debug rendering
    void Framework_Physics_SetDebugDraw(bool enabled) { g_physicsDebugDraw = enabled; }
    bool Framework_Physics_IsDebugDrawEnabled() { return g_physicsDebugDraw; }

    void Framework_Physics_DrawDebug() {
        if (!g_physicsDebugDraw) return;

        for (auto& kv : g_physicsBodies) {
            const PhysicsBody& body = kv.second;
            if (!body.valid) continue;

            Color color;
            switch (body.type) {
                case BODY_STATIC: color = { 100, 100, 100, 200 }; break;
                case BODY_DYNAMIC: color = { 0, 200, 0, 200 }; break;
                case BODY_KINEMATIC: color = { 200, 200, 0, 200 }; break;
                default: color = WHITE; break;
            }

            if (body.isTrigger) {
                color = { 0, 150, 255, 100 };
            }

            if (body.shapeType == SHAPE_CIRCLE) {
                DrawCircleLines(
                    (int)(body.x + body.shapeOffsetX),
                    (int)(body.y + body.shapeOffsetY),
                    body.shapeRadius, color);
            } else {
                float hw = body.shapeWidth / 2;
                float hh = body.shapeHeight / 2;
                DrawRectangleLines(
                    (int)(body.x + body.shapeOffsetX - hw),
                    (int)(body.y + body.shapeOffsetY - hh),
                    (int)body.shapeWidth, (int)body.shapeHeight, color);
            }

            // Draw velocity vector
            if (body.type == BODY_DYNAMIC && (fabsf(body.vx) > 1 || fabsf(body.vy) > 1)) {
                DrawLine((int)body.x, (int)body.y,
                    (int)(body.x + body.vx * 0.1f), (int)(body.y + body.vy * 0.1f),
                    RED);
            }
        }
    }

    // ========================================================================
    // PHYSICS JOINTS - Constraints between bodies
    // ========================================================================

    // Joint data structure
    struct PhysicsJoint {
        int id;
        int type;  // PhysicsJointType
        int bodyA;
        int bodyB;
        float anchorAX, anchorAY;  // Local anchor on body A
        float anchorBX, anchorBY;  // Local anchor on body B

        // Revolute/Wheel properties
        float lowerAngle, upperAngle;
        bool enableLimits;
        float motorSpeed, maxMotorTorque;
        bool enableMotor;

        // Distance/Rope properties
        float length;
        float minLength, maxLength;
        float stiffness;
        float damping;

        // Prismatic properties
        float axisX, axisY;
        float lowerTranslation, upperTranslation;
        float motorForce;

        // Motor joint properties
        float targetX, targetY, targetAngle;
        float maxForce, maxTorque;
        float correctionFactor;

        // Pulley properties
        float groundAX, groundAY, groundBX, groundBY;
        float ratio;

        // General
        bool collideConnected;
        int userData;
        bool valid;

        // Runtime values
        float currentAngle;
        float currentSpeed;
        float currentTranslation;
        float reactionForceX, reactionForceY;
        float reactionTorque;
    };

    static std::unordered_map<int, PhysicsJoint> g_physicsJoints;
    static int g_nextJointHandle = 1;
    static const int MAX_JOINTS = 1000;

    // Helper to get body position
    static bool GetJointBodyPosition(int bodyHandle, float& x, float& y) {
        auto it = g_physicsBodies.find(bodyHandle);
        if (it == g_physicsBodies.end() || !it->second.valid) return false;
        x = it->second.x;
        y = it->second.y;
        return true;
    }

    // Apply joint constraints during physics step
    static void ApplyJointConstraints(float dt) {
        for (auto& kv : g_physicsJoints) {
            PhysicsJoint& joint = kv.second;
            if (!joint.valid) continue;

            auto itA = g_physicsBodies.find(joint.bodyA);
            auto itB = g_physicsBodies.find(joint.bodyB);
            if (itA == g_physicsBodies.end() || !itA->second.valid) continue;
            if (itB == g_physicsBodies.end() || !itB->second.valid) continue;

            PhysicsBody& bodyA = itA->second;
            PhysicsBody& bodyB = itB->second;

            // World anchor positions
            float worldAX = bodyA.x + joint.anchorAX;
            float worldAY = bodyA.y + joint.anchorAY;
            float worldBX = bodyB.x + joint.anchorBX;
            float worldBY = bodyB.y + joint.anchorBY;

            switch (joint.type) {
                case JOINT_TYPE_DISTANCE: {
                    // Calculate current distance
                    float dx = worldBX - worldAX;
                    float dy = worldBY - worldAY;
                    float dist = sqrtf(dx * dx + dy * dy);
                    if (dist < 0.001f) break;

                    // Normalize direction
                    float nx = dx / dist;
                    float ny = dy / dist;

                    // Error from target length
                    float error = dist - joint.length;

                    // Apply spring force if stiffness > 0
                    float force = error * joint.stiffness;

                    // Apply damping
                    float relVelX = bodyB.vx - bodyA.vx;
                    float relVelY = bodyB.vy - bodyA.vy;
                    float relVelN = relVelX * nx + relVelY * ny;
                    force += relVelN * joint.damping;

                    // Apply forces
                    float massSum = bodyA.mass + bodyB.mass;
                    if (massSum > 0) {
                        float ratioA = bodyB.mass / massSum;
                        float ratioB = bodyA.mass / massSum;

                        if (bodyA.type == BODY_DYNAMIC) {
                            bodyA.vx += force * nx * ratioA * dt;
                            bodyA.vy += force * ny * ratioA * dt;
                        }
                        if (bodyB.type == BODY_DYNAMIC) {
                            bodyB.vx -= force * nx * ratioB * dt;
                            bodyB.vy -= force * ny * ratioB * dt;
                        }
                    }

                    joint.reactionForceX = force * nx;
                    joint.reactionForceY = force * ny;
                    break;
                }

                case JOINT_TYPE_REVOLUTE: {
                    // Keep bodies attached at anchor point
                    float dx = worldBX - worldAX;
                    float dy = worldBY - worldAY;
                    float dist = sqrtf(dx * dx + dy * dy);

                    if (dist > 0.5f) {  // Tolerance
                        float nx = dx / dist;
                        float ny = dy / dist;
                        float correction = dist * 0.5f;

                        if (bodyA.type == BODY_DYNAMIC) {
                            bodyA.x += nx * correction;
                            bodyA.y += ny * correction;
                        }
                        if (bodyB.type == BODY_DYNAMIC) {
                            bodyB.x -= nx * correction;
                            bodyB.y -= ny * correction;
                        }
                    }

                    // Calculate angle between bodies
                    float angleA = bodyA.rotation;
                    float angleB = bodyB.rotation;
                    joint.currentAngle = angleB - angleA;

                    // Angular velocity
                    joint.currentSpeed = bodyB.angularVelocity - bodyA.angularVelocity;

                    // Apply limits
                    if (joint.enableLimits) {
                        if (joint.currentAngle < joint.lowerAngle) {
                            float correction = (joint.lowerAngle - joint.currentAngle) * 5.0f;
                            if (bodyA.type == BODY_DYNAMIC) bodyA.angularVelocity -= correction * dt;
                            if (bodyB.type == BODY_DYNAMIC) bodyB.angularVelocity += correction * dt;
                        } else if (joint.currentAngle > joint.upperAngle) {
                            float correction = (joint.currentAngle - joint.upperAngle) * 5.0f;
                            if (bodyA.type == BODY_DYNAMIC) bodyA.angularVelocity += correction * dt;
                            if (bodyB.type == BODY_DYNAMIC) bodyB.angularVelocity -= correction * dt;
                        }
                    }

                    // Apply motor
                    if (joint.enableMotor) {
                        float speedError = joint.motorSpeed - joint.currentSpeed;
                        float torque = speedError * joint.maxMotorTorque * dt;
                        if (fabsf(torque) > joint.maxMotorTorque * dt) {
                            torque = (torque > 0 ? 1 : -1) * joint.maxMotorTorque * dt;
                        }
                        if (bodyA.type == BODY_DYNAMIC) bodyA.angularVelocity -= torque / bodyA.mass;
                        if (bodyB.type == BODY_DYNAMIC) bodyB.angularVelocity += torque / bodyB.mass;
                        joint.reactionTorque = torque;
                    }
                    break;
                }

                case JOINT_TYPE_PRISMATIC: {
                    // Project positions onto axis
                    float dx = bodyB.x - bodyA.x;
                    float dy = bodyB.y - bodyA.y;
                    joint.currentTranslation = dx * joint.axisX + dy * joint.axisY;

                    // Velocity along axis
                    float relVelX = bodyB.vx - bodyA.vx;
                    float relVelY = bodyB.vy - bodyA.vy;
                    joint.currentSpeed = relVelX * joint.axisX + relVelY * joint.axisY;

                    // Constrain perpendicular movement
                    float perpX = -joint.axisY;
                    float perpY = joint.axisX;
                    float perpDist = dx * perpX + dy * perpY;

                    if (fabsf(perpDist) > 0.5f) {
                        float correction = perpDist * 0.5f;
                        if (bodyA.type == BODY_DYNAMIC) {
                            bodyA.x += perpX * correction;
                            bodyA.y += perpY * correction;
                        }
                        if (bodyB.type == BODY_DYNAMIC) {
                            bodyB.x -= perpX * correction;
                            bodyB.y -= perpY * correction;
                        }
                    }

                    // Apply limits
                    if (joint.enableLimits) {
                        if (joint.currentTranslation < joint.lowerTranslation) {
                            float error = joint.lowerTranslation - joint.currentTranslation;
                            if (bodyB.type == BODY_DYNAMIC) {
                                bodyB.vx += joint.axisX * error * 5.0f * dt;
                                bodyB.vy += joint.axisY * error * 5.0f * dt;
                            }
                        } else if (joint.currentTranslation > joint.upperTranslation) {
                            float error = joint.currentTranslation - joint.upperTranslation;
                            if (bodyB.type == BODY_DYNAMIC) {
                                bodyB.vx -= joint.axisX * error * 5.0f * dt;
                                bodyB.vy -= joint.axisY * error * 5.0f * dt;
                            }
                        }
                    }

                    // Apply motor
                    if (joint.enableMotor) {
                        float speedError = joint.motorSpeed - joint.currentSpeed;
                        float force = speedError * joint.motorForce * dt;
                        if (fabsf(force) > joint.motorForce * dt) {
                            force = (force > 0 ? 1 : -1) * joint.motorForce * dt;
                        }
                        if (bodyB.type == BODY_DYNAMIC) {
                            bodyB.vx += joint.axisX * force / bodyB.mass;
                            bodyB.vy += joint.axisY * force / bodyB.mass;
                        }
                    }
                    break;
                }

                case JOINT_TYPE_WELD: {
                    // Force bodies to same position and rotation
                    float dx = worldBX - worldAX;
                    float dy = worldBY - worldAY;

                    if (bodyB.type == BODY_DYNAMIC) {
                        bodyB.x -= dx * 0.9f;
                        bodyB.y -= dy * 0.9f;
                        bodyB.vx = bodyA.vx;
                        bodyB.vy = bodyA.vy;
                        bodyB.rotation = bodyA.rotation + joint.currentAngle;
                        bodyB.angularVelocity = bodyA.angularVelocity;
                    } else if (bodyA.type == BODY_DYNAMIC) {
                        bodyA.x += dx * 0.9f;
                        bodyA.y += dy * 0.9f;
                        bodyA.vx = bodyB.vx;
                        bodyA.vy = bodyB.vy;
                    }
                    break;
                }

                case JOINT_TYPE_ROPE: {
                    // Maximum distance constraint
                    float dx = worldBX - worldAX;
                    float dy = worldBY - worldAY;
                    float dist = sqrtf(dx * dx + dy * dy);

                    if (dist > joint.maxLength && dist > 0.001f) {
                        float nx = dx / dist;
                        float ny = dy / dist;
                        float excess = dist - joint.maxLength;

                        if (bodyA.type == BODY_DYNAMIC && bodyB.type == BODY_DYNAMIC) {
                            float half = excess * 0.5f;
                            bodyA.x += nx * half;
                            bodyA.y += ny * half;
                            bodyB.x -= nx * half;
                            bodyB.y -= ny * half;
                        } else if (bodyA.type == BODY_DYNAMIC) {
                            bodyA.x += nx * excess;
                            bodyA.y += ny * excess;
                        } else if (bodyB.type == BODY_DYNAMIC) {
                            bodyB.x -= nx * excess;
                            bodyB.y -= ny * excess;
                        }
                    }
                    break;
                }

                case JOINT_TYPE_MOTOR: {
                    // Move body B toward target relative to body A
                    float targetWorldX = bodyA.x + joint.targetX;
                    float targetWorldY = bodyA.y + joint.targetY;

                    float dx = targetWorldX - bodyB.x;
                    float dy = targetWorldY - bodyB.y;
                    float dist = sqrtf(dx * dx + dy * dy);

                    if (dist > 0.5f && bodyB.type == BODY_DYNAMIC) {
                        float force = fminf(dist * joint.correctionFactor, joint.maxForce) * dt;
                        bodyB.vx += (dx / dist) * force / bodyB.mass;
                        bodyB.vy += (dy / dist) * force / bodyB.mass;
                    }

                    // Rotate toward target angle
                    float angleError = joint.targetAngle - (bodyB.rotation - bodyA.rotation);
                    while (angleError > PI) angleError -= 2 * PI;
                    while (angleError < -PI) angleError += 2 * PI;

                    if (fabsf(angleError) > 0.01f && bodyB.type == BODY_DYNAMIC) {
                        float torque = angleError * joint.correctionFactor * joint.maxTorque * dt;
                        if (fabsf(torque) > joint.maxTorque * dt) {
                            torque = (torque > 0 ? 1 : -1) * joint.maxTorque * dt;
                        }
                        bodyB.angularVelocity += torque / bodyB.mass;
                    }
                    break;
                }

                case JOINT_TYPE_WHEEL: {
                    // Suspension along axis, free rotation
                    float dx = bodyB.x - (bodyA.x + joint.anchorAX);
                    float dy = bodyB.y - (bodyA.y + joint.anchorAY);

                    // Project onto axis
                    float axisProj = dx * joint.axisX + dy * joint.axisY;
                    float perpProj = dx * (-joint.axisY) + dy * joint.axisX;

                    // Spring force along axis
                    float springForce = -axisProj * joint.stiffness;
                    float relVel = (bodyB.vx - bodyA.vx) * joint.axisX + (bodyB.vy - bodyA.vy) * joint.axisY;
                    springForce -= relVel * joint.damping;

                    if (bodyB.type == BODY_DYNAMIC) {
                        bodyB.vx += joint.axisX * springForce * dt / bodyB.mass;
                        bodyB.vy += joint.axisY * springForce * dt / bodyB.mass;
                    }

                    // Constrain perpendicular
                    if (fabsf(perpProj) > 0.1f) {
                        if (bodyB.type == BODY_DYNAMIC) {
                            bodyB.x -= (-joint.axisY) * perpProj * 0.5f;
                            bodyB.y -= joint.axisX * perpProj * 0.5f;
                        }
                    }

                    // Apply motor to wheel rotation
                    if (joint.enableMotor && bodyB.type == BODY_DYNAMIC) {
                        float speedError = joint.motorSpeed - bodyB.angularVelocity;
                        float torque = speedError * joint.maxMotorTorque * dt;
                        if (fabsf(torque) > joint.maxMotorTorque * dt) {
                            torque = (torque > 0 ? 1 : -1) * joint.maxMotorTorque * dt;
                        }
                        bodyB.angularVelocity += torque / bodyB.mass;
                    }
                    break;
                }

                case JOINT_TYPE_PULLEY: {
                    // Calculate rope lengths
                    float dxA = worldAX - joint.groundAX;
                    float dyA = worldAY - joint.groundAY;
                    float dxB = worldBX - joint.groundBX;
                    float dyB = worldBY - joint.groundBY;

                    float lenA = sqrtf(dxA * dxA + dyA * dyA);
                    float lenB = sqrtf(dxB * dxB + dyB * dyB);

                    // Total rope length constraint
                    float totalLen = lenA + joint.ratio * lenB;
                    float targetLen = joint.length + joint.ratio * joint.maxLength;  // Using length and maxLength as initial lengths
                    float error = totalLen - targetLen;

                    if (fabsf(error) > 0.5f) {
                        // Pull bodies toward ground anchors
                        float correction = error * 0.3f;

                        if (lenA > 0.001f && bodyA.type == BODY_DYNAMIC) {
                            bodyA.vx -= (dxA / lenA) * correction * dt * 50;
                            bodyA.vy -= (dyA / lenA) * correction * dt * 50;
                        }
                        if (lenB > 0.001f && bodyB.type == BODY_DYNAMIC) {
                            bodyB.vx -= (dxB / lenB) * correction * joint.ratio * dt * 50;
                            bodyB.vy -= (dyB / lenB) * correction * joint.ratio * dt * 50;
                        }
                    }
                    break;
                }
            }
        }
    }

    // Joint creation functions
    int Framework_Joint_CreateRevolute(int bodyA, int bodyB, float anchorX, float anchorY) {
        if (g_physicsJoints.size() >= MAX_JOINTS) return -1;
        if (g_physicsBodies.find(bodyA) == g_physicsBodies.end()) return -1;
        if (g_physicsBodies.find(bodyB) == g_physicsBodies.end()) return -1;

        int handle = g_nextJointHandle++;
        PhysicsJoint& joint = g_physicsJoints[handle];
        joint.id = handle;
        joint.type = JOINT_TYPE_REVOLUTE;
        joint.bodyA = bodyA;
        joint.bodyB = bodyB;

        // Calculate local anchors
        PhysicsBody& bA = g_physicsBodies[bodyA];
        PhysicsBody& bB = g_physicsBodies[bodyB];
        joint.anchorAX = anchorX - bA.x;
        joint.anchorAY = anchorY - bA.y;
        joint.anchorBX = anchorX - bB.x;
        joint.anchorBY = anchorY - bB.y;

        joint.lowerAngle = -PI;
        joint.upperAngle = PI;
        joint.enableLimits = false;
        joint.motorSpeed = 0;
        joint.maxMotorTorque = 100;
        joint.enableMotor = false;
        joint.collideConnected = false;
        joint.userData = 0;
        joint.valid = true;

        return handle;
    }

    int Framework_Joint_CreateDistance(int bodyA, int bodyB, float anchorAX, float anchorAY, float anchorBX, float anchorBY) {
        if (g_physicsJoints.size() >= MAX_JOINTS) return -1;
        if (g_physicsBodies.find(bodyA) == g_physicsBodies.end()) return -1;
        if (g_physicsBodies.find(bodyB) == g_physicsBodies.end()) return -1;

        int handle = g_nextJointHandle++;
        PhysicsJoint& joint = g_physicsJoints[handle];
        joint.id = handle;
        joint.type = JOINT_TYPE_DISTANCE;
        joint.bodyA = bodyA;
        joint.bodyB = bodyB;

        PhysicsBody& bA = g_physicsBodies[bodyA];
        PhysicsBody& bB = g_physicsBodies[bodyB];
        joint.anchorAX = anchorAX - bA.x;
        joint.anchorAY = anchorAY - bA.y;
        joint.anchorBX = anchorBX - bB.x;
        joint.anchorBY = anchorBY - bB.y;

        // Calculate initial length
        float dx = anchorBX - anchorAX;
        float dy = anchorBY - anchorAY;
        joint.length = sqrtf(dx * dx + dy * dy);
        joint.minLength = 0;
        joint.maxLength = joint.length * 2;
        joint.stiffness = 100.0f;
        joint.damping = 10.0f;
        joint.collideConnected = false;
        joint.userData = 0;
        joint.valid = true;

        return handle;
    }

    int Framework_Joint_CreatePrismatic(int bodyA, int bodyB, float anchorX, float anchorY, float axisX, float axisY) {
        if (g_physicsJoints.size() >= MAX_JOINTS) return -1;
        if (g_physicsBodies.find(bodyA) == g_physicsBodies.end()) return -1;
        if (g_physicsBodies.find(bodyB) == g_physicsBodies.end()) return -1;

        int handle = g_nextJointHandle++;
        PhysicsJoint& joint = g_physicsJoints[handle];
        joint.id = handle;
        joint.type = JOINT_TYPE_PRISMATIC;
        joint.bodyA = bodyA;
        joint.bodyB = bodyB;

        PhysicsBody& bA = g_physicsBodies[bodyA];
        PhysicsBody& bB = g_physicsBodies[bodyB];
        joint.anchorAX = anchorX - bA.x;
        joint.anchorAY = anchorY - bA.y;
        joint.anchorBX = anchorX - bB.x;
        joint.anchorBY = anchorY - bB.y;

        // Normalize axis
        float len = sqrtf(axisX * axisX + axisY * axisY);
        joint.axisX = len > 0 ? axisX / len : 1;
        joint.axisY = len > 0 ? axisY / len : 0;

        joint.lowerTranslation = -100;
        joint.upperTranslation = 100;
        joint.enableLimits = false;
        joint.motorSpeed = 0;
        joint.motorForce = 100;
        joint.enableMotor = false;
        joint.collideConnected = false;
        joint.userData = 0;
        joint.valid = true;

        return handle;
    }

    int Framework_Joint_CreatePulley(int bodyA, int bodyB, float groundAX, float groundAY, float groundBX, float groundBY,
                                      float anchorAX, float anchorAY, float anchorBX, float anchorBY, float ratio) {
        if (g_physicsJoints.size() >= MAX_JOINTS) return -1;
        if (g_physicsBodies.find(bodyA) == g_physicsBodies.end()) return -1;
        if (g_physicsBodies.find(bodyB) == g_physicsBodies.end()) return -1;

        int handle = g_nextJointHandle++;
        PhysicsJoint& joint = g_physicsJoints[handle];
        joint.id = handle;
        joint.type = JOINT_TYPE_PULLEY;
        joint.bodyA = bodyA;
        joint.bodyB = bodyB;

        PhysicsBody& bA = g_physicsBodies[bodyA];
        PhysicsBody& bB = g_physicsBodies[bodyB];
        joint.anchorAX = anchorAX - bA.x;
        joint.anchorAY = anchorAY - bA.y;
        joint.anchorBX = anchorBX - bB.x;
        joint.anchorBY = anchorBY - bB.y;

        joint.groundAX = groundAX;
        joint.groundAY = groundAY;
        joint.groundBX = groundBX;
        joint.groundBY = groundBY;
        joint.ratio = ratio > 0 ? ratio : 1;

        // Calculate initial lengths
        float dxA = anchorAX - groundAX;
        float dyA = anchorAY - groundAY;
        float dxB = anchorBX - groundBX;
        float dyB = anchorBY - groundBY;
        joint.length = sqrtf(dxA * dxA + dyA * dyA);
        joint.maxLength = sqrtf(dxB * dxB + dyB * dyB);

        joint.collideConnected = true;
        joint.userData = 0;
        joint.valid = true;

        return handle;
    }

    int Framework_Joint_CreateWeld(int bodyA, int bodyB, float anchorX, float anchorY) {
        if (g_physicsJoints.size() >= MAX_JOINTS) return -1;
        if (g_physicsBodies.find(bodyA) == g_physicsBodies.end()) return -1;
        if (g_physicsBodies.find(bodyB) == g_physicsBodies.end()) return -1;

        int handle = g_nextJointHandle++;
        PhysicsJoint& joint = g_physicsJoints[handle];
        joint.id = handle;
        joint.type = JOINT_TYPE_WELD;
        joint.bodyA = bodyA;
        joint.bodyB = bodyB;

        PhysicsBody& bA = g_physicsBodies[bodyA];
        PhysicsBody& bB = g_physicsBodies[bodyB];
        joint.anchorAX = anchorX - bA.x;
        joint.anchorAY = anchorY - bA.y;
        joint.anchorBX = anchorX - bB.x;
        joint.anchorBY = anchorY - bB.y;
        joint.currentAngle = bB.rotation - bA.rotation;

        joint.collideConnected = false;
        joint.userData = 0;
        joint.valid = true;

        return handle;
    }

    int Framework_Joint_CreateMotor(int bodyA, int bodyB) {
        if (g_physicsJoints.size() >= MAX_JOINTS) return -1;
        if (g_physicsBodies.find(bodyA) == g_physicsBodies.end()) return -1;
        if (g_physicsBodies.find(bodyB) == g_physicsBodies.end()) return -1;

        int handle = g_nextJointHandle++;
        PhysicsJoint& joint = g_physicsJoints[handle];
        joint.id = handle;
        joint.type = JOINT_TYPE_MOTOR;
        joint.bodyA = bodyA;
        joint.bodyB = bodyB;

        PhysicsBody& bA = g_physicsBodies[bodyA];
        PhysicsBody& bB = g_physicsBodies[bodyB];
        joint.targetX = bB.x - bA.x;
        joint.targetY = bB.y - bA.y;
        joint.targetAngle = bB.rotation - bA.rotation;
        joint.maxForce = 100;
        joint.maxTorque = 50;
        joint.correctionFactor = 0.3f;

        joint.collideConnected = true;
        joint.userData = 0;
        joint.valid = true;

        return handle;
    }

    int Framework_Joint_CreateWheel(int bodyA, int bodyB, float anchorX, float anchorY, float axisX, float axisY) {
        if (g_physicsJoints.size() >= MAX_JOINTS) return -1;
        if (g_physicsBodies.find(bodyA) == g_physicsBodies.end()) return -1;
        if (g_physicsBodies.find(bodyB) == g_physicsBodies.end()) return -1;

        int handle = g_nextJointHandle++;
        PhysicsJoint& joint = g_physicsJoints[handle];
        joint.id = handle;
        joint.type = JOINT_TYPE_WHEEL;
        joint.bodyA = bodyA;
        joint.bodyB = bodyB;

        PhysicsBody& bA = g_physicsBodies[bodyA];
        joint.anchorAX = anchorX - bA.x;
        joint.anchorAY = anchorY - bA.y;
        joint.anchorBX = 0;
        joint.anchorBY = 0;

        // Normalize axis
        float len = sqrtf(axisX * axisX + axisY * axisY);
        joint.axisX = len > 0 ? axisX / len : 0;
        joint.axisY = len > 0 ? axisY / len : 1;

        joint.stiffness = 200;
        joint.damping = 20;
        joint.motorSpeed = 0;
        joint.maxMotorTorque = 100;
        joint.enableMotor = false;

        joint.collideConnected = false;
        joint.userData = 0;
        joint.valid = true;

        return handle;
    }

    int Framework_Joint_CreateRope(int bodyA, int bodyB, float anchorAX, float anchorAY, float anchorBX, float anchorBY, float maxLength) {
        if (g_physicsJoints.size() >= MAX_JOINTS) return -1;
        if (g_physicsBodies.find(bodyA) == g_physicsBodies.end()) return -1;
        if (g_physicsBodies.find(bodyB) == g_physicsBodies.end()) return -1;

        int handle = g_nextJointHandle++;
        PhysicsJoint& joint = g_physicsJoints[handle];
        joint.id = handle;
        joint.type = JOINT_TYPE_ROPE;
        joint.bodyA = bodyA;
        joint.bodyB = bodyB;

        PhysicsBody& bA = g_physicsBodies[bodyA];
        PhysicsBody& bB = g_physicsBodies[bodyB];
        joint.anchorAX = anchorAX - bA.x;
        joint.anchorAY = anchorAY - bA.y;
        joint.anchorBX = anchorBX - bB.x;
        joint.anchorBY = anchorBY - bB.y;
        joint.maxLength = maxLength;

        joint.collideConnected = true;
        joint.userData = 0;
        joint.valid = true;

        return handle;
    }

    // Joint destruction
    void Framework_Joint_Destroy(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it != g_physicsJoints.end()) {
            g_physicsJoints.erase(it);
        }
    }

    void Framework_Joint_DestroyAll() {
        g_physicsJoints.clear();
    }

    bool Framework_Joint_IsValid(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        return it != g_physicsJoints.end() && it->second.valid;
    }

    int Framework_Joint_GetType(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return -1;
        return it->second.type;
    }

    // Joint queries
    int Framework_Joint_GetBodyA(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return -1;
        return it->second.bodyA;
    }

    int Framework_Joint_GetBodyB(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return -1;
        return it->second.bodyB;
    }

    void Framework_Joint_GetAnchorA(int jointHandle, float* x, float* y) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) { if (x) *x = 0; if (y) *y = 0; return; }

        PhysicsJoint& joint = it->second;
        auto bodyIt = g_physicsBodies.find(joint.bodyA);
        if (bodyIt == g_physicsBodies.end()) { if (x) *x = 0; if (y) *y = 0; return; }

        if (x) *x = bodyIt->second.x + joint.anchorAX;
        if (y) *y = bodyIt->second.y + joint.anchorAY;
    }

    void Framework_Joint_GetAnchorB(int jointHandle, float* x, float* y) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) { if (x) *x = 0; if (y) *y = 0; return; }

        PhysicsJoint& joint = it->second;
        auto bodyIt = g_physicsBodies.find(joint.bodyB);
        if (bodyIt == g_physicsBodies.end()) { if (x) *x = 0; if (y) *y = 0; return; }

        if (x) *x = bodyIt->second.x + joint.anchorBX;
        if (y) *y = bodyIt->second.y + joint.anchorBY;
    }

    void Framework_Joint_GetReactionForce(int jointHandle, float* fx, float* fy) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) { if (fx) *fx = 0; if (fy) *fy = 0; return; }
        if (fx) *fx = it->second.reactionForceX;
        if (fy) *fy = it->second.reactionForceY;
    }

    float Framework_Joint_GetReactionTorque(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return 0;
        return it->second.reactionTorque;
    }

    // Revolute joint configuration
    void Framework_Joint_SetRevoluteLimits(int jointHandle, float lowerAngle, float upperAngle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end() || it->second.type != JOINT_TYPE_REVOLUTE) return;
        it->second.lowerAngle = lowerAngle;
        it->second.upperAngle = upperAngle;
    }

    void Framework_Joint_GetRevoluteLimits(int jointHandle, float* lowerAngle, float* upperAngle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) { if (lowerAngle) *lowerAngle = 0; if (upperAngle) *upperAngle = 0; return; }
        if (lowerAngle) *lowerAngle = it->second.lowerAngle;
        if (upperAngle) *upperAngle = it->second.upperAngle;
    }

    void Framework_Joint_EnableRevoluteLimits(int jointHandle, bool enable) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end() || it->second.type != JOINT_TYPE_REVOLUTE) return;
        it->second.enableLimits = enable;
    }

    bool Framework_Joint_AreRevoluteLimitsEnabled(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return false;
        return it->second.enableLimits;
    }

    void Framework_Joint_SetRevoluteMotor(int jointHandle, float speed, float maxTorque) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.motorSpeed = speed;
        it->second.maxMotorTorque = maxTorque;
    }

    void Framework_Joint_EnableRevoluteMotor(int jointHandle, bool enable) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.enableMotor = enable;
    }

    bool Framework_Joint_IsRevoluteMotorEnabled(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return false;
        return it->second.enableMotor;
    }

    float Framework_Joint_GetRevoluteAngle(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return 0;
        return it->second.currentAngle;
    }

    float Framework_Joint_GetRevoluteSpeed(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return 0;
        return it->second.currentSpeed;
    }

    // Distance joint configuration
    void Framework_Joint_SetDistanceLength(int jointHandle, float length) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.length = length;
    }

    float Framework_Joint_GetDistanceLength(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return 0;
        return it->second.length;
    }

    void Framework_Joint_SetDistanceMinMax(int jointHandle, float minLength, float maxLength) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.minLength = minLength;
        it->second.maxLength = maxLength;
    }

    void Framework_Joint_SetDistanceStiffness(int jointHandle, float stiffness) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.stiffness = stiffness;
    }

    float Framework_Joint_GetDistanceStiffness(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return 0;
        return it->second.stiffness;
    }

    void Framework_Joint_SetDistanceDamping(int jointHandle, float damping) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.damping = damping;
    }

    float Framework_Joint_GetDistanceDamping(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return 0;
        return it->second.damping;
    }

    // Prismatic joint configuration
    void Framework_Joint_SetPrismaticLimits(int jointHandle, float lowerTranslation, float upperTranslation) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.lowerTranslation = lowerTranslation;
        it->second.upperTranslation = upperTranslation;
    }

    void Framework_Joint_GetPrismaticLimits(int jointHandle, float* lower, float* upper) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) { if (lower) *lower = 0; if (upper) *upper = 0; return; }
        if (lower) *lower = it->second.lowerTranslation;
        if (upper) *upper = it->second.upperTranslation;
    }

    void Framework_Joint_EnablePrismaticLimits(int jointHandle, bool enable) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.enableLimits = enable;
    }

    bool Framework_Joint_ArePrismaticLimitsEnabled(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return false;
        return it->second.enableLimits;
    }

    void Framework_Joint_SetPrismaticMotor(int jointHandle, float speed, float maxForce) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.motorSpeed = speed;
        it->second.motorForce = maxForce;
    }

    void Framework_Joint_EnablePrismaticMotor(int jointHandle, bool enable) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.enableMotor = enable;
    }

    bool Framework_Joint_IsPrismaticMotorEnabled(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return false;
        return it->second.enableMotor;
    }

    float Framework_Joint_GetPrismaticTranslation(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return 0;
        return it->second.currentTranslation;
    }

    float Framework_Joint_GetPrismaticSpeed(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return 0;
        return it->second.currentSpeed;
    }

    // Motor joint configuration
    void Framework_Joint_SetMotorTarget(int jointHandle, float targetX, float targetY, float targetAngle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.targetX = targetX;
        it->second.targetY = targetY;
        it->second.targetAngle = targetAngle;
    }

    void Framework_Joint_SetMotorMaxForce(int jointHandle, float maxForce) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.maxForce = maxForce;
    }

    void Framework_Joint_SetMotorMaxTorque(int jointHandle, float maxTorque) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.maxTorque = maxTorque;
    }

    void Framework_Joint_SetMotorCorrectionFactor(int jointHandle, float factor) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.correctionFactor = factor;
    }

    // Wheel joint configuration
    void Framework_Joint_SetWheelMotor(int jointHandle, float speed, float maxTorque) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.motorSpeed = speed;
        it->second.maxMotorTorque = maxTorque;
    }

    void Framework_Joint_EnableWheelMotor(int jointHandle, bool enable) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.enableMotor = enable;
    }

    bool Framework_Joint_IsWheelMotorEnabled(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return false;
        return it->second.enableMotor;
    }

    void Framework_Joint_SetWheelStiffness(int jointHandle, float stiffness) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.stiffness = stiffness;
    }

    void Framework_Joint_SetWheelDamping(int jointHandle, float damping) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.damping = damping;
    }

    // Rope joint configuration
    void Framework_Joint_SetRopeMaxLength(int jointHandle, float maxLength) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.maxLength = maxLength;
    }

    float Framework_Joint_GetRopeMaxLength(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return 0;
        return it->second.maxLength;
    }

    // General joint properties
    void Framework_Joint_SetCollideConnected(int jointHandle, bool collide) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.collideConnected = collide;
    }

    bool Framework_Joint_GetCollideConnected(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return false;
        return it->second.collideConnected;
    }

    void Framework_Joint_SetUserData(int jointHandle, int userData) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return;
        it->second.userData = userData;
    }

    int Framework_Joint_GetUserData(int jointHandle) {
        auto it = g_physicsJoints.find(jointHandle);
        if (it == g_physicsJoints.end()) return 0;
        return it->second.userData;
    }

    int Framework_Joint_GetCount() {
        return (int)g_physicsJoints.size();
    }

    int Framework_Joint_GetByIndex(int index) {
        if (index < 0 || index >= (int)g_physicsJoints.size()) return -1;
        auto it = g_physicsJoints.begin();
        std::advance(it, index);
        return it->first;
    }

    void Framework_Joint_DrawDebug() {
        for (auto& kv : g_physicsJoints) {
            PhysicsJoint& joint = kv.second;
            if (!joint.valid) continue;

            float ax, ay, bx, by;
            Framework_Joint_GetAnchorA(kv.first, &ax, &ay);
            Framework_Joint_GetAnchorB(kv.first, &bx, &by);

            Color color;
            switch (joint.type) {
                case JOINT_TYPE_REVOLUTE: color = { 255, 100, 100, 200 }; break;
                case JOINT_TYPE_DISTANCE: color = { 100, 255, 100, 200 }; break;
                case JOINT_TYPE_PRISMATIC: color = { 100, 100, 255, 200 }; break;
                case JOINT_TYPE_WELD: color = { 255, 255, 100, 200 }; break;
                case JOINT_TYPE_ROPE: color = { 200, 150, 100, 200 }; break;
                default: color = { 200, 200, 200, 200 }; break;
            }

            // Draw line between anchors
            DrawLine((int)ax, (int)ay, (int)bx, (int)by, color);

            // Draw anchor points
            DrawCircle((int)ax, (int)ay, 4, color);
            DrawCircle((int)bx, (int)by, 4, color);

            // Draw special indicators
            if (joint.type == JOINT_TYPE_REVOLUTE) {
                DrawCircleLines((int)ax, (int)ay, 10, color);
            } else if (joint.type == JOINT_TYPE_PRISMATIC) {
                // Draw axis indicator
                auto bodyIt = g_physicsBodies.find(joint.bodyA);
                if (bodyIt != g_physicsBodies.end()) {
                    float cx = bodyIt->second.x;
                    float cy = bodyIt->second.y;
                    DrawLine((int)(cx - joint.axisX * 30), (int)(cy - joint.axisY * 30),
                             (int)(cx + joint.axisX * 30), (int)(cy + joint.axisY * 30), color);
                }
            } else if (joint.type == JOINT_TYPE_PULLEY) {
                // Draw ground anchors
                DrawCircle((int)joint.groundAX, (int)joint.groundAY, 6, { 150, 150, 150, 200 });
                DrawCircle((int)joint.groundBX, (int)joint.groundBY, 6, { 150, 150, 150, 200 });
                DrawLine((int)joint.groundAX, (int)joint.groundAY, (int)ax, (int)ay, color);
                DrawLine((int)joint.groundBX, (int)joint.groundBY, (int)bx, (int)by, color);
            }
        }
    }

    // ========================================================================
    // BEHAVIOR TREES - AI Decision Making System
    // ========================================================================

    // Blackboard value variant
    struct BTBlackboardValue {
        enum Type { INT, FLOAT, BOOL, STRING, VECTOR2 } type;
        int intVal;
        float floatVal;
        bool boolVal;
        std::string stringVal;
        float vec2X, vec2Y;
    };

    // BT Node structure
    struct BTNode {
        int id;
        int type;           // BTNodeType
        int decoratorType;  // BTDecoratorType (if type == BT_NODE_DECORATOR)
        std::string name;
        std::string actionName;     // For action/condition nodes
        int parentId;
        std::vector<int> children;

        // Decorator properties
        int repeatCount;        // For repeater (-1 = forever)
        int currentRepeat;
        float cooldownTime;
        float cooldownRemaining;
        int maxExecutions;
        int executionCount;

        // Parallel properties
        int successPolicy;
        int failurePolicy;

        // Runtime state
        int lastStatus;
        int runningChildIndex;
        bool valid;
    };

    // Behavior Tree structure
    struct BehaviorTree {
        int id;
        std::string name;
        std::unordered_map<int, BTNode> nodes;
        int rootNodeId;
        int nextNodeId;
        int lastStatus;
        int runningNodeId;
        bool debugEnabled;
        std::unordered_map<std::string, BTBlackboardValue> blackboard;
        bool valid;
    };

    // Action/Condition callback storage
    struct BTActionEntry {
        BTActionCallback callback;
        void* userData;
    };
    struct BTConditionEntry {
        BTConditionCallback callback;
        void* userData;
    };

    static std::unordered_map<int, BehaviorTree> g_behaviorTrees;
    static int g_nextBTId = 1;
    static std::unordered_map<std::string, BTActionEntry> g_btActions;
    static std::unordered_map<std::string, BTConditionEntry> g_btConditions;
    static const int MAX_BT_TREES = 100;
    static const int MAX_BT_NODES = 1000;

    // Forward declaration for recursive execution
    static int BT_ExecuteNode(BehaviorTree& tree, int nodeId, int entityId, float dt);

    // Tree management
    int Framework_BT_CreateTree(const char* name) {
        if (g_behaviorTrees.size() >= MAX_BT_TREES) return -1;

        int id = g_nextBTId++;
        BehaviorTree& tree = g_behaviorTrees[id];
        tree.id = id;
        tree.name = name ? name : "";
        tree.rootNodeId = -1;
        tree.nextNodeId = 1;
        tree.lastStatus = BT_SUCCESS;
        tree.runningNodeId = -1;
        tree.debugEnabled = false;
        tree.valid = true;
        return id;
    }

    void Framework_BT_DestroyTree(int treeId) {
        g_behaviorTrees.erase(treeId);
    }

    int Framework_BT_GetTree(const char* name) {
        if (!name) return -1;
        for (auto& kv : g_behaviorTrees) {
            if (kv.second.valid && kv.second.name == name) return kv.first;
        }
        return -1;
    }

    bool Framework_BT_IsTreeValid(int treeId) {
        auto it = g_behaviorTrees.find(treeId);
        return it != g_behaviorTrees.end() && it->second.valid;
    }

    int Framework_BT_CloneTree(int treeId, const char* newName) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return -1;

        int newId = Framework_BT_CreateTree(newName);
        if (newId < 0) return -1;

        BehaviorTree& newTree = g_behaviorTrees[newId];
        BehaviorTree& srcTree = it->second;

        newTree.nodes = srcTree.nodes;
        newTree.rootNodeId = srcTree.rootNodeId;
        newTree.nextNodeId = srcTree.nextNodeId;
        return newId;
    }

    // Helper to create a node
    static int BT_CreateNode(int treeId, int parentId, int nodeType) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return -1;
        if (it->second.nodes.size() >= MAX_BT_NODES) return -1;

        BehaviorTree& tree = it->second;
        int nodeId = tree.nextNodeId++;

        BTNode& node = tree.nodes[nodeId];
        node.id = nodeId;
        node.type = nodeType;
        node.decoratorType = 0;
        node.parentId = parentId;
        node.repeatCount = 1;
        node.currentRepeat = 0;
        node.cooldownTime = 0;
        node.cooldownRemaining = 0;
        node.maxExecutions = -1;
        node.executionCount = 0;
        node.successPolicy = BT_PARALLEL_REQUIRE_ALL;
        node.failurePolicy = BT_PARALLEL_REQUIRE_ONE;
        node.lastStatus = BT_SUCCESS;
        node.runningChildIndex = 0;
        node.valid = true;

        // Add to parent's children
        if (parentId >= 0) {
            auto parentIt = tree.nodes.find(parentId);
            if (parentIt != tree.nodes.end()) {
                parentIt->second.children.push_back(nodeId);
            }
        } else {
            // This is the root
            tree.rootNodeId = nodeId;
        }

        return nodeId;
    }

    int Framework_BT_CreateSelector(int treeId, int parentId) {
        return BT_CreateNode(treeId, parentId, BT_NODE_SELECTOR);
    }

    int Framework_BT_CreateSequence(int treeId, int parentId) {
        return BT_CreateNode(treeId, parentId, BT_NODE_SEQUENCE);
    }

    int Framework_BT_CreateParallel(int treeId, int parentId, int successPolicy, int failurePolicy) {
        int nodeId = BT_CreateNode(treeId, parentId, BT_NODE_PARALLEL);
        if (nodeId < 0) return -1;

        auto& tree = g_behaviorTrees[treeId];
        tree.nodes[nodeId].successPolicy = successPolicy;
        tree.nodes[nodeId].failurePolicy = failurePolicy;
        return nodeId;
    }

    int Framework_BT_CreateAction(int treeId, int parentId, const char* actionName) {
        int nodeId = BT_CreateNode(treeId, parentId, BT_NODE_ACTION);
        if (nodeId < 0) return -1;

        auto& tree = g_behaviorTrees[treeId];
        tree.nodes[nodeId].actionName = actionName ? actionName : "";
        tree.nodes[nodeId].name = actionName ? actionName : "";
        return nodeId;
    }

    int Framework_BT_CreateCondition(int treeId, int parentId, const char* conditionName) {
        int nodeId = BT_CreateNode(treeId, parentId, BT_NODE_CONDITION);
        if (nodeId < 0) return -1;

        auto& tree = g_behaviorTrees[treeId];
        tree.nodes[nodeId].actionName = conditionName ? conditionName : "";
        tree.nodes[nodeId].name = conditionName ? conditionName : "";
        return nodeId;
    }

    // Decorator creation
    static int BT_CreateDecorator(int treeId, int parentId, int decoratorType) {
        int nodeId = BT_CreateNode(treeId, parentId, BT_NODE_DECORATOR);
        if (nodeId < 0) return -1;

        auto& tree = g_behaviorTrees[treeId];
        tree.nodes[nodeId].decoratorType = decoratorType;
        return nodeId;
    }

    int Framework_BT_CreateInverter(int treeId, int parentId) {
        return BT_CreateDecorator(treeId, parentId, BT_DEC_INVERTER);
    }

    int Framework_BT_CreateSucceeder(int treeId, int parentId) {
        return BT_CreateDecorator(treeId, parentId, BT_DEC_SUCCEEDER);
    }

    int Framework_BT_CreateFailer(int treeId, int parentId) {
        return BT_CreateDecorator(treeId, parentId, BT_DEC_FAILER);
    }

    int Framework_BT_CreateRepeater(int treeId, int parentId, int repeatCount) {
        int nodeId = BT_CreateDecorator(treeId, parentId, BT_DEC_REPEATER);
        if (nodeId < 0) return -1;

        auto& tree = g_behaviorTrees[treeId];
        tree.nodes[nodeId].repeatCount = repeatCount;
        return nodeId;
    }

    int Framework_BT_CreateRepeatUntilFail(int treeId, int parentId) {
        return BT_CreateDecorator(treeId, parentId, BT_DEC_REPEAT_UNTIL_FAIL);
    }

    int Framework_BT_CreateRepeatUntilSuccess(int treeId, int parentId) {
        return BT_CreateDecorator(treeId, parentId, BT_DEC_REPEAT_UNTIL_SUCCESS);
    }

    int Framework_BT_CreateCooldown(int treeId, int parentId, float cooldownTime) {
        int nodeId = BT_CreateDecorator(treeId, parentId, BT_DEC_COOLDOWN);
        if (nodeId < 0) return -1;

        auto& tree = g_behaviorTrees[treeId];
        tree.nodes[nodeId].cooldownTime = cooldownTime;
        return nodeId;
    }

    int Framework_BT_CreateLimiter(int treeId, int parentId, int maxExecutions) {
        int nodeId = BT_CreateDecorator(treeId, parentId, BT_DEC_LIMITER);
        if (nodeId < 0) return -1;

        auto& tree = g_behaviorTrees[treeId];
        tree.nodes[nodeId].maxExecutions = maxExecutions;
        return nodeId;
    }

    // Node configuration
    void Framework_BT_SetNodeName(int treeId, int nodeId, const char* name) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return;
        auto nodeIt = it->second.nodes.find(nodeId);
        if (nodeIt == it->second.nodes.end()) return;
        nodeIt->second.name = name ? name : "";
    }

    const char* Framework_BT_GetNodeName(int treeId, int nodeId) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return "";
        auto nodeIt = it->second.nodes.find(nodeId);
        if (nodeIt == it->second.nodes.end()) return "";
        return nodeIt->second.name.c_str();
    }

    int Framework_BT_GetNodeType(int treeId, int nodeId) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return -1;
        auto nodeIt = it->second.nodes.find(nodeId);
        if (nodeIt == it->second.nodes.end()) return -1;
        return nodeIt->second.type;
    }

    int Framework_BT_GetNodeParent(int treeId, int nodeId) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return -1;
        auto nodeIt = it->second.nodes.find(nodeId);
        if (nodeIt == it->second.nodes.end()) return -1;
        return nodeIt->second.parentId;
    }

    int Framework_BT_GetNodeChildCount(int treeId, int nodeId) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return 0;
        auto nodeIt = it->second.nodes.find(nodeId);
        if (nodeIt == it->second.nodes.end()) return 0;
        return (int)nodeIt->second.children.size();
    }

    int Framework_BT_GetNodeChild(int treeId, int nodeId, int childIndex) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return -1;
        auto nodeIt = it->second.nodes.find(nodeId);
        if (nodeIt == it->second.nodes.end()) return -1;
        if (childIndex < 0 || childIndex >= (int)nodeIt->second.children.size()) return -1;
        return nodeIt->second.children[childIndex];
    }

    void Framework_BT_RemoveNode(int treeId, int nodeId) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return;

        auto nodeIt = it->second.nodes.find(nodeId);
        if (nodeIt == it->second.nodes.end()) return;

        // Remove from parent's children
        int parentId = nodeIt->second.parentId;
        if (parentId >= 0) {
            auto parentIt = it->second.nodes.find(parentId);
            if (parentIt != it->second.nodes.end()) {
                auto& children = parentIt->second.children;
                children.erase(std::remove(children.begin(), children.end(), nodeId), children.end());
            }
        }

        // Recursively remove children
        for (int childId : nodeIt->second.children) {
            Framework_BT_RemoveNode(treeId, childId);
        }

        it->second.nodes.erase(nodeId);
    }

    // Callback registration
    void Framework_BT_RegisterAction(const char* actionName, BTActionCallback callback, void* userData) {
        if (!actionName || !callback) return;
        g_btActions[actionName] = { callback, userData };
    }

    void Framework_BT_RegisterCondition(const char* conditionName, BTConditionCallback callback, void* userData) {
        if (!conditionName || !callback) return;
        g_btConditions[conditionName] = { callback, userData };
    }

    void Framework_BT_UnregisterAction(const char* actionName) {
        if (!actionName) return;
        g_btActions.erase(actionName);
    }

    void Framework_BT_UnregisterCondition(const char* conditionName) {
        if (!conditionName) return;
        g_btConditions.erase(conditionName);
    }

    // Node execution
    static int BT_ExecuteNode(BehaviorTree& tree, int nodeId, int entityId, float dt) {
        auto nodeIt = tree.nodes.find(nodeId);
        if (nodeIt == tree.nodes.end()) return BT_FAILURE;

        BTNode& node = nodeIt->second;

        if (tree.debugEnabled) {
            TraceLog(LOG_INFO, "BT: Executing node %d (%s) type=%d", nodeId, node.name.c_str(), node.type);
        }

        switch (node.type) {
            case BT_NODE_SELECTOR: {
                // Run children until one succeeds
                for (size_t i = node.runningChildIndex; i < node.children.size(); i++) {
                    int status = BT_ExecuteNode(tree, node.children[i], entityId, dt);
                    if (status == BT_RUNNING) {
                        node.runningChildIndex = (int)i;
                        tree.runningNodeId = nodeId;
                        return BT_RUNNING;
                    }
                    if (status == BT_SUCCESS) {
                        node.runningChildIndex = 0;
                        return BT_SUCCESS;
                    }
                }
                node.runningChildIndex = 0;
                return BT_FAILURE;
            }

            case BT_NODE_SEQUENCE: {
                // Run children until one fails
                for (size_t i = node.runningChildIndex; i < node.children.size(); i++) {
                    int status = BT_ExecuteNode(tree, node.children[i], entityId, dt);
                    if (status == BT_RUNNING) {
                        node.runningChildIndex = (int)i;
                        tree.runningNodeId = nodeId;
                        return BT_RUNNING;
                    }
                    if (status == BT_FAILURE) {
                        node.runningChildIndex = 0;
                        return BT_FAILURE;
                    }
                }
                node.runningChildIndex = 0;
                return BT_SUCCESS;
            }

            case BT_NODE_PARALLEL: {
                int successCount = 0, failureCount = 0, runningCount = 0;
                for (int childId : node.children) {
                    int status = BT_ExecuteNode(tree, childId, entityId, dt);
                    if (status == BT_SUCCESS) successCount++;
                    else if (status == BT_FAILURE) failureCount++;
                    else runningCount++;
                }

                if (runningCount > 0) return BT_RUNNING;

                if (node.successPolicy == BT_PARALLEL_REQUIRE_ONE && successCount > 0) return BT_SUCCESS;
                if (node.successPolicy == BT_PARALLEL_REQUIRE_ALL && failureCount == 0) return BT_SUCCESS;
                return BT_FAILURE;
            }

            case BT_NODE_DECORATOR: {
                if (node.children.empty()) return BT_FAILURE;
                int childId = node.children[0];

                switch (node.decoratorType) {
                    case BT_DEC_INVERTER: {
                        int status = BT_ExecuteNode(tree, childId, entityId, dt);
                        if (status == BT_RUNNING) return BT_RUNNING;
                        return (status == BT_SUCCESS) ? BT_FAILURE : BT_SUCCESS;
                    }
                    case BT_DEC_SUCCEEDER: {
                        BT_ExecuteNode(tree, childId, entityId, dt);
                        return BT_SUCCESS;
                    }
                    case BT_DEC_FAILER: {
                        BT_ExecuteNode(tree, childId, entityId, dt);
                        return BT_FAILURE;
                    }
                    case BT_DEC_REPEATER: {
                        if (node.repeatCount >= 0 && node.currentRepeat >= node.repeatCount) {
                            node.currentRepeat = 0;
                            return BT_SUCCESS;
                        }
                        int status = BT_ExecuteNode(tree, childId, entityId, dt);
                        if (status == BT_RUNNING) return BT_RUNNING;
                        node.currentRepeat++;
                        if (node.repeatCount < 0 || node.currentRepeat < node.repeatCount) {
                            return BT_RUNNING;  // Keep running
                        }
                        node.currentRepeat = 0;
                        return BT_SUCCESS;
                    }
                    case BT_DEC_REPEAT_UNTIL_FAIL: {
                        int status = BT_ExecuteNode(tree, childId, entityId, dt);
                        if (status == BT_FAILURE) return BT_SUCCESS;
                        return BT_RUNNING;
                    }
                    case BT_DEC_REPEAT_UNTIL_SUCCESS: {
                        int status = BT_ExecuteNode(tree, childId, entityId, dt);
                        if (status == BT_SUCCESS) return BT_SUCCESS;
                        return BT_RUNNING;
                    }
                    case BT_DEC_COOLDOWN: {
                        if (node.cooldownRemaining > 0) {
                            node.cooldownRemaining -= dt;
                            return BT_FAILURE;
                        }
                        int status = BT_ExecuteNode(tree, childId, entityId, dt);
                        if (status != BT_RUNNING) {
                            node.cooldownRemaining = node.cooldownTime;
                        }
                        return status;
                    }
                    case BT_DEC_LIMITER: {
                        if (node.maxExecutions >= 0 && node.executionCount >= node.maxExecutions) {
                            return BT_FAILURE;
                        }
                        int status = BT_ExecuteNode(tree, childId, entityId, dt);
                        if (status != BT_RUNNING) {
                            node.executionCount++;
                        }
                        return status;
                    }
                }
                return BT_FAILURE;
            }

            case BT_NODE_ACTION: {
                auto actionIt = g_btActions.find(node.actionName);
                if (actionIt == g_btActions.end()) {
                    if (tree.debugEnabled) {
                        TraceLog(LOG_WARNING, "BT: Action '%s' not registered", node.actionName.c_str());
                    }
                    return BT_FAILURE;
                }
                return actionIt->second.callback(tree.id, nodeId, entityId, dt, actionIt->second.userData);
            }

            case BT_NODE_CONDITION: {
                auto condIt = g_btConditions.find(node.actionName);
                if (condIt == g_btConditions.end()) {
                    if (tree.debugEnabled) {
                        TraceLog(LOG_WARNING, "BT: Condition '%s' not registered", node.actionName.c_str());
                    }
                    return BT_FAILURE;
                }
                return condIt->second.callback(tree.id, nodeId, entityId, condIt->second.userData) ? BT_SUCCESS : BT_FAILURE;
            }
        }

        return BT_FAILURE;
    }

    int Framework_BT_Execute(int treeId, int entityId, float dt) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return BT_FAILURE;

        BehaviorTree& tree = it->second;
        if (tree.rootNodeId < 0) return BT_FAILURE;

        tree.runningNodeId = -1;
        tree.lastStatus = BT_ExecuteNode(tree, tree.rootNodeId, entityId, dt);
        return tree.lastStatus;
    }

    void Framework_BT_Reset(int treeId) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return;

        for (auto& kv : it->second.nodes) {
            kv.second.runningChildIndex = 0;
            kv.second.currentRepeat = 0;
            kv.second.cooldownRemaining = 0;
            kv.second.lastStatus = BT_SUCCESS;
        }
        it->second.runningNodeId = -1;
        it->second.lastStatus = BT_SUCCESS;
    }

    void Framework_BT_Abort(int treeId) {
        Framework_BT_Reset(treeId);
    }

    int Framework_BT_GetLastStatus(int treeId) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return BT_FAILURE;
        return it->second.lastStatus;
    }

    int Framework_BT_GetRunningNode(int treeId) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return -1;
        return it->second.runningNodeId;
    }

    // Blackboard
    void Framework_BT_SetBlackboardInt(int treeId, const char* key, int value) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end() || !key) return;
        BTBlackboardValue& v = it->second.blackboard[key];
        v.type = BTBlackboardValue::INT;
        v.intVal = value;
    }

    int Framework_BT_GetBlackboardInt(int treeId, const char* key, int defaultValue) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end() || !key) return defaultValue;
        auto valIt = it->second.blackboard.find(key);
        if (valIt == it->second.blackboard.end()) return defaultValue;
        return valIt->second.intVal;
    }

    void Framework_BT_SetBlackboardFloat(int treeId, const char* key, float value) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end() || !key) return;
        BTBlackboardValue& v = it->second.blackboard[key];
        v.type = BTBlackboardValue::FLOAT;
        v.floatVal = value;
    }

    float Framework_BT_GetBlackboardFloat(int treeId, const char* key, float defaultValue) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end() || !key) return defaultValue;
        auto valIt = it->second.blackboard.find(key);
        if (valIt == it->second.blackboard.end()) return defaultValue;
        return valIt->second.floatVal;
    }

    void Framework_BT_SetBlackboardBool(int treeId, const char* key, bool value) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end() || !key) return;
        BTBlackboardValue& v = it->second.blackboard[key];
        v.type = BTBlackboardValue::BOOL;
        v.boolVal = value;
    }

    bool Framework_BT_GetBlackboardBool(int treeId, const char* key, bool defaultValue) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end() || !key) return defaultValue;
        auto valIt = it->second.blackboard.find(key);
        if (valIt == it->second.blackboard.end()) return defaultValue;
        return valIt->second.boolVal;
    }

    void Framework_BT_SetBlackboardString(int treeId, const char* key, const char* value) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end() || !key) return;
        BTBlackboardValue& v = it->second.blackboard[key];
        v.type = BTBlackboardValue::STRING;
        v.stringVal = value ? value : "";
    }

    const char* Framework_BT_GetBlackboardString(int treeId, const char* key, const char* defaultValue) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end() || !key) return defaultValue;
        auto valIt = it->second.blackboard.find(key);
        if (valIt == it->second.blackboard.end()) return defaultValue;
        return valIt->second.stringVal.c_str();
    }

    void Framework_BT_SetBlackboardVector2(int treeId, const char* key, float x, float y) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end() || !key) return;
        BTBlackboardValue& v = it->second.blackboard[key];
        v.type = BTBlackboardValue::VECTOR2;
        v.vec2X = x;
        v.vec2Y = y;
    }

    void Framework_BT_GetBlackboardVector2(int treeId, const char* key, float* x, float* y) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end() || !key) { if (x) *x = 0; if (y) *y = 0; return; }
        auto valIt = it->second.blackboard.find(key);
        if (valIt == it->second.blackboard.end()) { if (x) *x = 0; if (y) *y = 0; return; }
        if (x) *x = valIt->second.vec2X;
        if (y) *y = valIt->second.vec2Y;
    }

    void Framework_BT_ClearBlackboard(int treeId) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return;
        it->second.blackboard.clear();
    }

    bool Framework_BT_HasBlackboardKey(int treeId, const char* key) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end() || !key) return false;
        return it->second.blackboard.count(key) > 0;
    }

    void Framework_BT_RemoveBlackboardKey(int treeId, const char* key) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end() || !key) return;
        it->second.blackboard.erase(key);
    }

    // Built-in actions
    static int BT_Action_Wait(int treeId, int nodeId, int entityId, float dt, void* userData) {
        float waitTime = Framework_BT_GetBlackboardFloat(treeId, "wait_time", 1.0f);
        float elapsed = Framework_BT_GetBlackboardFloat(treeId, "wait_elapsed", 0.0f);
        elapsed += dt;
        Framework_BT_SetBlackboardFloat(treeId, "wait_elapsed", elapsed);
        if (elapsed >= waitTime) {
            Framework_BT_SetBlackboardFloat(treeId, "wait_elapsed", 0.0f);
            return BT_SUCCESS;
        }
        return BT_RUNNING;
    }

    static int BT_Action_Log(int treeId, int nodeId, int entityId, float dt, void* userData) {
        const char* msg = Framework_BT_GetBlackboardString(treeId, "log_message", "BT Log");
        TraceLog(LOG_INFO, "BT[%d] Entity[%d]: %s", treeId, entityId, msg);
        return BT_SUCCESS;
    }

    static bool BT_Condition_True(int treeId, int nodeId, int entityId, void* userData) {
        return true;
    }

    static bool BT_Condition_False(int treeId, int nodeId, int entityId, void* userData) {
        return false;
    }

    static bool BT_Condition_HasKey(int treeId, int nodeId, int entityId, void* userData) {
        const char* key = Framework_BT_GetBlackboardString(treeId, "check_key", "");
        return Framework_BT_HasBlackboardKey(treeId, key);
    }

    void Framework_BT_RegisterBuiltinActions() {
        Framework_BT_RegisterAction("Wait", BT_Action_Wait, nullptr);
        Framework_BT_RegisterAction("Log", BT_Action_Log, nullptr);
        Framework_BT_RegisterCondition("True", BT_Condition_True, nullptr);
        Framework_BT_RegisterCondition("False", BT_Condition_False, nullptr);
        Framework_BT_RegisterCondition("HasKey", BT_Condition_HasKey, nullptr);
    }

    // Debug
    void Framework_BT_SetDebugEnabled(int treeId, bool enabled) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return;
        it->second.debugEnabled = enabled;
    }

    bool Framework_BT_IsDebugEnabled(int treeId) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return false;
        return it->second.debugEnabled;
    }

    int Framework_BT_GetTreeCount() {
        return (int)g_behaviorTrees.size();
    }

    int Framework_BT_GetNodeCount(int treeId) {
        auto it = g_behaviorTrees.find(treeId);
        if (it == g_behaviorTrees.end()) return 0;
        return (int)it->second.nodes.size();
    }

    // ========================================================================
    // ANIMATION STATE MACHINE - Blend Trees and State-based Animation
    // ========================================================================

    // Blend clip info
    struct AnimBlendClip {
        int animClipId;
        float threshold;  // For 1D blend
        float x, y;       // For 2D blend
    };

    // Animation state
    struct AnimState {
        int id;
        std::string name;
        AnimStateType type;
        int animClipId;           // For single state
        std::string blendParamX;  // For blend states
        std::string blendParamY;  // For 2D blend
        std::vector<AnimBlendClip> blendClips;
        float speed = 1.0f;
        bool loop = true;
    };

    // Transition condition
    struct AnimCondition {
        std::string paramName;
        AnimConditionType type;
        float threshold;
        bool boolValue;
        bool isTrigger;
    };

    // State transition
    struct AnimTransition {
        int id;
        int fromState;  // -1 for any-state
        int toState;
        float duration;
        bool hasExitTime;
        float exitTime;
        std::vector<AnimCondition> conditions;
    };

    // Animation parameter
    struct AnimParameter {
        enum Type { FLOAT, INT, BOOL, TRIGGER };
        Type type;
        float floatValue;
        int intValue;
        bool boolValue;
        bool triggered;
    };

    // Animation controller (template)
    struct AnimController {
        int id;
        std::string name;
        std::unordered_map<int, AnimState> states;
        std::unordered_map<int, AnimTransition> transitions;
        std::unordered_map<std::string, AnimParameter> parameters;
        int defaultState = -1;
        int nextStateId = 0;
        int nextTransitionId = 0;
        AnimStateCallback onStateEnter = nullptr;
        AnimStateCallback onStateExit = nullptr;
        void* callbackUserData = nullptr;
    };

    // Animation controller instance (runtime)
    struct AnimControllerInstance {
        int id;
        int controllerId;
        int entityId;
        int currentState;
        int targetState;
        float stateTime;
        float transitionTime;
        float transitionDuration;
        bool inTransition;
        bool paused;
        float speed;
        std::unordered_map<std::string, AnimParameter> localParams;  // Override controller params
    };

    static std::unordered_map<int, AnimController> g_animControllers;
    static std::unordered_map<int, AnimControllerInstance> g_animInstances;
    static int g_nextAnimControllerId = 1;
    static int g_nextAnimInstanceId = 1;

    // Helper to calculate clip duration from frames
    static float CalcClipDuration(const AnimClip& clip) {
        if (clip.frames.empty()) return 1.0f;
        float total = 0;
        for (const auto& frame : clip.frames) {
            total += frame.duration;
        }
        return total > 0 ? total : 1.0f;
    }

    // Helper to get state duration
    static float GetStateDuration(const AnimController& ctrl, int stateId) {
        auto stateIt = ctrl.states.find(stateId);
        if (stateIt == ctrl.states.end()) return 1.0f;

        const AnimState& state = stateIt->second;
        if (state.type == ANIM_STATE_SINGLE && state.animClipId >= 0) {
            auto clipIt = g_animClips.find(state.animClipId);
            if (clipIt != g_animClips.end()) {
                return CalcClipDuration(clipIt->second);
            }
        }
        // For blend states, use average duration
        if (!state.blendClips.empty()) {
            float total = 0;
            for (const auto& bc : state.blendClips) {
                auto clipIt = g_animClips.find(bc.animClipId);
                if (clipIt != g_animClips.end()) {
                    total += CalcClipDuration(clipIt->second);
                }
            }
            return total / state.blendClips.size();
        }
        return 1.0f;
    }

    // Helper to get parameter value from instance or controller
    static float GetParamFloat(const AnimControllerInstance& inst, const AnimController& ctrl, const std::string& name, float def) {
        auto it = inst.localParams.find(name);
        if (it != inst.localParams.end() && it->second.type == AnimParameter::FLOAT) {
            return it->second.floatValue;
        }
        auto it2 = ctrl.parameters.find(name);
        if (it2 != ctrl.parameters.end() && it2->second.type == AnimParameter::FLOAT) {
            return it2->second.floatValue;
        }
        return def;
    }

    static int GetParamInt(const AnimControllerInstance& inst, const AnimController& ctrl, const std::string& name, int def) {
        auto it = inst.localParams.find(name);
        if (it != inst.localParams.end() && it->second.type == AnimParameter::INT) {
            return it->second.intValue;
        }
        auto it2 = ctrl.parameters.find(name);
        if (it2 != ctrl.parameters.end() && it2->second.type == AnimParameter::INT) {
            return it2->second.intValue;
        }
        return def;
    }

    static bool GetParamBool(const AnimControllerInstance& inst, const AnimController& ctrl, const std::string& name, bool def) {
        auto it = inst.localParams.find(name);
        if (it != inst.localParams.end() && it->second.type == AnimParameter::BOOL) {
            return it->second.boolValue;
        }
        auto it2 = ctrl.parameters.find(name);
        if (it2 != ctrl.parameters.end() && it2->second.type == AnimParameter::BOOL) {
            return it2->second.boolValue;
        }
        return def;
    }

    static bool GetParamTrigger(AnimControllerInstance& inst, AnimController& ctrl, const std::string& name) {
        // Check local triggers first
        auto it = inst.localParams.find(name);
        if (it != inst.localParams.end() && it->second.type == AnimParameter::TRIGGER) {
            if (it->second.triggered) {
                it->second.triggered = false;  // Consume trigger
                return true;
            }
        }
        // Check controller triggers
        auto it2 = ctrl.parameters.find(name);
        if (it2 != ctrl.parameters.end() && it2->second.type == AnimParameter::TRIGGER) {
            if (it2->second.triggered) {
                it2->second.triggered = false;  // Consume trigger
                return true;
            }
        }
        return false;
    }

    // Check if a transition should fire
    static bool CheckTransitionConditions(AnimControllerInstance& inst, AnimController& ctrl, const AnimTransition& trans, float normalizedTime) {
        // Check exit time
        if (trans.hasExitTime && normalizedTime < trans.exitTime) {
            return false;
        }

        // Check all conditions (AND)
        for (const auto& cond : trans.conditions) {
            if (cond.isTrigger) {
                if (!GetParamTrigger(inst, ctrl, cond.paramName)) {
                    return false;
                }
            } else {
                float val = GetParamFloat(inst, ctrl, cond.paramName, 0.0f);
                bool satisfied = false;

                switch (cond.type) {
                case ANIM_COND_GREATER:
                    satisfied = val > cond.threshold;
                    break;
                case ANIM_COND_LESS:
                    satisfied = val < cond.threshold;
                    break;
                case ANIM_COND_EQUALS:
                    satisfied = fabsf(val - cond.threshold) < 0.001f;
                    break;
                case ANIM_COND_NOT_EQUALS:
                    satisfied = fabsf(val - cond.threshold) >= 0.001f;
                    break;
                case ANIM_COND_TRUE:
                    satisfied = GetParamBool(inst, ctrl, cond.paramName, false);
                    break;
                case ANIM_COND_FALSE:
                    satisfied = !GetParamBool(inst, ctrl, cond.paramName, true);
                    break;
                }

                if (!satisfied) return false;
            }
        }

        return true;
    }

    // Controller management
    int Framework_AnimCtrl_Create(const char* name) {
        AnimController ctrl;
        ctrl.id = g_nextAnimControllerId++;
        ctrl.name = name ? name : "";
        g_animControllers[ctrl.id] = ctrl;
        return ctrl.id;
    }

    void Framework_AnimCtrl_Destroy(int controllerId) {
        g_animControllers.erase(controllerId);
    }

    int Framework_AnimCtrl_Get(const char* name) {
        if (!name) return -1;
        for (const auto& pair : g_animControllers) {
            if (pair.second.name == name) return pair.first;
        }
        return -1;
    }

    bool Framework_AnimCtrl_IsValid(int controllerId) {
        return g_animControllers.find(controllerId) != g_animControllers.end();
    }

    int Framework_AnimCtrl_Clone(int controllerId, const char* newName) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return -1;

        AnimController clone = it->second;
        clone.id = g_nextAnimControllerId++;
        clone.name = newName ? newName : "";
        g_animControllers[clone.id] = clone;
        return clone.id;
    }

    // State management
    int Framework_AnimCtrl_AddState(int controllerId, const char* stateName, int animClipId) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return -1;

        AnimState state;
        state.id = it->second.nextStateId++;
        state.name = stateName ? stateName : "";
        state.type = ANIM_STATE_SINGLE;
        state.animClipId = animClipId;
        it->second.states[state.id] = state;

        // Set as default if first state
        if (it->second.defaultState < 0) {
            it->second.defaultState = state.id;
        }

        return state.id;
    }

    int Framework_AnimCtrl_AddBlendState1D(int controllerId, const char* stateName, const char* paramName) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return -1;

        AnimState state;
        state.id = it->second.nextStateId++;
        state.name = stateName ? stateName : "";
        state.type = ANIM_STATE_BLEND_1D;
        state.animClipId = -1;
        state.blendParamX = paramName ? paramName : "";
        it->second.states[state.id] = state;

        if (it->second.defaultState < 0) {
            it->second.defaultState = state.id;
        }

        return state.id;
    }

    int Framework_AnimCtrl_AddBlendState2D(int controllerId, const char* stateName, const char* paramX, const char* paramY) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return -1;

        AnimState state;
        state.id = it->second.nextStateId++;
        state.name = stateName ? stateName : "";
        state.type = ANIM_STATE_BLEND_2D;
        state.animClipId = -1;
        state.blendParamX = paramX ? paramX : "";
        state.blendParamY = paramY ? paramY : "";
        it->second.states[state.id] = state;

        if (it->second.defaultState < 0) {
            it->second.defaultState = state.id;
        }

        return state.id;
    }

    void Framework_AnimCtrl_RemoveState(int controllerId, int stateId) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return;
        it->second.states.erase(stateId);
    }

    int Framework_AnimCtrl_GetState(int controllerId, const char* stateName) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end() || !stateName) return -1;
        for (const auto& pair : it->second.states) {
            if (pair.second.name == stateName) return pair.first;
        }
        return -1;
    }

    int Framework_AnimCtrl_GetStateCount(int controllerId) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return 0;
        return (int)it->second.states.size();
    }

    void Framework_AnimCtrl_SetDefaultState(int controllerId, int stateId) {
        auto it = g_animControllers.find(controllerId);
        if (it != g_animControllers.end()) {
            it->second.defaultState = stateId;
        }
    }

    int Framework_AnimCtrl_GetDefaultState(int controllerId) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return -1;
        return it->second.defaultState;
    }

    // Blend state configuration
    void Framework_AnimCtrl_AddBlendClip(int controllerId, int stateId, int animClipId, float threshold) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return;

        auto stateIt = it->second.states.find(stateId);
        if (stateIt == it->second.states.end()) return;

        AnimBlendClip clip;
        clip.animClipId = animClipId;
        clip.threshold = threshold;
        clip.x = threshold;
        clip.y = 0;
        stateIt->second.blendClips.push_back(clip);
    }

    void Framework_AnimCtrl_AddBlendClip2D(int controllerId, int stateId, int animClipId, float x, float y) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return;

        auto stateIt = it->second.states.find(stateId);
        if (stateIt == it->second.states.end()) return;

        AnimBlendClip clip;
        clip.animClipId = animClipId;
        clip.threshold = 0;
        clip.x = x;
        clip.y = y;
        stateIt->second.blendClips.push_back(clip);
    }

    int Framework_AnimCtrl_GetBlendClipCount(int controllerId, int stateId) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return 0;

        auto stateIt = it->second.states.find(stateId);
        if (stateIt == it->second.states.end()) return 0;

        return (int)stateIt->second.blendClips.size();
    }

    // State properties
    void Framework_AnimCtrl_SetStateSpeed(int controllerId, int stateId, float speed) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return;

        auto stateIt = it->second.states.find(stateId);
        if (stateIt != it->second.states.end()) {
            stateIt->second.speed = speed;
        }
    }

    float Framework_AnimCtrl_GetStateSpeed(int controllerId, int stateId) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return 1.0f;

        auto stateIt = it->second.states.find(stateId);
        if (stateIt == it->second.states.end()) return 1.0f;

        return stateIt->second.speed;
    }

    void Framework_AnimCtrl_SetStateLoop(int controllerId, int stateId, bool loop) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return;

        auto stateIt = it->second.states.find(stateId);
        if (stateIt != it->second.states.end()) {
            stateIt->second.loop = loop;
        }
    }

    bool Framework_AnimCtrl_GetStateLoop(int controllerId, int stateId) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return true;

        auto stateIt = it->second.states.find(stateId);
        if (stateIt == it->second.states.end()) return true;

        return stateIt->second.loop;
    }

    // Transition management
    int Framework_AnimCtrl_AddTransition(int controllerId, int fromState, int toState, float duration) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return -1;

        AnimTransition trans;
        trans.id = it->second.nextTransitionId++;
        trans.fromState = fromState;
        trans.toState = toState;
        trans.duration = duration;
        trans.hasExitTime = false;
        trans.exitTime = 1.0f;
        it->second.transitions[trans.id] = trans;

        return trans.id;
    }

    void Framework_AnimCtrl_RemoveTransition(int controllerId, int transitionId) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return;
        it->second.transitions.erase(transitionId);
    }

    int Framework_AnimCtrl_GetTransitionCount(int controllerId) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return 0;
        return (int)it->second.transitions.size();
    }

    void Framework_AnimCtrl_SetTransitionDuration(int controllerId, int transitionId, float duration) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return;

        auto transIt = it->second.transitions.find(transitionId);
        if (transIt != it->second.transitions.end()) {
            transIt->second.duration = duration;
        }
    }

    float Framework_AnimCtrl_GetTransitionDuration(int controllerId, int transitionId) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return 0.0f;

        auto transIt = it->second.transitions.find(transitionId);
        if (transIt == it->second.transitions.end()) return 0.0f;

        return transIt->second.duration;
    }

    int Framework_AnimCtrl_AddAnyStateTransition(int controllerId, int toState, float duration) {
        return Framework_AnimCtrl_AddTransition(controllerId, -1, toState, duration);
    }

    // Transition conditions
    void Framework_AnimCtrl_AddCondition(int controllerId, int transitionId, const char* paramName, int conditionType, float threshold) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return;

        auto transIt = it->second.transitions.find(transitionId);
        if (transIt == it->second.transitions.end()) return;

        AnimCondition cond;
        cond.paramName = paramName ? paramName : "";
        cond.type = (AnimConditionType)conditionType;
        cond.threshold = threshold;
        cond.boolValue = threshold > 0.5f;
        cond.isTrigger = false;
        transIt->second.conditions.push_back(cond);
    }

    void Framework_AnimCtrl_AddBoolCondition(int controllerId, int transitionId, const char* paramName, bool value) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return;

        auto transIt = it->second.transitions.find(transitionId);
        if (transIt == it->second.transitions.end()) return;

        AnimCondition cond;
        cond.paramName = paramName ? paramName : "";
        cond.type = value ? ANIM_COND_TRUE : ANIM_COND_FALSE;
        cond.threshold = 0;
        cond.boolValue = value;
        cond.isTrigger = false;
        transIt->second.conditions.push_back(cond);
    }

    void Framework_AnimCtrl_AddTriggerCondition(int controllerId, int transitionId, const char* triggerName) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return;

        auto transIt = it->second.transitions.find(transitionId);
        if (transIt == it->second.transitions.end()) return;

        AnimCondition cond;
        cond.paramName = triggerName ? triggerName : "";
        cond.type = ANIM_COND_TRUE;
        cond.threshold = 0;
        cond.boolValue = true;
        cond.isTrigger = true;
        transIt->second.conditions.push_back(cond);
    }

    void Framework_AnimCtrl_ClearConditions(int controllerId, int transitionId) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return;

        auto transIt = it->second.transitions.find(transitionId);
        if (transIt != it->second.transitions.end()) {
            transIt->second.conditions.clear();
        }
    }

    int Framework_AnimCtrl_GetConditionCount(int controllerId, int transitionId) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return 0;

        auto transIt = it->second.transitions.find(transitionId);
        if (transIt == it->second.transitions.end()) return 0;

        return (int)transIt->second.conditions.size();
    }

    void Framework_AnimCtrl_SetExitTime(int controllerId, int transitionId, bool hasExitTime, float exitTimeNormalized) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return;

        auto transIt = it->second.transitions.find(transitionId);
        if (transIt != it->second.transitions.end()) {
            transIt->second.hasExitTime = hasExitTime;
            transIt->second.exitTime = exitTimeNormalized;
        }
    }

    bool Framework_AnimCtrl_HasExitTime(int controllerId, int transitionId) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end()) return false;

        auto transIt = it->second.transitions.find(transitionId);
        if (transIt == it->second.transitions.end()) return false;

        return transIt->second.hasExitTime;
    }

    // Parameters
    void Framework_AnimCtrl_SetFloat(int controllerId, const char* paramName, float value) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end() || !paramName) return;

        AnimParameter& param = it->second.parameters[paramName];
        param.type = AnimParameter::FLOAT;
        param.floatValue = value;
    }

    float Framework_AnimCtrl_GetFloat(int controllerId, const char* paramName, float defaultValue) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end() || !paramName) return defaultValue;

        auto paramIt = it->second.parameters.find(paramName);
        if (paramIt == it->second.parameters.end()) return defaultValue;
        if (paramIt->second.type != AnimParameter::FLOAT) return defaultValue;

        return paramIt->second.floatValue;
    }

    void Framework_AnimCtrl_SetInt(int controllerId, const char* paramName, int value) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end() || !paramName) return;

        AnimParameter& param = it->second.parameters[paramName];
        param.type = AnimParameter::INT;
        param.intValue = value;
    }

    int Framework_AnimCtrl_GetInt(int controllerId, const char* paramName, int defaultValue) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end() || !paramName) return defaultValue;

        auto paramIt = it->second.parameters.find(paramName);
        if (paramIt == it->second.parameters.end()) return defaultValue;
        if (paramIt->second.type != AnimParameter::INT) return defaultValue;

        return paramIt->second.intValue;
    }

    void Framework_AnimCtrl_SetBool(int controllerId, const char* paramName, bool value) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end() || !paramName) return;

        AnimParameter& param = it->second.parameters[paramName];
        param.type = AnimParameter::BOOL;
        param.boolValue = value;
    }

    bool Framework_AnimCtrl_GetBool(int controllerId, const char* paramName, bool defaultValue) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end() || !paramName) return defaultValue;

        auto paramIt = it->second.parameters.find(paramName);
        if (paramIt == it->second.parameters.end()) return defaultValue;
        if (paramIt->second.type != AnimParameter::BOOL) return defaultValue;

        return paramIt->second.boolValue;
    }

    void Framework_AnimCtrl_SetTrigger(int controllerId, const char* triggerName) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end() || !triggerName) return;

        AnimParameter& param = it->second.parameters[triggerName];
        param.type = AnimParameter::TRIGGER;
        param.triggered = true;
    }

    void Framework_AnimCtrl_ResetTrigger(int controllerId, const char* triggerName) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end() || !triggerName) return;

        auto paramIt = it->second.parameters.find(triggerName);
        if (paramIt != it->second.parameters.end()) {
            paramIt->second.triggered = false;
        }
    }

    bool Framework_AnimCtrl_HasParameter(int controllerId, const char* paramName) {
        auto it = g_animControllers.find(controllerId);
        if (it == g_animControllers.end() || !paramName) return false;
        return it->second.parameters.find(paramName) != it->second.parameters.end();
    }

    // Instance management
    int Framework_AnimCtrl_CreateInstance(int controllerId, int entityId) {
        auto ctrlIt = g_animControllers.find(controllerId);
        if (ctrlIt == g_animControllers.end()) return -1;

        AnimControllerInstance inst;
        inst.id = g_nextAnimInstanceId++;
        inst.controllerId = controllerId;
        inst.entityId = entityId;
        inst.currentState = ctrlIt->second.defaultState;
        inst.targetState = -1;
        inst.stateTime = 0;
        inst.transitionTime = 0;
        inst.transitionDuration = 0;
        inst.inTransition = false;
        inst.paused = false;
        inst.speed = 1.0f;
        g_animInstances[inst.id] = inst;

        return inst.id;
    }

    void Framework_AnimCtrl_DestroyInstance(int instanceId) {
        g_animInstances.erase(instanceId);
    }

    bool Framework_AnimCtrl_IsInstanceValid(int instanceId) {
        return g_animInstances.find(instanceId) != g_animInstances.end();
    }

    // Instance state
    void Framework_AnimCtrl_UpdateInstance(int instanceId, float dt) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end()) return;

        AnimControllerInstance& inst = instIt->second;
        if (inst.paused) return;

        auto ctrlIt = g_animControllers.find(inst.controllerId);
        if (ctrlIt == g_animControllers.end()) return;

        AnimController& ctrl = ctrlIt->second;

        float scaledDt = dt * inst.speed;

        // Handle transition
        if (inst.inTransition && inst.transitionDuration > 0) {
            inst.transitionTime += scaledDt;
            if (inst.transitionTime >= inst.transitionDuration) {
                // Transition complete
                if (ctrl.onStateExit && inst.currentState >= 0) {
                    ctrl.onStateExit(inst.id, inst.currentState, ctrl.callbackUserData);
                }
                inst.currentState = inst.targetState;
                inst.targetState = -1;
                inst.inTransition = false;
                inst.stateTime = 0;
                if (ctrl.onStateEnter && inst.currentState >= 0) {
                    ctrl.onStateEnter(inst.id, inst.currentState, ctrl.callbackUserData);
                }
            }
        } else {
            // Update state time
            auto stateIt = ctrl.states.find(inst.currentState);
            if (stateIt != ctrl.states.end()) {
                float duration = GetStateDuration(ctrl, inst.currentState);
                float stateSpeed = stateIt->second.speed;
                inst.stateTime += scaledDt * stateSpeed;

                // Handle looping
                if (stateIt->second.loop && duration > 0 && inst.stateTime >= duration) {
                    inst.stateTime = fmodf(inst.stateTime, duration);
                }
            }

            // Check transitions
            float normalizedTime = 0;
            if (inst.currentState >= 0) {
                float duration = GetStateDuration(ctrl, inst.currentState);
                if (duration > 0) {
                    normalizedTime = inst.stateTime / duration;
                }
            }

            for (auto& transPair : ctrl.transitions) {
                AnimTransition& trans = transPair.second;

                // Check if transition applies (from current state or any-state)
                if (trans.fromState != inst.currentState && trans.fromState != -1) continue;

                // Check conditions
                if (CheckTransitionConditions(inst, ctrl, trans, normalizedTime)) {
                    // Start transition
                    inst.targetState = trans.toState;
                    inst.transitionTime = 0;
                    inst.transitionDuration = trans.duration;
                    inst.inTransition = true;
                    break;
                }
            }
        }
    }

    int Framework_AnimCtrl_GetCurrentState(int instanceId) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end()) return -1;
        return instIt->second.currentState;
    }

    static std::string g_animStateNameBuffer;
    const char* Framework_AnimCtrl_GetCurrentStateName(int instanceId) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end()) return "";

        auto ctrlIt = g_animControllers.find(instIt->second.controllerId);
        if (ctrlIt == g_animControllers.end()) return "";

        auto stateIt = ctrlIt->second.states.find(instIt->second.currentState);
        if (stateIt == ctrlIt->second.states.end()) return "";

        g_animStateNameBuffer = stateIt->second.name;
        return g_animStateNameBuffer.c_str();
    }

    bool Framework_AnimCtrl_IsInTransition(int instanceId) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end()) return false;
        return instIt->second.inTransition;
    }

    float Framework_AnimCtrl_GetTransitionProgress(int instanceId) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end()) return 0.0f;

        if (!instIt->second.inTransition || instIt->second.transitionDuration <= 0) return 0.0f;
        return instIt->second.transitionTime / instIt->second.transitionDuration;
    }

    float Framework_AnimCtrl_GetNormalizedTime(int instanceId) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end()) return 0.0f;

        auto ctrlIt = g_animControllers.find(instIt->second.controllerId);
        if (ctrlIt == g_animControllers.end()) return 0.0f;

        float duration = GetStateDuration(ctrlIt->second, instIt->second.currentState);
        if (duration <= 0) return 0.0f;

        return instIt->second.stateTime / duration;
    }

    // Instance parameters
    void Framework_AnimCtrl_InstanceSetFloat(int instanceId, const char* paramName, float value) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end() || !paramName) return;

        AnimParameter& param = instIt->second.localParams[paramName];
        param.type = AnimParameter::FLOAT;
        param.floatValue = value;
    }

    float Framework_AnimCtrl_InstanceGetFloat(int instanceId, const char* paramName, float defaultValue) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end() || !paramName) return defaultValue;

        auto paramIt = instIt->second.localParams.find(paramName);
        if (paramIt == instIt->second.localParams.end()) return defaultValue;
        if (paramIt->second.type != AnimParameter::FLOAT) return defaultValue;

        return paramIt->second.floatValue;
    }

    void Framework_AnimCtrl_InstanceSetInt(int instanceId, const char* paramName, int value) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end() || !paramName) return;

        AnimParameter& param = instIt->second.localParams[paramName];
        param.type = AnimParameter::INT;
        param.intValue = value;
    }

    int Framework_AnimCtrl_InstanceGetInt(int instanceId, const char* paramName, int defaultValue) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end() || !paramName) return defaultValue;

        auto paramIt = instIt->second.localParams.find(paramName);
        if (paramIt == instIt->second.localParams.end()) return defaultValue;
        if (paramIt->second.type != AnimParameter::INT) return defaultValue;

        return paramIt->second.intValue;
    }

    void Framework_AnimCtrl_InstanceSetBool(int instanceId, const char* paramName, bool value) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end() || !paramName) return;

        AnimParameter& param = instIt->second.localParams[paramName];
        param.type = AnimParameter::BOOL;
        param.boolValue = value;
    }

    bool Framework_AnimCtrl_InstanceGetBool(int instanceId, const char* paramName, bool defaultValue) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end() || !paramName) return defaultValue;

        auto paramIt = instIt->second.localParams.find(paramName);
        if (paramIt == instIt->second.localParams.end()) return defaultValue;
        if (paramIt->second.type != AnimParameter::BOOL) return defaultValue;

        return paramIt->second.boolValue;
    }

    void Framework_AnimCtrl_InstanceSetTrigger(int instanceId, const char* triggerName) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end() || !triggerName) return;

        AnimParameter& param = instIt->second.localParams[triggerName];
        param.type = AnimParameter::TRIGGER;
        param.triggered = true;
    }

    void Framework_AnimCtrl_InstanceResetTrigger(int instanceId, const char* triggerName) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end() || !triggerName) return;

        auto paramIt = instIt->second.localParams.find(triggerName);
        if (paramIt != instIt->second.localParams.end()) {
            paramIt->second.triggered = false;
        }
    }

    // Force state change
    void Framework_AnimCtrl_ForceState(int instanceId, int stateId) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end()) return;

        instIt->second.currentState = stateId;
        instIt->second.targetState = -1;
        instIt->second.stateTime = 0;
        instIt->second.inTransition = false;
    }

    void Framework_AnimCtrl_CrossFade(int instanceId, int stateId, float duration) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end()) return;

        instIt->second.targetState = stateId;
        instIt->second.transitionTime = 0;
        instIt->second.transitionDuration = duration;
        instIt->second.inTransition = true;
    }

    // Playback control
    void Framework_AnimCtrl_Pause(int instanceId) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt != g_animInstances.end()) {
            instIt->second.paused = true;
        }
    }

    void Framework_AnimCtrl_Resume(int instanceId) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt != g_animInstances.end()) {
            instIt->second.paused = false;
        }
    }

    bool Framework_AnimCtrl_IsPaused(int instanceId) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end()) return false;
        return instIt->second.paused;
    }

    void Framework_AnimCtrl_SetSpeed(int instanceId, float speed) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt != g_animInstances.end()) {
            instIt->second.speed = speed;
        }
    }

    float Framework_AnimCtrl_GetSpeed(int instanceId) {
        auto instIt = g_animInstances.find(instanceId);
        if (instIt == g_animInstances.end()) return 1.0f;
        return instIt->second.speed;
    }

    // Callbacks
    void Framework_AnimCtrl_SetOnStateEnter(int controllerId, AnimStateCallback callback, void* userData) {
        auto it = g_animControllers.find(controllerId);
        if (it != g_animControllers.end()) {
            it->second.onStateEnter = callback;
            it->second.callbackUserData = userData;
        }
    }

    void Framework_AnimCtrl_SetOnStateExit(int controllerId, AnimStateCallback callback, void* userData) {
        auto it = g_animControllers.find(controllerId);
        if (it != g_animControllers.end()) {
            it->second.onStateExit = callback;
            it->second.callbackUserData = userData;
        }
    }

    // Debug
    int Framework_AnimCtrl_GetControllerCount() {
        return (int)g_animControllers.size();
    }

    int Framework_AnimCtrl_GetInstanceCount() {
        return (int)g_animInstances.size();
    }

    // ========================================================================
    // AUDIO MANAGER - Advanced Audio System Implementation
    // ========================================================================

    // Audio group state
    struct AudioGroupState {
        float volume = 1.0f;
        float targetVolume = 1.0f;
        float fadeSpeed = 0.0f;
        bool muted = false;
    };
    static AudioGroupState g_audioGroups[AUDIO_GROUP_COUNT];

    // Managed sound with group
    struct ManagedSound {
        Sound sound;
        int group = AUDIO_GROUP_SFX;
        float baseVolume = 1.0f;
        bool valid = false;
    };
    static std::unordered_map<int, ManagedSound> g_managedSounds;
    static int g_nextSoundHandle = 1;

    // Managed music with advanced features
    struct ManagedMusic {
        Music music;
        float baseVolume = 1.0f;
        float targetVolume = 1.0f;
        float fadeSpeed = 0.0f;
        bool looping = true;
        bool valid = false;
        bool playing = false;
    };
    static std::unordered_map<int, ManagedMusic> g_managedMusic;
    // Note: g_nextMusicHandle is defined in the anonymous namespace above

    // Sound pool for frequent sounds
    struct SoundPool {
        std::vector<Sound> sounds;
        int nextIndex = 0;
        int group = AUDIO_GROUP_SFX;
        bool valid = false;
    };
    static std::unordered_map<int, SoundPool> g_soundPools;
    static int g_nextPoolHandle = 1;

    // Playlist
    struct Playlist {
        std::vector<int> tracks;  // Music handles
        int currentIndex = 0;
        bool shuffle = false;
        int repeatMode = 1;  // 0=none, 1=all, 2=one
        float crossfadeDuration = 0.0f;
        bool playing = false;
        bool valid = false;
        std::vector<int> shuffleOrder;
    };
    static std::unordered_map<int, Playlist> g_playlists;
    static int g_nextPlaylistHandle = 1;
    static int g_activePlaylist = -1;

    // Spatial audio
    static float g_listenerX = 0.0f;
    static float g_listenerY = 0.0f;
    static float g_spatialMinDist = 100.0f;
    static float g_spatialMaxDist = 1000.0f;
    static bool g_spatialEnabled = true;

    // Crossfade state
    static int g_crossfadeFrom = -1;
    static int g_crossfadeTo = -1;
    static float g_crossfadeProgress = 0.0f;
    static float g_crossfadeDuration = 0.0f;

    // Helper: Calculate effective volume for a group
    static float Audio_GetEffectiveVolume(int group, float baseVolume) {
        if (group < 0 || group >= AUDIO_GROUP_COUNT) return baseVolume;

        float groupVol = g_audioGroups[group].muted ? 0.0f : g_audioGroups[group].volume;
        float masterVol = g_audioGroups[AUDIO_GROUP_MASTER].muted ? 0.0f : g_audioGroups[AUDIO_GROUP_MASTER].volume;

        return baseVolume * groupVol * masterVol;
    }

    // Helper: Calculate spatial pan and volume
    static void Audio_CalculateSpatial(float soundX, float soundY, float& outVolume, float& outPan) {
        if (!g_spatialEnabled) {
            outVolume = 1.0f;
            outPan = 0.5f;
            return;
        }

        float dx = soundX - g_listenerX;
        float dy = soundY - g_listenerY;
        float distance = sqrtf(dx * dx + dy * dy);

        // Volume falloff
        if (distance <= g_spatialMinDist) {
            outVolume = 1.0f;
        } else if (distance >= g_spatialMaxDist) {
            outVolume = 0.0f;
        } else {
            float t = (distance - g_spatialMinDist) / (g_spatialMaxDist - g_spatialMinDist);
            outVolume = 1.0f - t;
        }

        // Pan based on x position (-1 to 1, then convert to 0-1)
        float screenWidth = (float)GetScreenWidth();
        if (screenWidth > 0 && distance > 0.01f) {
            float normalizedX = dx / fmaxf(distance, g_spatialMaxDist);
            outPan = 0.5f + normalizedX * 0.5f;
            outPan = fmaxf(0.0f, fminf(1.0f, outPan));
        } else {
            outPan = 0.5f;
        }
    }

    // Group volume control
    void Framework_Audio_SetGroupVolume(int group, float volume) {
        if (group >= 0 && group < AUDIO_GROUP_COUNT) {
            g_audioGroups[group].volume = fmaxf(0.0f, fminf(1.0f, volume));
            g_audioGroups[group].targetVolume = g_audioGroups[group].volume;
            g_audioGroups[group].fadeSpeed = 0.0f;
        }
    }

    float Framework_Audio_GetGroupVolume(int group) {
        if (group >= 0 && group < AUDIO_GROUP_COUNT) {
            return g_audioGroups[group].volume;
        }
        return 0.0f;
    }

    void Framework_Audio_SetGroupMuted(int group, bool muted) {
        if (group >= 0 && group < AUDIO_GROUP_COUNT) {
            g_audioGroups[group].muted = muted;
        }
    }

    bool Framework_Audio_IsGroupMuted(int group) {
        if (group >= 0 && group < AUDIO_GROUP_COUNT) {
            return g_audioGroups[group].muted;
        }
        return false;
    }

    void Framework_Audio_FadeGroupVolume(int group, float targetVolume, float duration) {
        if (group >= 0 && group < AUDIO_GROUP_COUNT && duration > 0.0f) {
            g_audioGroups[group].targetVolume = fmaxf(0.0f, fminf(1.0f, targetVolume));
            g_audioGroups[group].fadeSpeed = (g_audioGroups[group].targetVolume - g_audioGroups[group].volume) / duration;
        }
    }

    // Sound with group assignment
    int Framework_Audio_LoadSound(const char* path, int group) {
        if (!path) return -1;

        Sound snd = LoadSound(path);
        if (!IsSoundValid(snd)) return -1;

        int handle = g_nextSoundHandle++;
        ManagedSound ms;
        ms.sound = snd;
        ms.group = (group >= 0 && group < AUDIO_GROUP_COUNT) ? group : AUDIO_GROUP_SFX;
        ms.baseVolume = 1.0f;
        ms.valid = true;
        g_managedSounds[handle] = ms;
        return handle;
    }

    void Framework_Audio_UnloadSound(int handle) {
        auto it = g_managedSounds.find(handle);
        if (it != g_managedSounds.end() && it->second.valid) {
            UnloadSound(it->second.sound);
            g_managedSounds.erase(it);
        }
    }

    void Framework_Audio_PlaySound(int handle) {
        auto it = g_managedSounds.find(handle);
        if (it != g_managedSounds.end() && it->second.valid) {
            float vol = Audio_GetEffectiveVolume(it->second.group, it->second.baseVolume);
            SetSoundVolume(it->second.sound, vol);
            PlaySound(it->second.sound);
        }
    }

    void Framework_Audio_PlaySoundEx(int handle, float volume, float pitch, float pan) {
        auto it = g_managedSounds.find(handle);
        if (it != g_managedSounds.end() && it->second.valid) {
            float vol = Audio_GetEffectiveVolume(it->second.group, volume);
            SetSoundVolume(it->second.sound, vol);
            SetSoundPitch(it->second.sound, pitch);
            SetSoundPan(it->second.sound, pan);
            PlaySound(it->second.sound);
        }
    }

    void Framework_Audio_StopSound(int handle) {
        auto it = g_managedSounds.find(handle);
        if (it != g_managedSounds.end() && it->second.valid) {
            StopSound(it->second.sound);
        }
    }

    void Framework_Audio_SetSoundGroup(int handle, int group) {
        auto it = g_managedSounds.find(handle);
        if (it != g_managedSounds.end() && group >= 0 && group < AUDIO_GROUP_COUNT) {
            it->second.group = group;
        }
    }

    int Framework_Audio_GetSoundGroup(int handle) {
        auto it = g_managedSounds.find(handle);
        return (it != g_managedSounds.end()) ? it->second.group : -1;
    }

    // Spatial audio
    void Framework_Audio_SetListenerPosition(float x, float y) {
        g_listenerX = x;
        g_listenerY = y;
    }

    void Framework_Audio_GetListenerPosition(float* x, float* y) {
        if (x) *x = g_listenerX;
        if (y) *y = g_listenerY;
    }

    void Framework_Audio_PlaySoundAt(int handle, float x, float y) {
        Framework_Audio_PlaySoundAtEx(handle, x, y, 1.0f, 1.0f);
    }

    void Framework_Audio_PlaySoundAtEx(int handle, float x, float y, float volume, float pitch) {
        auto it = g_managedSounds.find(handle);
        if (it != g_managedSounds.end() && it->second.valid) {
            float spatialVol, pan;
            Audio_CalculateSpatial(x, y, spatialVol, pan);

            float finalVol = Audio_GetEffectiveVolume(it->second.group, volume * spatialVol);
            SetSoundVolume(it->second.sound, finalVol);
            SetSoundPitch(it->second.sound, pitch);
            SetSoundPan(it->second.sound, pan);
            PlaySound(it->second.sound);
        }
    }

    void Framework_Audio_SetSpatialFalloff(float minDist, float maxDist) {
        g_spatialMinDist = fmaxf(1.0f, minDist);
        g_spatialMaxDist = fmaxf(g_spatialMinDist + 1.0f, maxDist);
    }

    void Framework_Audio_SetSpatialEnabled(bool enabled) {
        g_spatialEnabled = enabled;
    }

    // Sound pooling
    int Framework_Audio_CreatePool(const char* path, int poolSize, int group) {
        if (!path || poolSize <= 0) return -1;

        SoundPool pool;
        pool.group = (group >= 0 && group < AUDIO_GROUP_COUNT) ? group : AUDIO_GROUP_SFX;
        pool.valid = true;

        for (int i = 0; i < poolSize; i++) {
            Sound snd = LoadSound(path);
            if (IsSoundValid(snd)) {
                pool.sounds.push_back(snd);
            }
        }

        if (pool.sounds.empty()) return -1;

        int handle = g_nextPoolHandle++;
        g_soundPools[handle] = pool;
        return handle;
    }

    void Framework_Audio_DestroyPool(int poolHandle) {
        auto it = g_soundPools.find(poolHandle);
        if (it != g_soundPools.end()) {
            for (auto& snd : it->second.sounds) {
                UnloadSound(snd);
            }
            g_soundPools.erase(it);
        }
    }

    void Framework_Audio_PlayFromPool(int poolHandle) {
        auto it = g_soundPools.find(poolHandle);
        if (it == g_soundPools.end() || !it->second.valid || it->second.sounds.empty()) return;

        SoundPool& pool = it->second;
        Sound& snd = pool.sounds[pool.nextIndex];

        float vol = Audio_GetEffectiveVolume(pool.group, 1.0f);
        SetSoundVolume(snd, vol);
        SetSoundPan(snd, 0.5f);
        PlaySound(snd);

        pool.nextIndex = (pool.nextIndex + 1) % (int)pool.sounds.size();
    }

    void Framework_Audio_PlayFromPoolAt(int poolHandle, float x, float y) {
        auto it = g_soundPools.find(poolHandle);
        if (it == g_soundPools.end() || !it->second.valid || it->second.sounds.empty()) return;

        SoundPool& pool = it->second;
        Sound& snd = pool.sounds[pool.nextIndex];

        float spatialVol, pan;
        Audio_CalculateSpatial(x, y, spatialVol, pan);

        float vol = Audio_GetEffectiveVolume(pool.group, spatialVol);
        SetSoundVolume(snd, vol);
        SetSoundPan(snd, pan);
        PlaySound(snd);

        pool.nextIndex = (pool.nextIndex + 1) % (int)pool.sounds.size();
    }

    void Framework_Audio_PlayFromPoolEx(int poolHandle, float volume, float pitch, float pan) {
        auto it = g_soundPools.find(poolHandle);
        if (it == g_soundPools.end() || !it->second.valid || it->second.sounds.empty()) return;

        SoundPool& pool = it->second;
        Sound& snd = pool.sounds[pool.nextIndex];

        float vol = Audio_GetEffectiveVolume(pool.group, volume);
        SetSoundVolume(snd, vol);
        SetSoundPitch(snd, pitch);
        SetSoundPan(snd, pan);
        PlaySound(snd);

        pool.nextIndex = (pool.nextIndex + 1) % (int)pool.sounds.size();
    }

    void Framework_Audio_StopPool(int poolHandle) {
        auto it = g_soundPools.find(poolHandle);
        if (it != g_soundPools.end()) {
            for (auto& snd : it->second.sounds) {
                StopSound(snd);
            }
        }
    }

    // Music with advanced features
    int Framework_Audio_LoadMusic(const char* path) {
        if (!path) return -1;

        Music mus = LoadMusicStream(path);
        if (!IsMusicValid(mus)) return -1;

        int handle = g_nextMusicHandle++;
        ManagedMusic mm;
        mm.music = mus;
        mm.baseVolume = 1.0f;
        mm.targetVolume = 1.0f;
        mm.looping = true;
        mm.valid = true;
        mm.playing = false;
        g_managedMusic[handle] = mm;
        return handle;
    }

    void Framework_Audio_UnloadMusic(int handle) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid) {
            StopMusicStream(it->second.music);
            UnloadMusicStream(it->second.music);
            g_managedMusic.erase(it);
        }
    }

    void Framework_Audio_PlayMusic(int handle) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid) {
            it->second.music.looping = it->second.looping;
            float vol = Audio_GetEffectiveVolume(AUDIO_GROUP_MUSIC, it->second.baseVolume);
            SetMusicVolume(it->second.music, vol);
            PlayMusicStream(it->second.music);
            it->second.playing = true;
        }
    }

    void Framework_Audio_StopMusic(int handle) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid) {
            StopMusicStream(it->second.music);
            it->second.playing = false;
        }
    }

    void Framework_Audio_PauseMusic(int handle) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid) {
            PauseMusicStream(it->second.music);
        }
    }

    void Framework_Audio_ResumeMusic(int handle) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid) {
            ResumeMusicStream(it->second.music);
        }
    }

    void Framework_Audio_SetMusicVolume(int handle, float volume) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid) {
            it->second.baseVolume = fmaxf(0.0f, fminf(1.0f, volume));
            it->second.targetVolume = it->second.baseVolume;
            float vol = Audio_GetEffectiveVolume(AUDIO_GROUP_MUSIC, it->second.baseVolume);
            SetMusicVolume(it->second.music, vol);
        }
    }

    void Framework_Audio_SetMusicPitch(int handle, float pitch) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid) {
            SetMusicPitch(it->second.music, pitch);
        }
    }

    void Framework_Audio_SetMusicLooping(int handle, bool looping) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid) {
            it->second.looping = looping;
            it->second.music.looping = looping;
        }
    }

    bool Framework_Audio_IsMusicPlaying(int handle) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid) {
            return IsMusicStreamPlaying(it->second.music);
        }
        return false;
    }

    float Framework_Audio_GetMusicLength(int handle) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid) {
            return GetMusicTimeLength(it->second.music);
        }
        return 0.0f;
    }

    float Framework_Audio_GetMusicPosition(int handle) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid) {
            return GetMusicTimePlayed(it->second.music);
        }
        return 0.0f;
    }

    void Framework_Audio_SeekMusic(int handle, float position) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid) {
            SeekMusicStream(it->second.music, position);
        }
    }

    // Music crossfading
    void Framework_Audio_CrossfadeTo(int newMusicHandle, float duration) {
        if (duration <= 0.0f) {
            // Instant switch
            if (g_crossfadeFrom >= 0) Framework_Audio_StopMusic(g_crossfadeFrom);
            Framework_Audio_PlayMusic(newMusicHandle);
            g_crossfadeFrom = -1;
            g_crossfadeTo = -1;
            return;
        }

        // Find currently playing music
        int currentPlaying = -1;
        for (auto& kv : g_managedMusic) {
            if (kv.second.valid && kv.second.playing && IsMusicStreamPlaying(kv.second.music)) {
                currentPlaying = kv.first;
                break;
            }
        }

        g_crossfadeFrom = currentPlaying;
        g_crossfadeTo = newMusicHandle;
        g_crossfadeProgress = 0.0f;
        g_crossfadeDuration = duration;

        // Start new track at zero volume
        auto it = g_managedMusic.find(newMusicHandle);
        if (it != g_managedMusic.end() && it->second.valid) {
            SetMusicVolume(it->second.music, 0.0f);
            PlayMusicStream(it->second.music);
            it->second.playing = true;
        }
    }

    void Framework_Audio_FadeOutMusic(int handle, float duration) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid && duration > 0.0f) {
            it->second.targetVolume = 0.0f;
            it->second.fadeSpeed = -it->second.baseVolume / duration;
        }
    }

    void Framework_Audio_FadeInMusic(int handle, float duration, float targetVolume) {
        auto it = g_managedMusic.find(handle);
        if (it != g_managedMusic.end() && it->second.valid) {
            it->second.baseVolume = 0.0f;
            SetMusicVolume(it->second.music, 0.0f);
            PlayMusicStream(it->second.music);
            it->second.playing = true;

            if (duration > 0.0f) {
                it->second.targetVolume = fmaxf(0.0f, fminf(1.0f, targetVolume));
                it->second.fadeSpeed = it->second.targetVolume / duration;
            }
        }
    }

    bool Framework_Audio_IsCrossfading() {
        return g_crossfadeTo >= 0;
    }

    // Playlist system
    int Framework_Audio_CreatePlaylist() {
        int handle = g_nextPlaylistHandle++;
        Playlist pl;
        pl.valid = true;
        g_playlists[handle] = pl;
        return handle;
    }

    void Framework_Audio_DestroyPlaylist(int playlistHandle) {
        auto it = g_playlists.find(playlistHandle);
        if (it != g_playlists.end()) {
            if (g_activePlaylist == playlistHandle) {
                g_activePlaylist = -1;
            }
            g_playlists.erase(it);
        }
    }

    void Framework_Audio_PlaylistAdd(int playlistHandle, int musicHandle) {
        auto it = g_playlists.find(playlistHandle);
        if (it != g_playlists.end() && it->second.valid) {
            it->second.tracks.push_back(musicHandle);
        }
    }

    void Framework_Audio_PlaylistRemove(int playlistHandle, int index) {
        auto it = g_playlists.find(playlistHandle);
        if (it != g_playlists.end() && index >= 0 && index < (int)it->second.tracks.size()) {
            it->second.tracks.erase(it->second.tracks.begin() + index);
        }
    }

    void Framework_Audio_PlaylistClear(int playlistHandle) {
        auto it = g_playlists.find(playlistHandle);
        if (it != g_playlists.end()) {
            it->second.tracks.clear();
            it->second.shuffleOrder.clear();
            it->second.currentIndex = 0;
        }
    }

    void Framework_Audio_PlaylistPlay(int playlistHandle) {
        auto it = g_playlists.find(playlistHandle);
        if (it == g_playlists.end() || it->second.tracks.empty()) return;

        Playlist& pl = it->second;
        pl.playing = true;
        pl.currentIndex = 0;
        g_activePlaylist = playlistHandle;

        // Generate shuffle order if needed
        if (pl.shuffle) {
            pl.shuffleOrder.resize(pl.tracks.size());
            for (size_t i = 0; i < pl.tracks.size(); i++) pl.shuffleOrder[i] = (int)i;
            for (size_t i = pl.tracks.size() - 1; i > 0; i--) {
                int j = rand() % (i + 1);
                std::swap(pl.shuffleOrder[i], pl.shuffleOrder[j]);
            }
        }

        int trackIndex = pl.shuffle ? pl.shuffleOrder[0] : 0;
        if (pl.crossfadeDuration > 0) {
            Framework_Audio_FadeInMusic(pl.tracks[trackIndex], pl.crossfadeDuration, 1.0f);
        } else {
            Framework_Audio_PlayMusic(pl.tracks[trackIndex]);
        }
    }

    void Framework_Audio_PlaylistStop(int playlistHandle) {
        auto it = g_playlists.find(playlistHandle);
        if (it == g_playlists.end()) return;

        Playlist& pl = it->second;
        pl.playing = false;

        for (int trackHandle : pl.tracks) {
            Framework_Audio_StopMusic(trackHandle);
        }

        if (g_activePlaylist == playlistHandle) {
            g_activePlaylist = -1;
        }
    }

    void Framework_Audio_PlaylistNext(int playlistHandle) {
        auto it = g_playlists.find(playlistHandle);
        if (it == g_playlists.end() || it->second.tracks.empty()) return;

        Playlist& pl = it->second;
        int currentTrackIndex = pl.shuffle ? pl.shuffleOrder[pl.currentIndex] : pl.currentIndex;

        pl.currentIndex++;
        if (pl.currentIndex >= (int)pl.tracks.size()) {
            if (pl.repeatMode == 1) {  // Repeat all
                pl.currentIndex = 0;
                if (pl.shuffle) {
                    // Reshuffle
                    for (size_t i = pl.tracks.size() - 1; i > 0; i--) {
                        int j = rand() % (i + 1);
                        std::swap(pl.shuffleOrder[i], pl.shuffleOrder[j]);
                    }
                }
            } else {
                pl.currentIndex = (int)pl.tracks.size() - 1;
                pl.playing = false;
                return;
            }
        }

        int newTrackIndex = pl.shuffle ? pl.shuffleOrder[pl.currentIndex] : pl.currentIndex;

        if (pl.crossfadeDuration > 0) {
            Framework_Audio_CrossfadeTo(pl.tracks[newTrackIndex], pl.crossfadeDuration);
        } else {
            Framework_Audio_StopMusic(pl.tracks[currentTrackIndex]);
            Framework_Audio_PlayMusic(pl.tracks[newTrackIndex]);
        }
    }

    void Framework_Audio_PlaylistPrev(int playlistHandle) {
        auto it = g_playlists.find(playlistHandle);
        if (it == g_playlists.end() || it->second.tracks.empty()) return;

        Playlist& pl = it->second;
        int currentTrackIndex = pl.shuffle ? pl.shuffleOrder[pl.currentIndex] : pl.currentIndex;

        pl.currentIndex--;
        if (pl.currentIndex < 0) {
            if (pl.repeatMode == 1) {
                pl.currentIndex = (int)pl.tracks.size() - 1;
            } else {
                pl.currentIndex = 0;
                return;
            }
        }

        int newTrackIndex = pl.shuffle ? pl.shuffleOrder[pl.currentIndex] : pl.currentIndex;

        if (pl.crossfadeDuration > 0) {
            Framework_Audio_CrossfadeTo(pl.tracks[newTrackIndex], pl.crossfadeDuration);
        } else {
            Framework_Audio_StopMusic(pl.tracks[currentTrackIndex]);
            Framework_Audio_PlayMusic(pl.tracks[newTrackIndex]);
        }
    }

    void Framework_Audio_PlaylistSetShuffle(int playlistHandle, bool shuffle) {
        auto it = g_playlists.find(playlistHandle);
        if (it != g_playlists.end()) {
            it->second.shuffle = shuffle;
        }
    }

    void Framework_Audio_PlaylistSetRepeat(int playlistHandle, int mode) {
        auto it = g_playlists.find(playlistHandle);
        if (it != g_playlists.end()) {
            it->second.repeatMode = mode;
        }
    }

    int Framework_Audio_PlaylistGetCurrent(int playlistHandle) {
        auto it = g_playlists.find(playlistHandle);
        if (it != g_playlists.end()) {
            return it->second.currentIndex;
        }
        return -1;
    }

    int Framework_Audio_PlaylistGetCount(int playlistHandle) {
        auto it = g_playlists.find(playlistHandle);
        if (it != g_playlists.end()) {
            return (int)it->second.tracks.size();
        }
        return 0;
    }

    void Framework_Audio_PlaylistSetCrossfade(int playlistHandle, float duration) {
        auto it = g_playlists.find(playlistHandle);
        if (it != g_playlists.end()) {
            it->second.crossfadeDuration = fmaxf(0.0f, duration);
        }
    }

    // Audio manager update
    void Framework_Audio_Update(float dt) {
        // Update group volume fading
        for (int i = 0; i < AUDIO_GROUP_COUNT; i++) {
            AudioGroupState& group = g_audioGroups[i];
            if (group.fadeSpeed != 0.0f) {
                group.volume += group.fadeSpeed * dt;
                if ((group.fadeSpeed > 0 && group.volume >= group.targetVolume) ||
                    (group.fadeSpeed < 0 && group.volume <= group.targetVolume)) {
                    group.volume = group.targetVolume;
                    group.fadeSpeed = 0.0f;
                }
            }
        }

        // Update music streams and fading
        for (auto& kv : g_managedMusic) {
            ManagedMusic& mm = kv.second;
            if (!mm.valid) continue;

            // Update stream
            if (mm.playing) {
                UpdateMusicStream(mm.music);
            }

            // Handle volume fading
            if (mm.fadeSpeed != 0.0f) {
                mm.baseVolume += mm.fadeSpeed * dt;
                if ((mm.fadeSpeed > 0 && mm.baseVolume >= mm.targetVolume) ||
                    (mm.fadeSpeed < 0 && mm.baseVolume <= mm.targetVolume)) {
                    mm.baseVolume = mm.targetVolume;
                    mm.fadeSpeed = 0.0f;

                    // Stop if faded to zero
                    if (mm.baseVolume <= 0.0f) {
                        StopMusicStream(mm.music);
                        mm.playing = false;
                    }
                }
                float vol = Audio_GetEffectiveVolume(AUDIO_GROUP_MUSIC, mm.baseVolume);
                SetMusicVolume(mm.music, vol);
            }
        }

        // Handle crossfading
        if (g_crossfadeTo >= 0 && g_crossfadeDuration > 0.0f) {
            g_crossfadeProgress += dt;
            float t = g_crossfadeProgress / g_crossfadeDuration;

            if (t >= 1.0f) {
                // Crossfade complete
                if (g_crossfadeFrom >= 0) {
                    Framework_Audio_StopMusic(g_crossfadeFrom);
                }
                auto itTo = g_managedMusic.find(g_crossfadeTo);
                if (itTo != g_managedMusic.end()) {
                    itTo->second.baseVolume = 1.0f;
                    float vol = Audio_GetEffectiveVolume(AUDIO_GROUP_MUSIC, 1.0f);
                    SetMusicVolume(itTo->second.music, vol);
                }
                g_crossfadeFrom = -1;
                g_crossfadeTo = -1;
            } else {
                // Update volumes
                if (g_crossfadeFrom >= 0) {
                    auto itFrom = g_managedMusic.find(g_crossfadeFrom);
                    if (itFrom != g_managedMusic.end()) {
                        float vol = Audio_GetEffectiveVolume(AUDIO_GROUP_MUSIC, 1.0f - t);
                        SetMusicVolume(itFrom->second.music, vol);
                    }
                }
                auto itTo = g_managedMusic.find(g_crossfadeTo);
                if (itTo != g_managedMusic.end()) {
                    float vol = Audio_GetEffectiveVolume(AUDIO_GROUP_MUSIC, t);
                    SetMusicVolume(itTo->second.music, vol);
                }
            }
        }

        // Handle playlist auto-advance
        if (g_activePlaylist >= 0) {
            auto it = g_playlists.find(g_activePlaylist);
            if (it != g_playlists.end() && it->second.playing && !it->second.tracks.empty()) {
                Playlist& pl = it->second;
                int trackIndex = pl.shuffle ? pl.shuffleOrder[pl.currentIndex] : pl.currentIndex;

                if (!Framework_Audio_IsMusicPlaying(pl.tracks[trackIndex]) && !Framework_Audio_IsCrossfading()) {
                    if (pl.repeatMode == 2) {  // Repeat one
                        Framework_Audio_PlayMusic(pl.tracks[trackIndex]);
                    } else {
                        Framework_Audio_PlaylistNext(g_activePlaylist);
                    }
                }
            }
        }
    }

    // ========================================================================
    // ENHANCED AUDIO SYSTEM - Filters, Effects, 3D Audio Implementation
    // ========================================================================

    // Audio Filter structure
    struct AudioFilter {
        int id = -1;
        int type = AUDIO_FILTER_LOWPASS;
        float cutoff = 1000.0f;     // Hz
        float resonance = 1.0f;      // Q
        float gain = 0.0f;           // dB (for peaking filter)
        bool enabled = true;
        bool valid = true;
    };
    static std::unordered_map<int, AudioFilter> g_audioFilters;
    static int g_nextFilterId = 1;

    // Reverb structure
    struct AudioReverb {
        int id = -1;
        float decayTime = 1.0f;
        float density = 0.7f;
        float diffusion = 1.0f;
        float roomSize = 0.5f;
        float wet = 0.3f;
        float dry = 1.0f;
        float preDelay = 20.0f;
        bool valid = true;
    };
    static std::unordered_map<int, AudioReverb> g_audioReverbs;
    static int g_nextReverbId = 1;

    // Echo structure
    struct AudioEcho {
        int id = -1;
        float delay = 300.0f;     // ms
        float feedback = 0.3f;    // 0-1
        float wet = 0.3f;
        float dry = 1.0f;
        bool valid = true;
    };
    static std::unordered_map<int, AudioEcho> g_audioEchos;
    static int g_nextEchoId = 1;

    // Distortion structure
    struct AudioDistortion {
        int id = -1;
        float gain = 1.0f;
        float tone = 0.5f;
        float output = 1.0f;
        bool valid = true;
    };
    static std::unordered_map<int, AudioDistortion> g_audioDistortions;
    static int g_nextDistortionId = 1;

    // Compressor structure
    struct AudioCompressor {
        int id = -1;
        float threshold = -20.0f;  // dB
        float ratio = 4.0f;
        float attack = 10.0f;      // ms
        float release = 100.0f;    // ms
        float makeupGain = 0.0f;   // dB
        bool valid = true;
    };
    static std::unordered_map<int, AudioCompressor> g_audioCompressors;
    static int g_nextCompressorId = 1;

    // 3D Audio state
    static float g_listenerVelX = 0.0f;
    static float g_listenerVelY = 0.0f;
    static float g_listenerForwardX = 0.0f;
    static float g_listenerForwardY = -1.0f;
    static float g_dopplerFactor = 1.0f;
    static float g_speedOfSound = 343.0f;
    static int g_spatialRolloff = 0;  // 0=linear, 1=inverse, 2=exponential

    // Sound velocity tracking
    struct SoundVelocity {
        float vx = 0.0f;
        float vy = 0.0f;
        float x = 0.0f;
        float y = 0.0f;
    };
    static std::unordered_map<int, SoundVelocity> g_soundVelocities;

    // Ducking state
    struct DuckingState {
        float targetVolume = 0.3f;
        float attackMs = 50.0f;
        float releaseMs = 200.0f;
        float currentDuck = 0.0f;  // Current ducking amount 0-1
        float duckTimer = 0.0f;    // Time remaining
    };
    static std::unordered_map<int, DuckingState> g_duckingStates;

    // Audio Bus structure
    struct AudioBus {
        int id = -1;
        std::string name;
        float volume = 1.0f;
        bool muted = false;
        std::vector<int> filters;
        std::vector<int> reverbs;
        int outputBus = -1;  // Chain to another bus
        bool valid = true;
    };
    static std::unordered_map<int, AudioBus> g_audioBuses;
    static int g_nextBusId = 1;

    // Audio Snapshot structure
    struct AudioSnapshot {
        int id = -1;
        std::string name;
        std::unordered_map<int, float> groupVolumes;
        std::unordered_map<int, float> busVolumes;
        std::unordered_map<int, bool> filterEnabled;
        bool valid = true;
    };
    static std::unordered_map<int, AudioSnapshot> g_audioSnapshots;
    static int g_nextSnapshotId = 1;
    static int g_activeSnapshotId = -1;
    static int g_transitionToSnapshot = -1;
    static float g_snapshotTransitionTime = 0.0f;
    static float g_snapshotTransitionDuration = 0.0f;

    // Filter functions
    int Framework_Audio_CreateFilter(int filterType) {
        AudioFilter f;
        f.id = g_nextFilterId++;
        f.type = filterType;
        g_audioFilters[f.id] = f;
        return f.id;
    }

    void Framework_Audio_DestroyFilter(int filterId) {
        g_audioFilters.erase(filterId);
    }

    void Framework_Audio_SetFilterCutoff(int filterId, float frequency) {
        auto it = g_audioFilters.find(filterId);
        if (it != g_audioFilters.end()) it->second.cutoff = frequency;
    }

    void Framework_Audio_SetFilterResonance(int filterId, float q) {
        auto it = g_audioFilters.find(filterId);
        if (it != g_audioFilters.end()) it->second.resonance = q;
    }

    void Framework_Audio_SetFilterGain(int filterId, float gain) {
        auto it = g_audioFilters.find(filterId);
        if (it != g_audioFilters.end()) it->second.gain = gain;
    }

    void Framework_Audio_ApplyFilterToSound(int soundHandle, int filterId) {
        // Store association (actual DSP would be done in audio callback)
        (void)soundHandle; (void)filterId;
    }

    void Framework_Audio_ApplyFilterToGroup(int group, int filterId) {
        (void)group; (void)filterId;
    }

    void Framework_Audio_RemoveFilterFromSound(int soundHandle, int filterId) {
        (void)soundHandle; (void)filterId;
    }

    void Framework_Audio_RemoveFilterFromGroup(int group, int filterId) {
        (void)group; (void)filterId;
    }

    void Framework_Audio_SetFilterEnabled(int filterId, bool enabled) {
        auto it = g_audioFilters.find(filterId);
        if (it != g_audioFilters.end()) it->second.enabled = enabled;
    }

    bool Framework_Audio_IsFilterEnabled(int filterId) {
        auto it = g_audioFilters.find(filterId);
        return (it != g_audioFilters.end()) ? it->second.enabled : false;
    }

    // Reverb functions
    int Framework_Audio_CreateReverb() {
        AudioReverb r;
        r.id = g_nextReverbId++;
        g_audioReverbs[r.id] = r;
        return r.id;
    }

    void Framework_Audio_DestroyReverb(int reverbId) {
        g_audioReverbs.erase(reverbId);
    }

    void Framework_Audio_SetReverbDecay(int reverbId, float decayTime) {
        auto it = g_audioReverbs.find(reverbId);
        if (it != g_audioReverbs.end()) it->second.decayTime = decayTime;
    }

    void Framework_Audio_SetReverbDensity(int reverbId, float density) {
        auto it = g_audioReverbs.find(reverbId);
        if (it != g_audioReverbs.end()) it->second.density = density;
    }

    void Framework_Audio_SetReverbDiffusion(int reverbId, float diffusion) {
        auto it = g_audioReverbs.find(reverbId);
        if (it != g_audioReverbs.end()) it->second.diffusion = diffusion;
    }

    void Framework_Audio_SetReverbRoomSize(int reverbId, float size) {
        auto it = g_audioReverbs.find(reverbId);
        if (it != g_audioReverbs.end()) it->second.roomSize = size;
    }

    void Framework_Audio_SetReverbWetDry(int reverbId, float wet, float dry) {
        auto it = g_audioReverbs.find(reverbId);
        if (it != g_audioReverbs.end()) {
            it->second.wet = wet;
            it->second.dry = dry;
        }
    }

    void Framework_Audio_SetReverbPreDelay(int reverbId, float delayMs) {
        auto it = g_audioReverbs.find(reverbId);
        if (it != g_audioReverbs.end()) it->second.preDelay = delayMs;
    }

    void Framework_Audio_ApplyReverbToSound(int soundHandle, int reverbId) {
        (void)soundHandle; (void)reverbId;
    }

    void Framework_Audio_ApplyReverbToGroup(int group, int reverbId) {
        (void)group; (void)reverbId;
    }

    void Framework_Audio_RemoveReverbFromSound(int soundHandle, int reverbId) {
        (void)soundHandle; (void)reverbId;
    }

    void Framework_Audio_RemoveReverbFromGroup(int group, int reverbId) {
        (void)group; (void)reverbId;
    }

    void Framework_Audio_SetReverbPreset(int reverbId, int preset) {
        auto it = g_audioReverbs.find(reverbId);
        if (it == g_audioReverbs.end()) return;

        switch (preset) {
            case 0:  // Small room
                it->second.decayTime = 0.3f;
                it->second.roomSize = 0.2f;
                it->second.wet = 0.2f;
                break;
            case 1:  // Medium room
                it->second.decayTime = 0.6f;
                it->second.roomSize = 0.4f;
                it->second.wet = 0.3f;
                break;
            case 2:  // Large room
                it->second.decayTime = 1.0f;
                it->second.roomSize = 0.6f;
                it->second.wet = 0.4f;
                break;
            case 3:  // Hall
                it->second.decayTime = 1.8f;
                it->second.roomSize = 0.8f;
                it->second.wet = 0.5f;
                break;
            case 4:  // Cave
                it->second.decayTime = 3.0f;
                it->second.roomSize = 1.0f;
                it->second.wet = 0.7f;
                break;
        }
    }

    // Echo functions
    int Framework_Audio_CreateEcho() {
        AudioEcho e;
        e.id = g_nextEchoId++;
        g_audioEchos[e.id] = e;
        return e.id;
    }

    void Framework_Audio_DestroyEcho(int echoId) {
        g_audioEchos.erase(echoId);
    }

    void Framework_Audio_SetEchoDelay(int echoId, float delayMs) {
        auto it = g_audioEchos.find(echoId);
        if (it != g_audioEchos.end()) it->second.delay = delayMs;
    }

    void Framework_Audio_SetEchoFeedback(int echoId, float feedback) {
        auto it = g_audioEchos.find(echoId);
        if (it != g_audioEchos.end()) it->second.feedback = feedback;
    }

    void Framework_Audio_SetEchoWetDry(int echoId, float wet, float dry) {
        auto it = g_audioEchos.find(echoId);
        if (it != g_audioEchos.end()) {
            it->second.wet = wet;
            it->second.dry = dry;
        }
    }

    void Framework_Audio_ApplyEchoToSound(int soundHandle, int echoId) {
        (void)soundHandle; (void)echoId;
    }

    void Framework_Audio_RemoveEchoFromSound(int soundHandle, int echoId) {
        (void)soundHandle; (void)echoId;
    }

    // Distortion functions
    int Framework_Audio_CreateDistortion() {
        AudioDistortion d;
        d.id = g_nextDistortionId++;
        g_audioDistortions[d.id] = d;
        return d.id;
    }

    void Framework_Audio_DestroyDistortion(int distortionId) {
        g_audioDistortions.erase(distortionId);
    }

    void Framework_Audio_SetDistortionGain(int distortionId, float gain) {
        auto it = g_audioDistortions.find(distortionId);
        if (it != g_audioDistortions.end()) it->second.gain = gain;
    }

    void Framework_Audio_SetDistortionTone(int distortionId, float tone) {
        auto it = g_audioDistortions.find(distortionId);
        if (it != g_audioDistortions.end()) it->second.tone = tone;
    }

    void Framework_Audio_SetDistortionOutput(int distortionId, float output) {
        auto it = g_audioDistortions.find(distortionId);
        if (it != g_audioDistortions.end()) it->second.output = output;
    }

    void Framework_Audio_ApplyDistortionToSound(int soundHandle, int distortionId) {
        (void)soundHandle; (void)distortionId;
    }

    // Compressor functions
    int Framework_Audio_CreateCompressor() {
        AudioCompressor c;
        c.id = g_nextCompressorId++;
        g_audioCompressors[c.id] = c;
        return c.id;
    }

    void Framework_Audio_DestroyCompressor(int compressorId) {
        g_audioCompressors.erase(compressorId);
    }

    void Framework_Audio_SetCompressorThreshold(int compressorId, float thresholdDb) {
        auto it = g_audioCompressors.find(compressorId);
        if (it != g_audioCompressors.end()) it->second.threshold = thresholdDb;
    }

    void Framework_Audio_SetCompressorRatio(int compressorId, float ratio) {
        auto it = g_audioCompressors.find(compressorId);
        if (it != g_audioCompressors.end()) it->second.ratio = ratio;
    }

    void Framework_Audio_SetCompressorAttack(int compressorId, float attackMs) {
        auto it = g_audioCompressors.find(compressorId);
        if (it != g_audioCompressors.end()) it->second.attack = attackMs;
    }

    void Framework_Audio_SetCompressorRelease(int compressorId, float releaseMs) {
        auto it = g_audioCompressors.find(compressorId);
        if (it != g_audioCompressors.end()) it->second.release = releaseMs;
    }

    void Framework_Audio_SetCompressorMakeupGain(int compressorId, float gainDb) {
        auto it = g_audioCompressors.find(compressorId);
        if (it != g_audioCompressors.end()) it->second.makeupGain = gainDb;
    }

    void Framework_Audio_ApplyCompressorToGroup(int group, int compressorId) {
        (void)group; (void)compressorId;
    }

    // Enhanced 3D Audio
    void Framework_Audio_SetListenerVelocity(float vx, float vy) {
        g_listenerVelX = vx;
        g_listenerVelY = vy;
    }

    void Framework_Audio_SetListenerOrientation(float forwardX, float forwardY) {
        g_listenerForwardX = forwardX;
        g_listenerForwardY = forwardY;
    }

    void Framework_Audio_SetDopplerFactor(float factor) {
        g_dopplerFactor = factor;
    }

    void Framework_Audio_SetSpeedOfSound(float speed) {
        g_speedOfSound = speed;
    }

    void Framework_Audio_PlaySoundWithVelocity(int handle, float x, float y, float vx, float vy) {
        g_soundVelocities[handle] = { vx, vy, x, y };
        Framework_Audio_PlaySoundAt(handle, x, y);
    }

    void Framework_Audio_SetSoundVelocity(int handle, float vx, float vy) {
        auto it = g_soundVelocities.find(handle);
        if (it != g_soundVelocities.end()) {
            it->second.vx = vx;
            it->second.vy = vy;
        } else {
            g_soundVelocities[handle] = { vx, vy, 0, 0 };
        }
    }

    void Framework_Audio_SetSoundPosition(int handle, float x, float y) {
        auto it = g_soundVelocities.find(handle);
        if (it != g_soundVelocities.end()) {
            it->second.x = x;
            it->second.y = y;
        } else {
            g_soundVelocities[handle] = { 0, 0, x, y };
        }
    }

    void Framework_Audio_SetSpatialRolloff(int rolloffMode) {
        g_spatialRolloff = rolloffMode;
    }

    // Sound Ducking
    void Framework_Audio_SetDuckingTarget(int group, float duckVolume) {
        g_duckingStates[group].targetVolume = duckVolume;
    }

    void Framework_Audio_SetDuckingDurations(int group, float attackMs, float releaseMs) {
        g_duckingStates[group].attackMs = attackMs;
        g_duckingStates[group].releaseMs = releaseMs;
    }

    void Framework_Audio_TriggerDucking(int group, float durationMs) {
        g_duckingStates[group].duckTimer = durationMs / 1000.0f;
    }

    void Framework_Audio_PlaySoundWithDucking(int handle, int duckGroup) {
        Framework_Audio_TriggerDucking(duckGroup, 1000.0f);  // Default 1 second
        Framework_Audio_PlaySound(handle);
    }

    // Audio Bus System
    int Framework_Audio_CreateBus(const char* name) {
        AudioBus bus;
        bus.id = g_nextBusId++;
        bus.name = name ? name : "";
        g_audioBuses[bus.id] = bus;
        return bus.id;
    }

    void Framework_Audio_DestroyBus(int busId) {
        g_audioBuses.erase(busId);
    }

    void Framework_Audio_RouteSoundToBus(int soundHandle, int busId) {
        (void)soundHandle; (void)busId;
    }

    void Framework_Audio_RouteGroupToBus(int group, int busId) {
        (void)group; (void)busId;
    }

    void Framework_Audio_SetBusVolume(int busId, float volume) {
        auto it = g_audioBuses.find(busId);
        if (it != g_audioBuses.end()) it->second.volume = volume;
    }

    void Framework_Audio_SetBusMuted(int busId, bool muted) {
        auto it = g_audioBuses.find(busId);
        if (it != g_audioBuses.end()) it->second.muted = muted;
    }

    void Framework_Audio_ApplyFilterToBus(int busId, int filterId) {
        auto it = g_audioBuses.find(busId);
        if (it != g_audioBuses.end()) it->second.filters.push_back(filterId);
    }

    void Framework_Audio_ApplyReverbToBus(int busId, int reverbId) {
        auto it = g_audioBuses.find(busId);
        if (it != g_audioBuses.end()) it->second.reverbs.push_back(reverbId);
    }

    void Framework_Audio_ChainBuses(int sourceBusId, int destBusId) {
        auto it = g_audioBuses.find(sourceBusId);
        if (it != g_audioBuses.end()) it->second.outputBus = destBusId;
    }

    // Audio Snapshots
    int Framework_Audio_CreateSnapshot(const char* name) {
        AudioSnapshot snap;
        snap.id = g_nextSnapshotId++;
        snap.name = name ? name : "";
        g_audioSnapshots[snap.id] = snap;
        return snap.id;
    }

    void Framework_Audio_DestroySnapshot(int snapshotId) {
        g_audioSnapshots.erase(snapshotId);
    }

    void Framework_Audio_SnapshotSetGroupVolume(int snapshotId, int group, float volume) {
        auto it = g_audioSnapshots.find(snapshotId);
        if (it != g_audioSnapshots.end()) it->second.groupVolumes[group] = volume;
    }

    void Framework_Audio_SnapshotSetBusVolume(int snapshotId, int busId, float volume) {
        auto it = g_audioSnapshots.find(snapshotId);
        if (it != g_audioSnapshots.end()) it->second.busVolumes[busId] = volume;
    }

    void Framework_Audio_SnapshotSetFilterEnabled(int snapshotId, int filterId, bool enabled) {
        auto it = g_audioSnapshots.find(snapshotId);
        if (it != g_audioSnapshots.end()) it->second.filterEnabled[filterId] = enabled;
    }

    void Framework_Audio_TransitionToSnapshot(int snapshotId, float durationMs) {
        g_transitionToSnapshot = snapshotId;
        g_snapshotTransitionDuration = durationMs / 1000.0f;
        g_snapshotTransitionTime = 0.0f;
    }

    int Framework_Audio_GetActiveSnapshot() {
        return g_activeSnapshotId;
    }

    // Audio Analysis
    float Framework_Audio_GetMasterLevel() {
        return 0.0f;  // Would need actual audio metering
    }

    float Framework_Audio_GetGroupLevel(int group) {
        (void)group;
        return 0.0f;
    }

    float Framework_Audio_GetSoundLevel(int soundHandle) {
        (void)soundHandle;
        return 0.0f;
    }

    void Framework_Audio_GetSpectrum(int bandCount, float* outBands) {
        // Would need FFT analysis
        if (outBands) {
            for (int i = 0; i < bandCount; i++) {
                outBands[i] = 0.0f;
            }
        }
    }

    // ========================================================================
    // INPUT MANAGER - Action-based Input System Implementation
    // ========================================================================

    // Binding structures
    struct KeyBinding {
        int keyCode;
    };

    struct MouseButtonBinding {
        int button;  // 0=left, 1=right, 2=middle
    };

    struct GamepadButtonBinding {
        int button;
    };

    struct AxisBinding {
        int sourceType;  // InputSourceType
        int axis;
        float scale;
    };

    // Input action
    struct InputAction {
        std::string name;
        std::vector<KeyBinding> keyBindings;
        std::vector<MouseButtonBinding> mouseBindings;
        std::vector<GamepadButtonBinding> gamepadBindings;
        std::vector<AxisBinding> axisBindings;

        float deadzone = 0.1f;
        float sensitivity = 1.0f;

        // Current frame state
        bool pressed = false;    // Just pressed
        bool down = false;       // Currently held
        bool released = false;   // Just released
        float value = 0.0f;      // Analog value
        float rawValue = 0.0f;   // Raw unprocessed

        // Previous frame state
        bool wasDown = false;

        bool valid = true;
    };

    static std::unordered_map<int, InputAction> g_inputActions;
    static std::unordered_map<std::string, int> g_actionByName;
    static int g_nextActionHandle = 1;
    static int g_activeGamepad = 0;

    // Rebinding state
    static bool g_isListening = false;
    static int g_listeningAction = -1;
    static bool g_bindingCaptured = false;
    static int g_capturedSourceType = 0;
    static int g_capturedCode = 0;

    // Vibration state
    struct VibrationState {
        float leftMotor = 0;
        float rightMotor = 0;
        float duration = 0;
        float timer = 0;
    };
    static VibrationState g_vibration[4];

    // Action management
    int Framework_Input_CreateAction(const char* name) {
        if (!name) return -1;

        std::string actionName(name);

        // Check if already exists
        auto it = g_actionByName.find(actionName);
        if (it != g_actionByName.end()) {
            return it->second;
        }

        int handle = g_nextActionHandle++;
        InputAction& action = g_inputActions[handle];
        action.name = actionName;
        action.valid = true;
        g_actionByName[actionName] = handle;

        return handle;
    }

    void Framework_Input_DestroyAction(int actionHandle) {
        auto it = g_inputActions.find(actionHandle);
        if (it != g_inputActions.end()) {
            g_actionByName.erase(it->second.name);
            g_inputActions.erase(it);
        }
    }

    int Framework_Input_GetAction(const char* name) {
        if (!name) return -1;
        auto it = g_actionByName.find(std::string(name));
        return (it != g_actionByName.end()) ? it->second : -1;
    }

    bool Framework_Input_IsActionValid(int actionHandle) {
        auto it = g_inputActions.find(actionHandle);
        return it != g_inputActions.end() && it->second.valid;
    }

    void Framework_Input_ClearAllActions() {
        g_inputActions.clear();
        g_actionByName.clear();
        g_nextActionHandle = 1;
    }

    // Keyboard bindings
    void Framework_Input_BindKey(int actionHandle, int keyCode) {
        auto it = g_inputActions.find(actionHandle);
        if (it == g_inputActions.end()) return;

        // Check if already bound
        for (const auto& kb : it->second.keyBindings) {
            if (kb.keyCode == keyCode) return;
        }
        it->second.keyBindings.push_back({ keyCode });
    }

    void Framework_Input_UnbindKey(int actionHandle, int keyCode) {
        auto it = g_inputActions.find(actionHandle);
        if (it == g_inputActions.end()) return;

        auto& bindings = it->second.keyBindings;
        bindings.erase(std::remove_if(bindings.begin(), bindings.end(),
            [keyCode](const KeyBinding& kb) { return kb.keyCode == keyCode; }), bindings.end());
    }

    void Framework_Input_ClearKeyBindings(int actionHandle) {
        auto it = g_inputActions.find(actionHandle);
        if (it != g_inputActions.end()) {
            it->second.keyBindings.clear();
        }
    }

    // Mouse button bindings
    void Framework_Input_BindMouseButton(int actionHandle, int button) {
        auto it = g_inputActions.find(actionHandle);
        if (it == g_inputActions.end()) return;

        for (const auto& mb : it->second.mouseBindings) {
            if (mb.button == button) return;
        }
        it->second.mouseBindings.push_back({ button });
    }

    void Framework_Input_UnbindMouseButton(int actionHandle, int button) {
        auto it = g_inputActions.find(actionHandle);
        if (it == g_inputActions.end()) return;

        auto& bindings = it->second.mouseBindings;
        bindings.erase(std::remove_if(bindings.begin(), bindings.end(),
            [button](const MouseButtonBinding& mb) { return mb.button == button; }), bindings.end());
    }

    // Gamepad button bindings
    void Framework_Input_BindGamepadButton(int actionHandle, int button) {
        auto it = g_inputActions.find(actionHandle);
        if (it == g_inputActions.end()) return;

        for (const auto& gb : it->second.gamepadBindings) {
            if (gb.button == button) return;
        }
        it->second.gamepadBindings.push_back({ button });
    }

    void Framework_Input_UnbindGamepadButton(int actionHandle, int button) {
        auto it = g_inputActions.find(actionHandle);
        if (it == g_inputActions.end()) return;

        auto& bindings = it->second.gamepadBindings;
        bindings.erase(std::remove_if(bindings.begin(), bindings.end(),
            [button](const GamepadButtonBinding& gb) { return gb.button == button; }), bindings.end());
    }

    // Axis bindings
    void Framework_Input_BindMouseAxis(int actionHandle, int axis, float scale) {
        auto it = g_inputActions.find(actionHandle);
        if (it == g_inputActions.end()) return;

        it->second.axisBindings.push_back({ INPUT_SOURCE_MOUSE_AXIS, axis, scale });
    }

    void Framework_Input_BindGamepadAxis(int actionHandle, int axis, float scale) {
        auto it = g_inputActions.find(actionHandle);
        if (it == g_inputActions.end()) return;

        it->second.axisBindings.push_back({ INPUT_SOURCE_GAMEPAD_AXIS, axis, scale });
    }

    void Framework_Input_ClearAxisBindings(int actionHandle) {
        auto it = g_inputActions.find(actionHandle);
        if (it != g_inputActions.end()) {
            it->second.axisBindings.clear();
        }
    }

    // Action state queries
    bool Framework_Input_IsActionPressed(int actionHandle) {
        auto it = g_inputActions.find(actionHandle);
        return it != g_inputActions.end() && it->second.pressed;
    }

    bool Framework_Input_IsActionDown(int actionHandle) {
        auto it = g_inputActions.find(actionHandle);
        return it != g_inputActions.end() && it->second.down;
    }

    bool Framework_Input_IsActionReleased(int actionHandle) {
        auto it = g_inputActions.find(actionHandle);
        return it != g_inputActions.end() && it->second.released;
    }

    float Framework_Input_GetActionValue(int actionHandle) {
        auto it = g_inputActions.find(actionHandle);
        return it != g_inputActions.end() ? it->second.value : 0.0f;
    }

    float Framework_Input_GetActionRawValue(int actionHandle) {
        auto it = g_inputActions.find(actionHandle);
        return it != g_inputActions.end() ? it->second.rawValue : 0.0f;
    }

    // Action configuration
    void Framework_Input_SetActionDeadzone(int actionHandle, float deadzone) {
        auto it = g_inputActions.find(actionHandle);
        if (it != g_inputActions.end()) {
            it->second.deadzone = deadzone < 0 ? 0 : (deadzone > 1 ? 1 : deadzone);
        }
    }

    float Framework_Input_GetActionDeadzone(int actionHandle) {
        auto it = g_inputActions.find(actionHandle);
        return it != g_inputActions.end() ? it->second.deadzone : 0.1f;
    }

    void Framework_Input_SetActionSensitivity(int actionHandle, float sensitivity) {
        auto it = g_inputActions.find(actionHandle);
        if (it != g_inputActions.end()) {
            it->second.sensitivity = sensitivity > 0 ? sensitivity : 1.0f;
        }
    }

    float Framework_Input_GetActionSensitivity(int actionHandle) {
        auto it = g_inputActions.find(actionHandle);
        return it != g_inputActions.end() ? it->second.sensitivity : 1.0f;
    }

    // Gamepad management
    bool Framework_Input_IsGamepadAvailable(int gamepadId) {
        return IsGamepadAvailable(gamepadId);
    }

    const char* Framework_Input_GetGamepadName(int gamepadId) {
        if (!IsGamepadAvailable(gamepadId)) return "";
        return GetGamepadName(gamepadId);
    }

    int Framework_Input_GetGamepadCount() {
        int count = 0;
        for (int i = 0; i < 4; i++) {
            if (IsGamepadAvailable(i)) count++;
        }
        return count;
    }

    void Framework_Input_SetActiveGamepad(int gamepadId) {
        g_activeGamepad = (gamepadId >= 0 && gamepadId < 4) ? gamepadId : 0;
    }

    int Framework_Input_GetActiveGamepad() {
        return g_activeGamepad;
    }

    // Direct gamepad queries
    bool Framework_Input_IsGamepadButtonPressed(int gamepadId, int button) {
        return IsGamepadAvailable(gamepadId) && IsGamepadButtonPressed(gamepadId, button);
    }

    bool Framework_Input_IsGamepadButtonDown(int gamepadId, int button) {
        return IsGamepadAvailable(gamepadId) && IsGamepadButtonDown(gamepadId, button);
    }

    bool Framework_Input_IsGamepadButtonReleased(int gamepadId, int button) {
        return IsGamepadAvailable(gamepadId) && IsGamepadButtonReleased(gamepadId, button);
    }

    float Framework_Input_GetGamepadAxisValue(int gamepadId, int axis) {
        if (!IsGamepadAvailable(gamepadId)) return 0.0f;
        return GetGamepadAxisMovement(gamepadId, axis);
    }

    // Rebinding support
    void Framework_Input_StartListening(int actionHandle) {
        if (!Framework_Input_IsActionValid(actionHandle)) return;
        g_isListening = true;
        g_listeningAction = actionHandle;
        g_bindingCaptured = false;
        g_capturedSourceType = 0;
        g_capturedCode = 0;
    }

    bool Framework_Input_IsListening() {
        return g_isListening;
    }

    void Framework_Input_StopListening() {
        g_isListening = false;
        g_listeningAction = -1;
    }

    bool Framework_Input_WasBindingCaptured() {
        return g_bindingCaptured;
    }

    int Framework_Input_GetCapturedSourceType() {
        return g_capturedSourceType;
    }

    int Framework_Input_GetCapturedCode() {
        return g_capturedCode;
    }

    // Rumble/vibration - uses XInput for actual controller vibration
    void Framework_Input_SetGamepadVibration(int gamepadId, float leftMotor, float rightMotor, float duration) {
        if (gamepadId < 0 || gamepadId >= 4) return;

        // Clamp motor values to 0-1 range
        leftMotor = leftMotor < 0 ? 0 : (leftMotor > 1 ? 1 : leftMotor);
        rightMotor = rightMotor < 0 ? 0 : (rightMotor > 1 ? 1 : rightMotor);

        g_vibration[gamepadId].leftMotor = leftMotor;
        g_vibration[gamepadId].rightMotor = rightMotor;
        g_vibration[gamepadId].duration = duration;
        g_vibration[gamepadId].timer = duration;

        // Apply XInput vibration (works on Windows with Xbox controllers)
        XINPUT_VIBRATION vibration;
        vibration.wLeftMotorSpeed = (WORD)(leftMotor * 65535.0f);
        vibration.wRightMotorSpeed = (WORD)(rightMotor * 65535.0f);
        XInputSetState(gamepadId, &vibration);
    }

    void Framework_Input_StopGamepadVibration(int gamepadId) {
        if (gamepadId < 0 || gamepadId >= 4) return;
        g_vibration[gamepadId].leftMotor = 0;
        g_vibration[gamepadId].rightMotor = 0;
        g_vibration[gamepadId].timer = 0;

        // Stop XInput vibration
        XINPUT_VIBRATION vibration = { 0, 0 };
        XInputSetState(gamepadId, &vibration);
    }

    void Framework_Input_PulseGamepad(int gamepadId, float intensity, float duration) {
        // Quick pulse on both motors - good for pickups, small hits
        Framework_Input_SetGamepadVibration(gamepadId, intensity, intensity, duration);
    }

    void Framework_Input_ImpactRumble(int gamepadId, float intensity) {
        // Heavy impact on left motor (low frequency) - good for explosions, big hits
        Framework_Input_SetGamepadVibration(gamepadId, intensity, intensity * 0.3f, 0.15f);
    }

    void Framework_Input_EngineRumble(int gamepadId, float intensity) {
        // Constant right motor (high frequency) - good for engines, ongoing effects
        // No duration - stays on until stopped
        if (gamepadId < 0 || gamepadId >= 4) return;
        float motor = intensity < 0 ? 0 : (intensity > 1 ? 1 : intensity);
        g_vibration[gamepadId].rightMotor = motor;
        g_vibration[gamepadId].timer = 0;  // Continuous until stopped

        XINPUT_VIBRATION vibration;
        vibration.wLeftMotorSpeed = (WORD)(g_vibration[gamepadId].leftMotor * 65535.0f);
        vibration.wRightMotorSpeed = (WORD)(motor * 65535.0f);
        XInputSetState(gamepadId, &vibration);
    }

    bool Framework_Input_IsGamepadVibrating(int gamepadId) {
        if (gamepadId < 0 || gamepadId >= 4) return false;
        return g_vibration[gamepadId].leftMotor > 0 || g_vibration[gamepadId].rightMotor > 0;
    }

    float Framework_Input_GetVibrationTimeRemaining(int gamepadId) {
        if (gamepadId < 0 || gamepadId >= 4) return 0;
        return g_vibration[gamepadId].timer;
    }

    // Input system update
    void Framework_Input_Update() {
        float dt = GetFrameTime();

        // Handle rebinding mode
        if (g_isListening) {
            // Check keyboard
            for (int key = 0; key < 350; key++) {
                if (IsKeyPressed(key)) {
                    g_capturedSourceType = INPUT_SOURCE_KEYBOARD;
                    g_capturedCode = key;
                    g_bindingCaptured = true;
                    Framework_Input_BindKey(g_listeningAction, key);
                    g_isListening = false;
                    g_listeningAction = -1;
                    return;
                }
            }

            // Check mouse buttons
            for (int btn = 0; btn < 3; btn++) {
                if (IsMouseButtonPressed(btn)) {
                    g_capturedSourceType = INPUT_SOURCE_MOUSE_BUTTON;
                    g_capturedCode = btn;
                    g_bindingCaptured = true;
                    Framework_Input_BindMouseButton(g_listeningAction, btn);
                    g_isListening = false;
                    g_listeningAction = -1;
                    return;
                }
            }

            // Check gamepad buttons
            if (IsGamepadAvailable(g_activeGamepad)) {
                for (int btn = 0; btn < 18; btn++) {
                    if (IsGamepadButtonPressed(g_activeGamepad, btn)) {
                        g_capturedSourceType = INPUT_SOURCE_GAMEPAD_BUTTON;
                        g_capturedCode = btn;
                        g_bindingCaptured = true;
                        Framework_Input_BindGamepadButton(g_listeningAction, btn);
                        g_isListening = false;
                        g_listeningAction = -1;
                        return;
                    }
                }
            }
        }

        // Update vibration timers
        for (int i = 0; i < 4; i++) {
            if (g_vibration[i].timer > 0) {
                g_vibration[i].timer -= dt;
                if (g_vibration[i].timer <= 0) {
                    g_vibration[i].leftMotor = 0;
                    g_vibration[i].rightMotor = 0;
                    // Stop XInput vibration when timer expires
                    XINPUT_VIBRATION vibration = { 0, 0 };
                    XInputSetState(i, &vibration);
                }
            }
        }

        // Update all actions
        for (auto& kv : g_inputActions) {
            InputAction& action = kv.second;

            // Store previous state
            action.wasDown = action.down;

            // Check digital inputs (keyboard, mouse, gamepad buttons)
            bool isDown = false;

            // Keyboard
            for (const auto& kb : action.keyBindings) {
                if (IsKeyDown(kb.keyCode)) {
                    isDown = true;
                    break;
                }
            }

            // Mouse buttons
            if (!isDown) {
                for (const auto& mb : action.mouseBindings) {
                    if (IsMouseButtonDown(mb.button)) {
                        isDown = true;
                        break;
                    }
                }
            }

            // Gamepad buttons
            if (!isDown && IsGamepadAvailable(g_activeGamepad)) {
                for (const auto& gb : action.gamepadBindings) {
                    if (IsGamepadButtonDown(g_activeGamepad, gb.button)) {
                        isDown = true;
                        break;
                    }
                }
            }

            action.down = isDown;
            action.pressed = isDown && !action.wasDown;
            action.released = !isDown && action.wasDown;

            // Calculate analog value from axis bindings
            float analogValue = 0.0f;

            for (const auto& ab : action.axisBindings) {
                float axisValue = 0.0f;

                if (ab.sourceType == INPUT_SOURCE_MOUSE_AXIS) {
                    Vector2 delta = GetMouseDelta();
                    switch (ab.axis) {
                        case MOUSE_AXIS_X: axisValue = delta.x; break;
                        case MOUSE_AXIS_Y: axisValue = delta.y; break;
                        case MOUSE_AXIS_WHEEL: axisValue = GetMouseWheelMove(); break;
                        case MOUSE_AXIS_WHEEL_H: axisValue = GetMouseWheelMoveV().x; break;
                    }
                } else if (ab.sourceType == INPUT_SOURCE_GAMEPAD_AXIS && IsGamepadAvailable(g_activeGamepad)) {
                    axisValue = GetGamepadAxisMovement(g_activeGamepad, ab.axis);
                }

                analogValue += axisValue * ab.scale;
            }

            // If digital input is active, use 1.0/-1.0
            if (isDown && fabsf(analogValue) < 0.001f) {
                analogValue = 1.0f;
            }

            action.rawValue = analogValue;

            // Apply deadzone
            if (fabsf(analogValue) < action.deadzone) {
                analogValue = 0.0f;
            } else {
                // Remap to 0-1 range after deadzone
                float sign = analogValue > 0 ? 1.0f : -1.0f;
                analogValue = sign * ((fabsf(analogValue) - action.deadzone) / (1.0f - action.deadzone));
            }

            // Apply sensitivity
            analogValue *= action.sensitivity;

            // Clamp to -1 to 1
            action.value = analogValue < -1.0f ? -1.0f : (analogValue > 1.0f ? 1.0f : analogValue);
        }
    }

    // Serialization
    bool Framework_Input_SaveBindings(const char* filename) {
        if (!filename) return false;

        std::string path = ResolveAssetPath(filename);
        FILE* f = nullptr;
        if (fopen_s(&f, path.c_str(), "w") != 0 || !f) return false;

        fprintf(f, "# Input Bindings\n");
        fprintf(f, "version 1\n\n");

        for (const auto& kv : g_inputActions) {
            const InputAction& action = kv.second;
            fprintf(f, "action %s\n", action.name.c_str());

            for (const auto& kb : action.keyBindings) {
                fprintf(f, "  key %d\n", kb.keyCode);
            }
            for (const auto& mb : action.mouseBindings) {
                fprintf(f, "  mouse %d\n", mb.button);
            }
            for (const auto& gb : action.gamepadBindings) {
                fprintf(f, "  gamepad %d\n", gb.button);
            }
            for (const auto& ab : action.axisBindings) {
                fprintf(f, "  axis %d %d %f\n", ab.sourceType, ab.axis, ab.scale);
            }

            fprintf(f, "  deadzone %f\n", action.deadzone);
            fprintf(f, "  sensitivity %f\n", action.sensitivity);
            fprintf(f, "end\n\n");
        }

        fclose(f);
        return true;
    }

    bool Framework_Input_LoadBindings(const char* filename) {
        if (!filename) return false;

        std::string path = ResolveAssetPath(filename);
        FILE* f = nullptr;
        if (fopen_s(&f, path.c_str(), "r") != 0 || !f) return false;

        char line[256];
        int currentAction = -1;

        while (fgets(line, sizeof(line), f)) {
            // Skip comments and empty lines
            if (line[0] == '#' || line[0] == '\n' || line[0] == '\r') continue;

            char arg1[128];
            int i1, i2;
            float f1;

            if (sscanf_s(line, "action %127s", arg1, (unsigned)sizeof(arg1)) == 1) {
                currentAction = Framework_Input_CreateAction(arg1);
                // Clear existing bindings
                if (currentAction != -1) {
                    auto it = g_inputActions.find(currentAction);
                    if (it != g_inputActions.end()) {
                        it->second.keyBindings.clear();
                        it->second.mouseBindings.clear();
                        it->second.gamepadBindings.clear();
                        it->second.axisBindings.clear();
                    }
                }
            } else if (sscanf_s(line, " key %d", &i1) == 1) {
                if (currentAction != -1) Framework_Input_BindKey(currentAction, i1);
            } else if (sscanf_s(line, " mouse %d", &i1) == 1) {
                if (currentAction != -1) Framework_Input_BindMouseButton(currentAction, i1);
            } else if (sscanf_s(line, " gamepad %d", &i1) == 1) {
                if (currentAction != -1) Framework_Input_BindGamepadButton(currentAction, i1);
            } else if (sscanf_s(line, " axis %d %d %f", &i1, &i2, &f1) == 3) {
                if (currentAction != -1) {
                    auto it = g_inputActions.find(currentAction);
                    if (it != g_inputActions.end()) {
                        it->second.axisBindings.push_back({ i1, i2, f1 });
                    }
                }
            } else if (sscanf_s(line, " deadzone %f", &f1) == 1) {
                if (currentAction != -1) Framework_Input_SetActionDeadzone(currentAction, f1);
            } else if (sscanf_s(line, " sensitivity %f", &f1) == 1) {
                if (currentAction != -1) Framework_Input_SetActionSensitivity(currentAction, f1);
            } else if (strstr(line, "end")) {
                currentAction = -1;
            }
        }

        fclose(f);
        return true;
    }

    // ========================================================================
    // SAVE/LOAD SYSTEM - Game State Persistence Implementation
    // ========================================================================

    // Save system state
    static std::string g_saveDirectory = "saves";
    static std::unordered_map<std::string, std::string> g_saveData;       // Current save being built/read
    static std::unordered_map<std::string, std::string> g_saveMetadata;   // Metadata for current save
    static int g_currentSaveSlot = -1;
    static bool g_isSaving = false;
    static bool g_isLoading = false;
    static std::string g_tempStringResult;  // For returning string pointers

    // Auto-save state
    static bool g_autoSaveEnabled = false;
    static float g_autoSaveInterval = 300.0f;  // 5 minutes default
    static float g_autoSaveTimer = 0.0f;
    static int g_autoSaveSlot = -1;  // -1 = rotating, else specific slot
    static int g_autoSaveRotation = 0;

    // Settings (separate from game saves)
    static std::unordered_map<std::string, std::string> g_settings;

    // Helper: Get save file path for a slot
    static std::string GetSaveFilePath(int slot) {
        return g_saveDirectory + "/save_" + std::to_string(slot) + ".sav";
    }

    static std::string GetSettingsFilePath() {
        return g_saveDirectory + "/settings.cfg";
    }

    // Helper: Ensure save directory exists (use raylib's DirectoryExists)
    static bool EnsureSaveDirectory() {
        std::string path = ResolveAssetPath(g_saveDirectory.c_str());
        // Use raylib's directory check - if not exists, create it
        if (!DirectoryExists(path.c_str())) {
            // Create directory using system call
            std::string cmd = "mkdir \"" + path + "\"";
            system(cmd.c_str());
        }
        return true;
    }

    // Helper: Check if file exists (use raylib's FileExists)
    static bool SaveFileExists(const std::string& path) {
        return ::FileExists(path.c_str());
    }

    // Save slot management
    void Framework_Save_SetDirectory(const char* directory) {
        if (directory) g_saveDirectory = directory;
    }

    const char* Framework_Save_GetDirectory() {
        return g_saveDirectory.c_str();
    }

    int Framework_Save_GetSlotCount() {
        int count = 0;
        for (int i = 0; i < 100; i++) {  // Check up to 100 slots
            if (Framework_Save_SlotExists(i)) count++;
        }
        return count;
    }

    bool Framework_Save_SlotExists(int slot) {
        std::string path = ResolveAssetPath(GetSaveFilePath(slot).c_str());
        return SaveFileExists(path);
    }

    bool Framework_Save_DeleteSlot(int slot) {
        std::string path = ResolveAssetPath(GetSaveFilePath(slot).c_str());
        return remove(path.c_str()) == 0;
    }

    bool Framework_Save_CopySlot(int fromSlot, int toSlot) {
        if (!Framework_Save_SlotExists(fromSlot)) return false;

        std::string fromPath = ResolveAssetPath(GetSaveFilePath(fromSlot).c_str());
        std::string toPath = ResolveAssetPath(GetSaveFilePath(toSlot).c_str());

        FILE* src = nullptr;
        FILE* dst = nullptr;

        if (fopen_s(&src, fromPath.c_str(), "rb") != 0 || !src) return false;
        if (fopen_s(&dst, toPath.c_str(), "wb") != 0 || !dst) {
            fclose(src);
            return false;
        }

        char buffer[4096];
        size_t bytes;
        while ((bytes = fread(buffer, 1, sizeof(buffer), src)) > 0) {
            fwrite(buffer, 1, bytes, dst);
        }

        fclose(src);
        fclose(dst);
        return true;
    }

    const char* Framework_Save_GetSlotInfo(int slot) {
        if (!Framework_Save_SlotExists(slot)) {
            g_tempStringResult = "";
            return g_tempStringResult.c_str();
        }

        // Load just metadata from slot
        std::string path = ResolveAssetPath(GetSaveFilePath(slot).c_str());
        FILE* f = nullptr;
        if (fopen_s(&f, path.c_str(), "r") != 0 || !f) {
            g_tempStringResult = "";
            return g_tempStringResult.c_str();
        }

        g_tempStringResult = "";
        char line[512];
        while (fgets(line, sizeof(line), f)) {
            if (strncmp(line, "[META]", 6) == 0) {
                // Read metadata section
                while (fgets(line, sizeof(line), f)) {
                    if (line[0] == '[') break;  // Next section
                    g_tempStringResult += line;
                }
                break;
            }
        }

        fclose(f);
        return g_tempStringResult.c_str();
    }

    // Save/Load operations
    bool Framework_Save_BeginSave(int slot) {
        if (g_isSaving || g_isLoading) return false;

        g_saveData.clear();
        g_saveMetadata.clear();
        g_currentSaveSlot = slot;
        g_isSaving = true;

        // Add timestamp metadata
        time_t now = time(nullptr);
        char timeBuf[64];
        ctime_s(timeBuf, sizeof(timeBuf), &now);
        timeBuf[strlen(timeBuf) - 1] = '\0';  // Remove newline
        g_saveMetadata["timestamp"] = timeBuf;

        return true;
    }

    bool Framework_Save_EndSave() {
        if (!g_isSaving) return false;

        EnsureSaveDirectory();
        std::string path = ResolveAssetPath(GetSaveFilePath(g_currentSaveSlot).c_str());

        FILE* f = nullptr;
        if (fopen_s(&f, path.c_str(), "w") != 0 || !f) {
            g_isSaving = false;
            return false;
        }

        fprintf(f, "# Game Save - Slot %d\n", g_currentSaveSlot);
        fprintf(f, "version 1\n\n");

        // Write metadata
        fprintf(f, "[META]\n");
        for (const auto& kv : g_saveMetadata) {
            fprintf(f, "%s=%s\n", kv.first.c_str(), kv.second.c_str());
        }
        fprintf(f, "\n");

        // Write data
        fprintf(f, "[DATA]\n");
        for (const auto& kv : g_saveData) {
            fprintf(f, "%s=%s\n", kv.first.c_str(), kv.second.c_str());
        }

        fclose(f);
        g_isSaving = false;
        g_currentSaveSlot = -1;
        return true;
    }

    bool Framework_Save_BeginLoad(int slot) {
        if (g_isSaving || g_isLoading) return false;
        if (!Framework_Save_SlotExists(slot)) return false;

        std::string path = ResolveAssetPath(GetSaveFilePath(slot).c_str());
        FILE* f = nullptr;
        if (fopen_s(&f, path.c_str(), "r") != 0 || !f) return false;

        g_saveData.clear();
        g_saveMetadata.clear();
        g_currentSaveSlot = slot;
        g_isLoading = true;

        char line[1024];
        bool inMeta = false;
        bool inData = false;

        while (fgets(line, sizeof(line), f)) {
            // Remove newline
            size_t len = strlen(line);
            if (len > 0 && line[len - 1] == '\n') line[len - 1] = '\0';
            if (len > 1 && line[len - 2] == '\r') line[len - 2] = '\0';

            if (line[0] == '#' || line[0] == '\0') continue;

            if (strcmp(line, "[META]") == 0) { inMeta = true; inData = false; continue; }
            if (strcmp(line, "[DATA]") == 0) { inMeta = false; inData = true; continue; }

            // Parse key=value
            char* eq = strchr(line, '=');
            if (eq) {
                *eq = '\0';
                std::string key = line;
                std::string val = eq + 1;

                if (inMeta) g_saveMetadata[key] = val;
                else if (inData) g_saveData[key] = val;
            }
        }

        fclose(f);
        return true;
    }

    bool Framework_Save_EndLoad() {
        if (!g_isLoading) return false;
        g_isLoading = false;
        g_currentSaveSlot = -1;
        return true;
    }

    // Data serialization - Write
    void Framework_Save_WriteInt(const char* key, int value) {
        if (!g_isSaving || !key) return;
        g_saveData[key] = std::to_string(value);
    }

    void Framework_Save_WriteFloat(const char* key, float value) {
        if (!g_isSaving || !key) return;
        char buf[64];
        snprintf(buf, sizeof(buf), "%.6f", value);
        g_saveData[key] = buf;
    }

    void Framework_Save_WriteBool(const char* key, bool value) {
        if (!g_isSaving || !key) return;
        g_saveData[key] = value ? "true" : "false";
    }

    void Framework_Save_WriteString(const char* key, const char* value) {
        if (!g_isSaving || !key) return;
        g_saveData[key] = value ? value : "";
    }

    void Framework_Save_WriteVector2(const char* key, float x, float y) {
        if (!g_isSaving || !key) return;
        char buf[128];
        snprintf(buf, sizeof(buf), "%.6f,%.6f", x, y);
        g_saveData[key] = buf;
    }

    void Framework_Save_WriteIntArray(const char* key, const int* values, int count) {
        if (!g_isSaving || !key || !values || count <= 0) return;
        std::string result;
        for (int i = 0; i < count; i++) {
            if (i > 0) result += ",";
            result += std::to_string(values[i]);
        }
        g_saveData[key] = result;
    }

    void Framework_Save_WriteFloatArray(const char* key, const float* values, int count) {
        if (!g_isSaving || !key || !values || count <= 0) return;
        std::string result;
        char buf[32];
        for (int i = 0; i < count; i++) {
            if (i > 0) result += ",";
            snprintf(buf, sizeof(buf), "%.6f", values[i]);
            result += buf;
        }
        g_saveData[key] = result;
    }

    // Data serialization - Read
    int Framework_Save_ReadInt(const char* key, int defaultValue) {
        if (!g_isLoading || !key) return defaultValue;
        auto it = g_saveData.find(key);
        if (it == g_saveData.end()) return defaultValue;
        return atoi(it->second.c_str());
    }

    float Framework_Save_ReadFloat(const char* key, float defaultValue) {
        if (!g_isLoading || !key) return defaultValue;
        auto it = g_saveData.find(key);
        if (it == g_saveData.end()) return defaultValue;
        return (float)atof(it->second.c_str());
    }

    bool Framework_Save_ReadBool(const char* key, bool defaultValue) {
        if (!g_isLoading || !key) return defaultValue;
        auto it = g_saveData.find(key);
        if (it == g_saveData.end()) return defaultValue;
        return it->second == "true" || it->second == "1";
    }

    const char* Framework_Save_ReadString(const char* key, const char* defaultValue) {
        if (!g_isLoading || !key) return defaultValue;
        auto it = g_saveData.find(key);
        if (it == g_saveData.end()) return defaultValue;
        g_tempStringResult = it->second;
        return g_tempStringResult.c_str();
    }

    void Framework_Save_ReadVector2(const char* key, float* x, float* y, float defX, float defY) {
        if (!g_isLoading || !key) {
            if (x) *x = defX;
            if (y) *y = defY;
            return;
        }
        auto it = g_saveData.find(key);
        if (it == g_saveData.end()) {
            if (x) *x = defX;
            if (y) *y = defY;
            return;
        }
        float fx = defX, fy = defY;
        sscanf_s(it->second.c_str(), "%f,%f", &fx, &fy);
        if (x) *x = fx;
        if (y) *y = fy;
    }

    int Framework_Save_ReadIntArray(const char* key, int* buffer, int bufferSize) {
        if (!g_isLoading || !key || !buffer || bufferSize <= 0) return 0;
        auto it = g_saveData.find(key);
        if (it == g_saveData.end()) return 0;

        int count = 0;
        const char* str = it->second.c_str();
        const char* p = str;

        while (*p && count < bufferSize) {
            buffer[count++] = atoi(p);
            p = strchr(p, ',');
            if (!p) break;
            p++;  // Skip comma
        }
        return count;
    }

    int Framework_Save_ReadFloatArray(const char* key, float* buffer, int bufferSize) {
        if (!g_isLoading || !key || !buffer || bufferSize <= 0) return 0;
        auto it = g_saveData.find(key);
        if (it == g_saveData.end()) return 0;

        int count = 0;
        const char* str = it->second.c_str();
        const char* p = str;

        while (*p && count < bufferSize) {
            buffer[count++] = (float)atof(p);
            p = strchr(p, ',');
            if (!p) break;
            p++;  // Skip comma
        }
        return count;
    }

    bool Framework_Save_HasKey(const char* key) {
        if (!g_isLoading || !key) return false;
        return g_saveData.find(key) != g_saveData.end();
    }

    // Metadata
    void Framework_Save_SetMetadata(const char* key, const char* value) {
        if (!g_isSaving || !key) return;
        g_saveMetadata[key] = value ? value : "";
    }

    const char* Framework_Save_GetMetadata(int slot, const char* key) {
        // Need to load the slot temporarily to get metadata
        if (!key) return "";

        std::string path = ResolveAssetPath(GetSaveFilePath(slot).c_str());
        FILE* f = nullptr;
        if (fopen_s(&f, path.c_str(), "r") != 0 || !f) return "";

        char line[1024];
        bool inMeta = false;
        g_tempStringResult = "";

        while (fgets(line, sizeof(line), f)) {
            size_t len = strlen(line);
            if (len > 0 && line[len - 1] == '\n') line[len - 1] = '\0';

            if (strcmp(line, "[META]") == 0) { inMeta = true; continue; }
            if (line[0] == '[') { inMeta = false; continue; }

            if (inMeta) {
                char* eq = strchr(line, '=');
                if (eq) {
                    *eq = '\0';
                    if (strcmp(line, key) == 0) {
                        g_tempStringResult = eq + 1;
                        break;
                    }
                }
            }
        }

        fclose(f);
        return g_tempStringResult.c_str();
    }

    // Auto-save
    void Framework_Save_SetAutoSaveEnabled(bool enabled) {
        g_autoSaveEnabled = enabled;
        g_autoSaveTimer = 0;
    }

    bool Framework_Save_IsAutoSaveEnabled() {
        return g_autoSaveEnabled;
    }

    void Framework_Save_SetAutoSaveInterval(float seconds) {
        g_autoSaveInterval = seconds > 1.0f ? seconds : 1.0f;
    }

    float Framework_Save_GetAutoSaveInterval() {
        return g_autoSaveInterval;
    }

    void Framework_Save_SetAutoSaveSlot(int slot) {
        g_autoSaveSlot = slot;
    }

    int Framework_Save_GetAutoSaveSlot() {
        return g_autoSaveSlot;
    }

    void Framework_Save_TriggerAutoSave() {
        int slot = g_autoSaveSlot;
        if (slot < 0) {
            // Rotating slots: use 90-99 for auto-saves
            slot = 90 + (g_autoSaveRotation % 10);
            g_autoSaveRotation++;
        }

        // Quick auto-save - just mark that auto-save should happen
        // Game code needs to handle the actual save in their update loop
        if (Framework_Save_BeginSave(slot)) {
            Framework_Save_SetMetadata("type", "autosave");
            // Note: Game code must call WriteXxx functions and EndSave
        }
    }

    void Framework_Save_Update(float dt) {
        if (!g_autoSaveEnabled) return;

        g_autoSaveTimer += dt;
        if (g_autoSaveTimer >= g_autoSaveInterval) {
            g_autoSaveTimer = 0;
            Framework_Save_TriggerAutoSave();
        }
    }

    // Quick save/load
    bool Framework_Save_QuickSave() {
        return Framework_Save_BeginSave(0);
        // Note: Caller must write data and call EndSave
    }

    bool Framework_Save_QuickLoad() {
        return Framework_Save_BeginLoad(0);
        // Note: Caller must read data and call EndLoad
    }

    // Settings (persistent across sessions)
    void Framework_Settings_SetInt(const char* key, int value) {
        if (!key) return;
        g_settings[key] = std::to_string(value);
    }

    int Framework_Settings_GetInt(const char* key, int defaultValue) {
        if (!key) return defaultValue;
        auto it = g_settings.find(key);
        if (it == g_settings.end()) return defaultValue;
        return atoi(it->second.c_str());
    }

    void Framework_Settings_SetFloat(const char* key, float value) {
        if (!key) return;
        char buf[64];
        snprintf(buf, sizeof(buf), "%.6f", value);
        g_settings[key] = buf;
    }

    float Framework_Settings_GetFloat(const char* key, float defaultValue) {
        if (!key) return defaultValue;
        auto it = g_settings.find(key);
        if (it == g_settings.end()) return defaultValue;
        return (float)atof(it->second.c_str());
    }

    void Framework_Settings_SetBool(const char* key, bool value) {
        if (!key) return;
        g_settings[key] = value ? "true" : "false";
    }

    bool Framework_Settings_GetBool(const char* key, bool defaultValue) {
        if (!key) return defaultValue;
        auto it = g_settings.find(key);
        if (it == g_settings.end()) return defaultValue;
        return it->second == "true" || it->second == "1";
    }

    void Framework_Settings_SetString(const char* key, const char* value) {
        if (!key) return;
        g_settings[key] = value ? value : "";
    }

    const char* Framework_Settings_GetString(const char* key, const char* defaultValue) {
        if (!key) return defaultValue;
        auto it = g_settings.find(key);
        if (it == g_settings.end()) return defaultValue;
        g_tempStringResult = it->second;
        return g_tempStringResult.c_str();
    }

    bool Framework_Settings_Save() {
        EnsureSaveDirectory();
        std::string path = ResolveAssetPath(GetSettingsFilePath().c_str());

        FILE* f = nullptr;
        if (fopen_s(&f, path.c_str(), "w") != 0 || !f) return false;

        fprintf(f, "# Game Settings\n");
        fprintf(f, "version 1\n\n");

        for (const auto& kv : g_settings) {
            fprintf(f, "%s=%s\n", kv.first.c_str(), kv.second.c_str());
        }

        fclose(f);
        return true;
    }

    bool Framework_Settings_Load() {
        std::string path = ResolveAssetPath(GetSettingsFilePath().c_str());

        FILE* f = nullptr;
        if (fopen_s(&f, path.c_str(), "r") != 0 || !f) return false;

        g_settings.clear();
        char line[1024];

        while (fgets(line, sizeof(line), f)) {
            size_t len = strlen(line);
            if (len > 0 && line[len - 1] == '\n') line[len - 1] = '\0';
            if (len > 1 && line[len - 2] == '\r') line[len - 2] = '\0';

            if (line[0] == '#' || line[0] == '\0') continue;
            if (strncmp(line, "version", 7) == 0) continue;

            char* eq = strchr(line, '=');
            if (eq) {
                *eq = '\0';
                g_settings[line] = eq + 1;
            }
        }

        fclose(f);
        return true;
    }

    void Framework_Settings_Clear() {
        g_settings.clear();
    }

    // ========================================================================
    // TWEENING SYSTEM - Property Animation & Interpolation
    // ========================================================================
}  // Temporarily close extern "C" for namespace

namespace {
    // Tween type enumeration
    enum TweenType {
        TWEEN_TYPE_FLOAT,
        TWEEN_TYPE_VECTOR2,
        TWEEN_TYPE_COLOR
    };

    // Tween data structure
    struct Tween {
        int id = 0;
        TweenType type = TWEEN_TYPE_FLOAT;
        TweenState state = TWEEN_STATE_IDLE;
        TweenEasing easing = TWEEN_LINEAR;
        TweenLoopMode loopMode = TWEEN_LOOP_NONE;

        // Timing
        float duration = 1.0f;
        float elapsed = 0.0f;
        float delay = 0.0f;
        float delayElapsed = 0.0f;
        float timeScale = 1.0f;

        // Loop
        int loopCount = 0;       // 0 = once, -1 = infinite
        int currentLoop = 0;
        bool yoyoReverse = false;

        // Values
        float fromFloat = 0, toFloat = 0, currentFloat = 0;
        float fromX = 0, fromY = 0, toX = 0, toY = 0, currentX = 0, currentY = 0;
        unsigned char fromR = 0, fromG = 0, fromB = 0, fromA = 0;
        unsigned char toR = 0, toG = 0, toB = 0, toA = 0;
        unsigned char currentR = 0, currentG = 0, currentB = 0, currentA = 0;

        // Target pointers (for direct tweening)
        float* targetFloat = nullptr;
        float* targetX = nullptr;
        float* targetY = nullptr;

        // Entity target (for convenience tweens)
        int targetEntity = -1;

        // Callbacks
        TweenCallback onStart = nullptr;
        TweenUpdateCallback onUpdate = nullptr;
        TweenCallback onComplete = nullptr;
        TweenCallback onLoop = nullptr;
        TweenCallback onKill = nullptr;

        // Options
        bool autoKill = true;
        bool started = false;
    };

    // Sequence entry
    struct SequenceEntry {
        int tweenId = -1;
        float startTime = 0;
        TweenCallback callback = nullptr;
        bool isCallback = false;
        bool isDelay = false;
        float delayDuration = 0;
    };

    // Sequence structure
    struct TweenSequence {
        int id = 0;
        std::vector<SequenceEntry> entries;
        float duration = 0;
        float elapsed = 0;
        TweenState state = TWEEN_STATE_IDLE;
        bool autoKill = true;
    };

    // Global tween state
    std::unordered_map<int, Tween> g_tweens;
    std::unordered_map<int, TweenSequence> g_sequences;
    int g_nextTweenId = 1;
    int g_nextSequenceId = 1;
    float g_globalTweenTimeScale = 1.0f;
    bool g_tweensPaused = false;

    // Extended easing function
    const float TWEEN_PI = 3.14159265358979323846f;

    float ApplyTweenEasing(float t, TweenEasing easing) {
        const float c1 = 1.70158f;
        const float c2 = c1 * 1.525f;
        const float c3 = c1 + 1.0f;
        const float c4 = (2.0f * TWEEN_PI) / 3.0f;
        const float c5 = (2.0f * TWEEN_PI) / 4.5f;

        switch (easing) {
            case TWEEN_LINEAR: return t;
            case TWEEN_IN_QUAD: return t * t;
            case TWEEN_OUT_QUAD: return 1.0f - (1.0f - t) * (1.0f - t);
            case TWEEN_IN_OUT_QUAD: return t < 0.5f ? 2.0f * t * t : 1.0f - powf(-2.0f * t + 2.0f, 2.0f) / 2.0f;
            case TWEEN_IN_CUBIC: return t * t * t;
            case TWEEN_OUT_CUBIC: return 1.0f - powf(1.0f - t, 3.0f);
            case TWEEN_IN_OUT_CUBIC: return t < 0.5f ? 4.0f * t * t * t : 1.0f - powf(-2.0f * t + 2.0f, 3.0f) / 2.0f;
            case TWEEN_IN_EXPO: return t == 0.0f ? 0.0f : powf(2.0f, 10.0f * t - 10.0f);
            case TWEEN_OUT_EXPO: return t == 1.0f ? 1.0f : 1.0f - powf(2.0f, -10.0f * t);
            case TWEEN_IN_OUT_EXPO:
                if (t == 0.0f) return 0.0f;
                if (t == 1.0f) return 1.0f;
                return t < 0.5f ? powf(2.0f, 20.0f * t - 10.0f) / 2.0f : (2.0f - powf(2.0f, -20.0f * t + 10.0f)) / 2.0f;
            case TWEEN_IN_SINE: return 1.0f - cosf((t * TWEEN_PI) / 2.0f);
            case TWEEN_OUT_SINE: return sinf((t * TWEEN_PI) / 2.0f);
            case TWEEN_IN_OUT_SINE: return -(cosf(TWEEN_PI * t) - 1.0f) / 2.0f;
            case TWEEN_IN_BACK: return c3 * t * t * t - c1 * t * t;
            case TWEEN_OUT_BACK: return 1.0f + c3 * powf(t - 1.0f, 3.0f) + c1 * powf(t - 1.0f, 2.0f);
            case TWEEN_IN_OUT_BACK:
                return t < 0.5f
                    ? (powf(2.0f * t, 2.0f) * ((c2 + 1.0f) * 2.0f * t - c2)) / 2.0f
                    : (powf(2.0f * t - 2.0f, 2.0f) * ((c2 + 1.0f) * (t * 2.0f - 2.0f) + c2) + 2.0f) / 2.0f;
            case TWEEN_IN_ELASTIC:
                if (t == 0.0f) return 0.0f;
                if (t == 1.0f) return 1.0f;
                return -powf(2.0f, 10.0f * t - 10.0f) * sinf((t * 10.0f - 10.75f) * c4);
            case TWEEN_OUT_ELASTIC:
                if (t == 0.0f) return 0.0f;
                if (t == 1.0f) return 1.0f;
                return powf(2.0f, -10.0f * t) * sinf((t * 10.0f - 0.75f) * c4) + 1.0f;
            case TWEEN_IN_OUT_ELASTIC:
                if (t == 0.0f) return 0.0f;
                if (t == 1.0f) return 1.0f;
                return t < 0.5f
                    ? -(powf(2.0f, 20.0f * t - 10.0f) * sinf((20.0f * t - 11.125f) * c5)) / 2.0f
                    : (powf(2.0f, -20.0f * t + 10.0f) * sinf((20.0f * t - 11.125f) * c5)) / 2.0f + 1.0f;
            case TWEEN_IN_BOUNCE: return 1.0f - ApplyTweenEasing(1.0f - t, TWEEN_OUT_BOUNCE);
            case TWEEN_OUT_BOUNCE: {
                const float n1 = 7.5625f;
                const float d1 = 2.75f;
                if (t < 1.0f / d1) return n1 * t * t;
                if (t < 2.0f / d1) return n1 * (t -= 1.5f / d1) * t + 0.75f;
                if (t < 2.5f / d1) return n1 * (t -= 2.25f / d1) * t + 0.9375f;
                return n1 * (t -= 2.625f / d1) * t + 0.984375f;
            }
            case TWEEN_IN_OUT_BOUNCE:
                return t < 0.5f
                    ? (1.0f - ApplyTweenEasing(1.0f - 2.0f * t, TWEEN_OUT_BOUNCE)) / 2.0f
                    : (1.0f + ApplyTweenEasing(2.0f * t - 1.0f, TWEEN_OUT_BOUNCE)) / 2.0f;
            default: return t;
        }
    }

    // Update a single tween
    void UpdateTween(Tween& tw, float dt) {
        if (tw.state != TWEEN_STATE_PLAYING) return;

        // Handle delay
        if (tw.delayElapsed < tw.delay) {
            tw.delayElapsed += dt;
            if (tw.delayElapsed < tw.delay) return;
            // Start callback
            if (!tw.started && tw.onStart) {
                tw.started = true;
                tw.onStart(tw.id);
            }
        }

        if (!tw.started && tw.onStart) {
            tw.started = true;
            tw.onStart(tw.id);
        }

        // Update elapsed time
        tw.elapsed += dt * tw.timeScale;

        // Calculate progress
        float progress = tw.duration > 0.0f ? tw.elapsed / tw.duration : 1.0f;
        if (progress > 1.0f) progress = 1.0f;

        // Handle yoyo reverse
        float easedProgress = progress;
        if (tw.yoyoReverse) {
            easedProgress = ApplyTweenEasing(1.0f - progress, tw.easing);
        } else {
            easedProgress = ApplyTweenEasing(progress, tw.easing);
        }

        // Update values based on type
        switch (tw.type) {
            case TWEEN_TYPE_FLOAT:
                tw.currentFloat = tw.fromFloat + (tw.toFloat - tw.fromFloat) * easedProgress;
                if (tw.targetFloat) *tw.targetFloat = tw.currentFloat;
                break;
            case TWEEN_TYPE_VECTOR2:
                tw.currentX = tw.fromX + (tw.toX - tw.fromX) * easedProgress;
                tw.currentY = tw.fromY + (tw.toY - tw.fromY) * easedProgress;
                if (tw.targetX) *tw.targetX = tw.currentX;
                if (tw.targetY) *tw.targetY = tw.currentY;
                break;
            case TWEEN_TYPE_COLOR:
                tw.currentR = (unsigned char)(tw.fromR + (tw.toR - tw.fromR) * easedProgress);
                tw.currentG = (unsigned char)(tw.fromG + (tw.toG - tw.fromG) * easedProgress);
                tw.currentB = (unsigned char)(tw.fromB + (tw.toB - tw.fromB) * easedProgress);
                tw.currentA = (unsigned char)(tw.fromA + (tw.toA - tw.fromA) * easedProgress);
                break;
        }

        // Update callback
        if (tw.onUpdate) {
            tw.onUpdate(tw.id, tw.currentFloat);
        }

        // Check completion
        if (progress >= 1.0f) {
            // Handle looping
            bool shouldLoop = false;
            if (tw.loopCount < 0 || tw.currentLoop < tw.loopCount) {
                shouldLoop = true;
            }

            if (shouldLoop && tw.loopMode != TWEEN_LOOP_NONE) {
                tw.currentLoop++;
                tw.elapsed = 0.0f;

                if (tw.onLoop) tw.onLoop(tw.id);

                if (tw.loopMode == TWEEN_LOOP_YOYO) {
                    tw.yoyoReverse = !tw.yoyoReverse;
                }
                else if (tw.loopMode == TWEEN_LOOP_INCREMENT) {
                    // Shift values for incremental loops
                    float delta = tw.toFloat - tw.fromFloat;
                    tw.fromFloat = tw.toFloat;
                    tw.toFloat += delta;

                    float deltaX = tw.toX - tw.fromX;
                    float deltaY = tw.toY - tw.fromY;
                    tw.fromX = tw.toX;
                    tw.fromY = tw.toY;
                    tw.toX += deltaX;
                    tw.toY += deltaY;
                }
            }
            else {
                tw.state = TWEEN_STATE_COMPLETED;
                if (tw.onComplete) tw.onComplete(tw.id);
            }
        }
    }

    Tween* GetTween(int id) {
        auto it = g_tweens.find(id);
        return it != g_tweens.end() ? &it->second : nullptr;
    }

    TweenSequence* GetSequence(int id) {
        auto it = g_sequences.find(id);
        return it != g_sequences.end() ? &it->second : nullptr;
    }
}

// Forward declarations for ECS functions used by entity tweens
extern "C" {
    bool Framework_Ecs_IsAlive(int entity);
    bool Framework_Ecs_HasTransform2D(int entity);
    Vector2 Framework_Ecs_GetTransformPosition(int entity);
    void Framework_Ecs_SetTransformPosition(int entity, float x, float y);
    float Framework_Ecs_GetTransformRotation(int entity);
    void Framework_Ecs_SetTransformRotation(int entity, float rotation);
    Vector2 Framework_Ecs_GetTransformScale(int entity);
    void Framework_Ecs_SetTransformScale(int entity, float sx, float sy);
    bool Framework_Ecs_HasSprite2D(int entity);
    void Framework_Ecs_SetSpriteTint(int entity, unsigned char r, unsigned char g, unsigned char b, unsigned char a);
}

extern "C" {
    // Float tweens
    int Framework_Tween_Float(float from, float to, float duration, int easing) {
        Tween tw;
        tw.id = g_nextTweenId++;
        tw.type = TWEEN_TYPE_FLOAT;
        tw.fromFloat = from;
        tw.toFloat = to;
        tw.currentFloat = from;
        tw.duration = duration;
        tw.easing = (TweenEasing)easing;
        tw.state = TWEEN_STATE_PLAYING;
        g_tweens[tw.id] = tw;
        return tw.id;
    }

    int Framework_Tween_FloatTo(float* target, float to, float duration, int easing) {
        if (!target) return -1;
        Tween tw;
        tw.id = g_nextTweenId++;
        tw.type = TWEEN_TYPE_FLOAT;
        tw.targetFloat = target;
        tw.fromFloat = *target;
        tw.toFloat = to;
        tw.currentFloat = *target;
        tw.duration = duration;
        tw.easing = (TweenEasing)easing;
        tw.state = TWEEN_STATE_PLAYING;
        g_tweens[tw.id] = tw;
        return tw.id;
    }

    int Framework_Tween_FloatFromTo(float* target, float from, float to, float duration, int easing) {
        if (!target) return -1;
        Tween tw;
        tw.id = g_nextTweenId++;
        tw.type = TWEEN_TYPE_FLOAT;
        tw.targetFloat = target;
        tw.fromFloat = from;
        tw.toFloat = to;
        tw.currentFloat = from;
        *target = from;
        tw.duration = duration;
        tw.easing = (TweenEasing)easing;
        tw.state = TWEEN_STATE_PLAYING;
        g_tweens[tw.id] = tw;
        return tw.id;
    }

    // Vector2 tweens
    int Framework_Tween_Vector2(float fromX, float fromY, float toX, float toY, float duration, int easing) {
        Tween tw;
        tw.id = g_nextTweenId++;
        tw.type = TWEEN_TYPE_VECTOR2;
        tw.fromX = fromX; tw.fromY = fromY;
        tw.toX = toX; tw.toY = toY;
        tw.currentX = fromX; tw.currentY = fromY;
        tw.duration = duration;
        tw.easing = (TweenEasing)easing;
        tw.state = TWEEN_STATE_PLAYING;
        g_tweens[tw.id] = tw;
        return tw.id;
    }

    int Framework_Tween_Vector2To(float* targetX, float* targetY, float toX, float toY, float duration, int easing) {
        if (!targetX || !targetY) return -1;
        Tween tw;
        tw.id = g_nextTweenId++;
        tw.type = TWEEN_TYPE_VECTOR2;
        tw.targetX = targetX;
        tw.targetY = targetY;
        tw.fromX = *targetX; tw.fromY = *targetY;
        tw.toX = toX; tw.toY = toY;
        tw.currentX = *targetX; tw.currentY = *targetY;
        tw.duration = duration;
        tw.easing = (TweenEasing)easing;
        tw.state = TWEEN_STATE_PLAYING;
        g_tweens[tw.id] = tw;
        return tw.id;
    }

    // Color tweens
    int Framework_Tween_Color(unsigned char fromR, unsigned char fromG, unsigned char fromB, unsigned char fromA,
                              unsigned char toR, unsigned char toG, unsigned char toB, unsigned char toA,
                              float duration, int easing) {
        Tween tw;
        tw.id = g_nextTweenId++;
        tw.type = TWEEN_TYPE_COLOR;
        tw.fromR = fromR; tw.fromG = fromG; tw.fromB = fromB; tw.fromA = fromA;
        tw.toR = toR; tw.toG = toG; tw.toB = toB; tw.toA = toA;
        tw.currentR = fromR; tw.currentG = fromG; tw.currentB = fromB; tw.currentA = fromA;
        tw.duration = duration;
        tw.easing = (TweenEasing)easing;
        tw.state = TWEEN_STATE_PLAYING;
        g_tweens[tw.id] = tw;
        return tw.id;
    }

    // Tween control
    void Framework_Tween_Play(int tweenId) {
        if (auto* tw = GetTween(tweenId)) tw->state = TWEEN_STATE_PLAYING;
    }

    void Framework_Tween_Pause(int tweenId) {
        if (auto* tw = GetTween(tweenId)) {
            if (tw->state == TWEEN_STATE_PLAYING) tw->state = TWEEN_STATE_PAUSED;
        }
    }

    void Framework_Tween_Resume(int tweenId) {
        if (auto* tw = GetTween(tweenId)) {
            if (tw->state == TWEEN_STATE_PAUSED) tw->state = TWEEN_STATE_PLAYING;
        }
    }

    void Framework_Tween_Stop(int tweenId) {
        if (auto* tw = GetTween(tweenId)) tw->state = TWEEN_STATE_IDLE;
    }

    void Framework_Tween_Restart(int tweenId) {
        if (auto* tw = GetTween(tweenId)) {
            tw->elapsed = 0.0f;
            tw->delayElapsed = 0.0f;
            tw->currentLoop = 0;
            tw->yoyoReverse = false;
            tw->started = false;
            tw->state = TWEEN_STATE_PLAYING;
        }
    }

    void Framework_Tween_Kill(int tweenId) {
        auto it = g_tweens.find(tweenId);
        if (it != g_tweens.end()) {
            if (it->second.onKill) it->second.onKill(tweenId);
            g_tweens.erase(it);
        }
    }

    void Framework_Tween_Complete(int tweenId) {
        if (auto* tw = GetTween(tweenId)) {
            tw->elapsed = tw->duration;
            UpdateTween(*tw, 0);  // Force final update
        }
    }

    // Tween state queries
    bool Framework_Tween_IsValid(int tweenId) {
        return g_tweens.find(tweenId) != g_tweens.end();
    }

    int Framework_Tween_GetState(int tweenId) {
        if (auto* tw = GetTween(tweenId)) return (int)tw->state;
        return (int)TWEEN_STATE_IDLE;
    }

    bool Framework_Tween_IsPlaying(int tweenId) {
        if (auto* tw = GetTween(tweenId)) return tw->state == TWEEN_STATE_PLAYING;
        return false;
    }

    bool Framework_Tween_IsPaused(int tweenId) {
        if (auto* tw = GetTween(tweenId)) return tw->state == TWEEN_STATE_PAUSED;
        return false;
    }

    bool Framework_Tween_IsCompleted(int tweenId) {
        if (auto* tw = GetTween(tweenId)) return tw->state == TWEEN_STATE_COMPLETED;
        return false;
    }

    float Framework_Tween_GetProgress(int tweenId) {
        if (auto* tw = GetTween(tweenId)) {
            return tw->duration > 0 ? tw->elapsed / tw->duration : 1.0f;
        }
        return 0.0f;
    }

    float Framework_Tween_GetElapsed(int tweenId) {
        if (auto* tw = GetTween(tweenId)) return tw->elapsed;
        return 0.0f;
    }

    float Framework_Tween_GetDuration(int tweenId) {
        if (auto* tw = GetTween(tweenId)) return tw->duration;
        return 0.0f;
    }

    // Tween value getters
    float Framework_Tween_GetFloat(int tweenId) {
        if (auto* tw = GetTween(tweenId)) return tw->currentFloat;
        return 0.0f;
    }

    void Framework_Tween_GetVector2(int tweenId, float* x, float* y) {
        if (auto* tw = GetTween(tweenId)) {
            if (x) *x = tw->currentX;
            if (y) *y = tw->currentY;
        }
    }

    void Framework_Tween_GetColor(int tweenId, unsigned char* r, unsigned char* g, unsigned char* b, unsigned char* a) {
        if (auto* tw = GetTween(tweenId)) {
            if (r) *r = tw->currentR;
            if (g) *g = tw->currentG;
            if (b) *b = tw->currentB;
            if (a) *a = tw->currentA;
        }
    }

    // Tween configuration
    void Framework_Tween_SetDelay(int tweenId, float delay) {
        if (auto* tw = GetTween(tweenId)) tw->delay = delay;
    }

    float Framework_Tween_GetDelay(int tweenId) {
        if (auto* tw = GetTween(tweenId)) return tw->delay;
        return 0.0f;
    }

    void Framework_Tween_SetLoopMode(int tweenId, int loopMode) {
        if (auto* tw = GetTween(tweenId)) tw->loopMode = (TweenLoopMode)loopMode;
    }

    int Framework_Tween_GetLoopMode(int tweenId) {
        if (auto* tw = GetTween(tweenId)) return (int)tw->loopMode;
        return (int)TWEEN_LOOP_NONE;
    }

    void Framework_Tween_SetLoopCount(int tweenId, int count) {
        if (auto* tw = GetTween(tweenId)) tw->loopCount = count;
    }

    int Framework_Tween_GetLoopCount(int tweenId) {
        if (auto* tw = GetTween(tweenId)) return tw->loopCount;
        return 0;
    }

    int Framework_Tween_GetCurrentLoop(int tweenId) {
        if (auto* tw = GetTween(tweenId)) return tw->currentLoop;
        return 0;
    }

    void Framework_Tween_SetTimeScale(int tweenId, float scale) {
        if (auto* tw = GetTween(tweenId)) tw->timeScale = scale;
    }

    float Framework_Tween_GetTimeScale(int tweenId) {
        if (auto* tw = GetTween(tweenId)) return tw->timeScale;
        return 1.0f;
    }

    void Framework_Tween_SetAutoKill(int tweenId, bool autoKill) {
        if (auto* tw = GetTween(tweenId)) tw->autoKill = autoKill;
    }

    // Tween callbacks
    void Framework_Tween_SetOnStart(int tweenId, TweenCallback callback) {
        if (auto* tw = GetTween(tweenId)) tw->onStart = callback;
    }

    void Framework_Tween_SetOnUpdate(int tweenId, TweenUpdateCallback callback) {
        if (auto* tw = GetTween(tweenId)) tw->onUpdate = callback;
    }

    void Framework_Tween_SetOnComplete(int tweenId, TweenCallback callback) {
        if (auto* tw = GetTween(tweenId)) tw->onComplete = callback;
    }

    void Framework_Tween_SetOnLoop(int tweenId, TweenCallback callback) {
        if (auto* tw = GetTween(tweenId)) tw->onLoop = callback;
    }

    void Framework_Tween_SetOnKill(int tweenId, TweenCallback callback) {
        if (auto* tw = GetTween(tweenId)) tw->onKill = callback;
    }

    // Sequence building
    int Framework_Tween_CreateSequence() {
        TweenSequence seq;
        seq.id = g_nextSequenceId++;
        g_sequences[seq.id] = seq;
        return seq.id;
    }

    void Framework_Tween_SequenceAppend(int seqId, int tweenId) {
        auto* seq = GetSequence(seqId);
        auto* tw = GetTween(tweenId);
        if (!seq || !tw) return;

        SequenceEntry entry;
        entry.tweenId = tweenId;
        entry.startTime = seq->duration;
        seq->entries.push_back(entry);
        seq->duration += tw->duration + tw->delay;

        // Pause the tween until sequence starts
        tw->state = TWEEN_STATE_PAUSED;
    }

    void Framework_Tween_SequenceJoin(int seqId, int tweenId) {
        auto* seq = GetSequence(seqId);
        auto* tw = GetTween(tweenId);
        if (!seq || !tw || seq->entries.empty()) return;

        // Find start time of last entry
        float lastStart = seq->entries.back().startTime;

        SequenceEntry entry;
        entry.tweenId = tweenId;
        entry.startTime = lastStart;
        seq->entries.push_back(entry);

        // Extend duration if this tween is longer
        float entryEnd = lastStart + tw->duration + tw->delay;
        if (entryEnd > seq->duration) seq->duration = entryEnd;

        tw->state = TWEEN_STATE_PAUSED;
    }

    void Framework_Tween_SequenceInsert(int seqId, float atTime, int tweenId) {
        auto* seq = GetSequence(seqId);
        auto* tw = GetTween(tweenId);
        if (!seq || !tw) return;

        SequenceEntry entry;
        entry.tweenId = tweenId;
        entry.startTime = atTime;
        seq->entries.push_back(entry);

        float entryEnd = atTime + tw->duration + tw->delay;
        if (entryEnd > seq->duration) seq->duration = entryEnd;

        tw->state = TWEEN_STATE_PAUSED;
    }

    void Framework_Tween_SequenceAppendDelay(int seqId, float delay) {
        auto* seq = GetSequence(seqId);
        if (!seq) return;

        SequenceEntry entry;
        entry.isDelay = true;
        entry.delayDuration = delay;
        entry.startTime = seq->duration;
        seq->entries.push_back(entry);
        seq->duration += delay;
    }

    void Framework_Tween_SequenceAppendCallback(int seqId, TweenCallback callback) {
        auto* seq = GetSequence(seqId);
        if (!seq) return;

        SequenceEntry entry;
        entry.isCallback = true;
        entry.callback = callback;
        entry.startTime = seq->duration;
        seq->entries.push_back(entry);
    }

    void Framework_Tween_PlaySequence(int seqId) {
        auto* seq = GetSequence(seqId);
        if (!seq) return;
        seq->state = TWEEN_STATE_PLAYING;
        seq->elapsed = 0;
    }

    void Framework_Tween_PauseSequence(int seqId) {
        auto* seq = GetSequence(seqId);
        if (!seq) return;
        if (seq->state == TWEEN_STATE_PLAYING) seq->state = TWEEN_STATE_PAUSED;
    }

    void Framework_Tween_StopSequence(int seqId) {
        auto* seq = GetSequence(seqId);
        if (!seq) return;
        seq->state = TWEEN_STATE_IDLE;
    }

    void Framework_Tween_KillSequence(int seqId) {
        auto it = g_sequences.find(seqId);
        if (it != g_sequences.end()) {
            // Kill all tweens in sequence
            for (auto& entry : it->second.entries) {
                if (entry.tweenId >= 0) {
                    Framework_Tween_Kill(entry.tweenId);
                }
            }
            g_sequences.erase(it);
        }
    }

    bool Framework_Tween_IsSequenceValid(int seqId) {
        return g_sequences.find(seqId) != g_sequences.end();
    }

    bool Framework_Tween_IsSequencePlaying(int seqId) {
        auto* seq = GetSequence(seqId);
        return seq && seq->state == TWEEN_STATE_PLAYING;
    }

    float Framework_Tween_GetSequenceDuration(int seqId) {
        auto* seq = GetSequence(seqId);
        return seq ? seq->duration : 0.0f;
    }

    // Entity property tweens
    int Framework_Tween_EntityPosition(int entity, float toX, float toY, float duration, int easing) {
        if (!Framework_Ecs_HasTransform2D(entity)) return -1;

        Vector2 pos = Framework_Ecs_GetTransformPosition(entity);

        int tweenId = Framework_Tween_Vector2(pos.x, pos.y, toX, toY, duration, easing);
        if (auto* tw = GetTween(tweenId)) {
            tw->targetEntity = entity;
        }
        return tweenId;
    }

    int Framework_Tween_EntityRotation(int entity, float toRotation, float duration, int easing) {
        if (!Framework_Ecs_HasTransform2D(entity)) return -1;

        float rot = Framework_Ecs_GetTransformRotation(entity);
        int tweenId = Framework_Tween_Float(rot, toRotation, duration, easing);
        if (auto* tw = GetTween(tweenId)) {
            tw->targetEntity = entity;
        }
        return tweenId;
    }

    int Framework_Tween_EntityScale(int entity, float toScaleX, float toScaleY, float duration, int easing) {
        if (!Framework_Ecs_HasTransform2D(entity)) return -1;

        Vector2 scale = Framework_Ecs_GetTransformScale(entity);

        int tweenId = Framework_Tween_Vector2(scale.x, scale.y, toScaleX, toScaleY, duration, easing);
        if (auto* tw = GetTween(tweenId)) {
            tw->targetEntity = entity;
        }
        return tweenId;
    }

    int Framework_Tween_EntityAlpha(int entity, unsigned char toAlpha, float duration, int easing) {
        if (!Framework_Ecs_HasSprite2D(entity)) return -1;

        // Get current alpha from sprite component directly
        auto it = g_sprite2D.find(entity);
        if (it == g_sprite2D.end()) return -1;
        unsigned char a = it->second.tint.a;

        int tweenId = Framework_Tween_Float((float)a, (float)toAlpha, duration, easing);
        if (auto* tw = GetTween(tweenId)) {
            tw->targetEntity = entity;
        }
        return tweenId;
    }

    // Global tween management
    void Framework_Tween_Update(float dt) {
        if (g_tweensPaused) return;

        float scaledDt = dt * g_globalTweenTimeScale;

        // Update all tweens
        std::vector<int> toRemove;
        for (auto& pair : g_tweens) {
            UpdateTween(pair.second, scaledDt);

            // Update entity properties if applicable
            Tween& tw = pair.second;
            if (tw.targetEntity >= 0 && Framework_Ecs_IsAlive(tw.targetEntity)) {
                if (tw.type == TWEEN_TYPE_VECTOR2 && Framework_Ecs_HasTransform2D(tw.targetEntity)) {
                    Framework_Ecs_SetTransformPosition(tw.targetEntity, tw.currentX, tw.currentY);
                }
                else if (tw.type == TWEEN_TYPE_FLOAT) {
                    // Could be rotation or alpha
                    if (Framework_Ecs_HasTransform2D(tw.targetEntity)) {
                        Framework_Ecs_SetTransformRotation(tw.targetEntity, tw.currentFloat);
                    }
                }
            }

            if (tw.state == TWEEN_STATE_COMPLETED && tw.autoKill) {
                toRemove.push_back(pair.first);
            }
        }

        // Remove completed auto-kill tweens
        for (int id : toRemove) {
            g_tweens.erase(id);
        }

        // Update sequences
        std::vector<int> seqToRemove;
        for (auto& pair : g_sequences) {
            TweenSequence& seq = pair.second;
            if (seq.state != TWEEN_STATE_PLAYING) continue;

            float prevElapsed = seq.elapsed;
            seq.elapsed += scaledDt;

            // Check entries that should start
            for (auto& entry : seq.entries) {
                if (entry.startTime >= prevElapsed && entry.startTime < seq.elapsed) {
                    if (entry.isCallback && entry.callback) {
                        entry.callback(seq.id);
                    }
                    else if (entry.tweenId >= 0) {
                        Framework_Tween_Play(entry.tweenId);
                    }
                }
            }

            if (seq.elapsed >= seq.duration) {
                seq.state = TWEEN_STATE_COMPLETED;
                if (seq.autoKill) seqToRemove.push_back(pair.first);
            }
        }

        for (int id : seqToRemove) {
            Framework_Tween_KillSequence(id);
        }
    }

    void Framework_Tween_PauseAll() {
        g_tweensPaused = true;
    }

    void Framework_Tween_ResumeAll() {
        g_tweensPaused = false;
    }

    void Framework_Tween_KillAll() {
        g_tweens.clear();
        g_sequences.clear();
    }

    int Framework_Tween_GetActiveCount() {
        int count = 0;
        for (const auto& pair : g_tweens) {
            if (pair.second.state == TWEEN_STATE_PLAYING) count++;
        }
        return count;
    }

    void Framework_Tween_SetGlobalTimeScale(float scale) {
        g_globalTweenTimeScale = scale;
    }

    float Framework_Tween_GetGlobalTimeScale() {
        return g_globalTweenTimeScale;
    }

    // Easing function utility
    float Framework_Tween_Ease(float t, int easing) {
        return ApplyTweenEasing(t, (TweenEasing)easing);
    }

    // ========================================================================
    // EVENT SYSTEM - Publish/Subscribe messaging
    // ========================================================================

    // Subscription types to handle different callback signatures
    enum SubscriptionType {
        SUB_TYPE_BASIC = 0,
        SUB_TYPE_INT = 1,
        SUB_TYPE_FLOAT = 2,
        SUB_TYPE_STRING = 3,
        SUB_TYPE_VECTOR2 = 4,
        SUB_TYPE_ENTITY = 5
    };

    struct Subscription {
        int id;
        int eventId;
        SubscriptionType type;
        void* callback;
        void* userData;
        int priority;
        bool enabled;
        bool oneShot;
        int targetEntity;  // -1 for global, >= 0 for entity-specific
    };

    struct RegisteredEvent {
        int id;
        std::string name;
        std::vector<int> subscriptionIds;  // Sorted by priority
    };

    struct QueuedEvent {
        int eventId;
        EventDataType dataType;
        int intValue;
        float floatValue;
        std::string stringValue;
        float x, y;
        float delay;
        float elapsed;
        int targetEntity;  // -1 for global
    };

    // Event system globals
    static std::unordered_map<int, RegisteredEvent> g_events;
    static std::unordered_map<std::string, int> g_eventIdByName;
    static std::unordered_map<int, Subscription> g_subscriptions;
    static std::vector<QueuedEvent> g_eventQueue;
    static int g_nextEventId = 1;
    static int g_nextSubscriptionId = 1;
    static bool g_eventsPaused = false;

    // Helper to get subscription
    Subscription* GetSubscription(int subId) {
        auto it = g_subscriptions.find(subId);
        return it != g_subscriptions.end() ? &it->second : nullptr;
    }

    // Helper to get event
    RegisteredEvent* GetEvent(int eventId) {
        auto it = g_events.find(eventId);
        return it != g_events.end() ? &it->second : nullptr;
    }

    // Helper to sort subscriptions by priority
    void SortEventSubscriptions(int eventId) {
        auto* evt = GetEvent(eventId);
        if (!evt) return;

        std::sort(evt->subscriptionIds.begin(), evt->subscriptionIds.end(),
            [](int a, int b) {
                auto* subA = GetSubscription(a);
                auto* subB = GetSubscription(b);
                if (!subA || !subB) return false;
                return subA->priority > subB->priority;  // Higher priority first
            });
    }

    // Event registration
    int Framework_Event_Register(const char* eventName) {
        if (!eventName) return -1;

        std::string name(eventName);
        auto it = g_eventIdByName.find(name);
        if (it != g_eventIdByName.end()) {
            return it->second;  // Already registered
        }

        int eventId = g_nextEventId++;
        RegisteredEvent evt;
        evt.id = eventId;
        evt.name = name;
        g_events[eventId] = evt;
        g_eventIdByName[name] = eventId;
        return eventId;
    }

    int Framework_Event_GetId(const char* eventName) {
        if (!eventName) return -1;
        auto it = g_eventIdByName.find(std::string(eventName));
        return it != g_eventIdByName.end() ? it->second : -1;
    }

    const char* Framework_Event_GetName(int eventId) {
        auto* evt = GetEvent(eventId);
        return evt ? evt->name.c_str() : nullptr;
    }

    bool Framework_Event_Exists(const char* eventName) {
        return eventName && g_eventIdByName.find(std::string(eventName)) != g_eventIdByName.end();
    }

    // Subscribe helpers
    int CreateSubscription(int eventId, SubscriptionType type, void* callback, void* userData, bool oneShot, int targetEntity) {
        if (!callback) return -1;
        auto* evt = GetEvent(eventId);
        if (!evt) return -1;

        int subId = g_nextSubscriptionId++;
        Subscription sub;
        sub.id = subId;
        sub.eventId = eventId;
        sub.type = type;
        sub.callback = callback;
        sub.userData = userData;
        sub.priority = 0;
        sub.enabled = true;
        sub.oneShot = oneShot;
        sub.targetEntity = targetEntity;
        g_subscriptions[subId] = sub;
        evt->subscriptionIds.push_back(subId);
        return subId;
    }

    int Framework_Event_Subscribe(int eventId, EventCallback callback, void* userData) {
        return CreateSubscription(eventId, SUB_TYPE_BASIC, (void*)callback, userData, false, -1);
    }

    int Framework_Event_SubscribeInt(int eventId, EventCallbackInt callback, void* userData) {
        return CreateSubscription(eventId, SUB_TYPE_INT, (void*)callback, userData, false, -1);
    }

    int Framework_Event_SubscribeFloat(int eventId, EventCallbackFloat callback, void* userData) {
        return CreateSubscription(eventId, SUB_TYPE_FLOAT, (void*)callback, userData, false, -1);
    }

    int Framework_Event_SubscribeString(int eventId, EventCallbackString callback, void* userData) {
        return CreateSubscription(eventId, SUB_TYPE_STRING, (void*)callback, userData, false, -1);
    }

    int Framework_Event_SubscribeVector2(int eventId, EventCallbackVector2 callback, void* userData) {
        return CreateSubscription(eventId, SUB_TYPE_VECTOR2, (void*)callback, userData, false, -1);
    }

    int Framework_Event_SubscribeEntity(int eventId, EventCallbackEntity callback, void* userData) {
        return CreateSubscription(eventId, SUB_TYPE_ENTITY, (void*)callback, userData, false, -1);
    }

    int Framework_Event_SubscribeByName(const char* eventName, EventCallback callback, void* userData) {
        int eventId = Framework_Event_GetId(eventName);
        if (eventId < 0) eventId = Framework_Event_Register(eventName);
        return Framework_Event_Subscribe(eventId, callback, userData);
    }

    int Framework_Event_SubscribeOnce(int eventId, EventCallback callback, void* userData) {
        return CreateSubscription(eventId, SUB_TYPE_BASIC, (void*)callback, userData, true, -1);
    }

    int Framework_Event_SubscribeOnceInt(int eventId, EventCallbackInt callback, void* userData) {
        return CreateSubscription(eventId, SUB_TYPE_INT, (void*)callback, userData, true, -1);
    }

    // Unsubscribe
    void Framework_Event_Unsubscribe(int subscriptionId) {
        auto* sub = GetSubscription(subscriptionId);
        if (!sub) return;

        auto* evt = GetEvent(sub->eventId);
        if (evt) {
            auto& subs = evt->subscriptionIds;
            subs.erase(std::remove(subs.begin(), subs.end(), subscriptionId), subs.end());
        }
        g_subscriptions.erase(subscriptionId);
    }

    void Framework_Event_UnsubscribeAll(int eventId) {
        auto* evt = GetEvent(eventId);
        if (!evt) return;

        for (int subId : evt->subscriptionIds) {
            g_subscriptions.erase(subId);
        }
        evt->subscriptionIds.clear();
    }

    void Framework_Event_UnsubscribeCallback(int eventId, EventCallback callback) {
        auto* evt = GetEvent(eventId);
        if (!evt) return;

        std::vector<int> toRemove;
        for (int subId : evt->subscriptionIds) {
            auto* sub = GetSubscription(subId);
            if (sub && sub->callback == (void*)callback) {
                toRemove.push_back(subId);
            }
        }
        for (int subId : toRemove) {
            Framework_Event_Unsubscribe(subId);
        }
    }

    // Publish events (immediate dispatch)
    void DispatchEvent(int eventId, EventDataType dataType, int intVal, float floatVal,
                       const char* strVal, float x, float y, int targetEntity) {
        if (g_eventsPaused) return;

        auto* evt = GetEvent(eventId);
        if (!evt) return;

        std::vector<int> toRemove;

        // Copy subscription IDs to avoid iterator invalidation
        std::vector<int> subs = evt->subscriptionIds;

        for (int subId : subs) {
            auto* sub = GetSubscription(subId);
            if (!sub || !sub->enabled) continue;
            if (sub->targetEntity >= 0 && sub->targetEntity != targetEntity) continue;

            switch (sub->type) {
            case SUB_TYPE_BASIC:
                ((EventCallback)sub->callback)(eventId, sub->userData);
                break;
            case SUB_TYPE_INT:
                ((EventCallbackInt)sub->callback)(eventId, intVal, sub->userData);
                break;
            case SUB_TYPE_FLOAT:
                ((EventCallbackFloat)sub->callback)(eventId, floatVal, sub->userData);
                break;
            case SUB_TYPE_STRING:
                ((EventCallbackString)sub->callback)(eventId, strVal ? strVal : "", sub->userData);
                break;
            case SUB_TYPE_VECTOR2:
                ((EventCallbackVector2)sub->callback)(eventId, x, y, sub->userData);
                break;
            case SUB_TYPE_ENTITY:
                ((EventCallbackEntity)sub->callback)(eventId, targetEntity >= 0 ? targetEntity : intVal, sub->userData);
                break;
            }

            if (sub->oneShot) {
                toRemove.push_back(subId);
            }
        }

        // Remove one-shot subscriptions
        for (int subId : toRemove) {
            Framework_Event_Unsubscribe(subId);
        }
    }

    void Framework_Event_Publish(int eventId) {
        DispatchEvent(eventId, EVENT_DATA_NONE, 0, 0.0f, nullptr, 0, 0, -1);
    }

    void Framework_Event_PublishInt(int eventId, int value) {
        DispatchEvent(eventId, EVENT_DATA_INT, value, 0.0f, nullptr, 0, 0, -1);
    }

    void Framework_Event_PublishFloat(int eventId, float value) {
        DispatchEvent(eventId, EVENT_DATA_FLOAT, 0, value, nullptr, 0, 0, -1);
    }

    void Framework_Event_PublishString(int eventId, const char* value) {
        DispatchEvent(eventId, EVENT_DATA_STRING, 0, 0.0f, value, 0, 0, -1);
    }

    void Framework_Event_PublishVector2(int eventId, float x, float y) {
        DispatchEvent(eventId, EVENT_DATA_VECTOR2, 0, 0.0f, nullptr, x, y, -1);
    }

    void Framework_Event_PublishEntity(int eventId, int entity) {
        DispatchEvent(eventId, EVENT_DATA_ENTITY, entity, 0.0f, nullptr, 0, 0, -1);
    }

    void Framework_Event_PublishByName(const char* eventName) {
        int eventId = Framework_Event_GetId(eventName);
        if (eventId >= 0) Framework_Event_Publish(eventId);
    }

    void Framework_Event_PublishByNameInt(const char* eventName, int value) {
        int eventId = Framework_Event_GetId(eventName);
        if (eventId >= 0) Framework_Event_PublishInt(eventId, value);
    }

    // Queued/deferred events
    void Framework_Event_Queue(int eventId) {
        QueuedEvent qe;
        qe.eventId = eventId;
        qe.dataType = EVENT_DATA_NONE;
        qe.delay = 0;
        qe.elapsed = 0;
        qe.targetEntity = -1;
        g_eventQueue.push_back(qe);
    }

    void Framework_Event_QueueInt(int eventId, int value) {
        QueuedEvent qe;
        qe.eventId = eventId;
        qe.dataType = EVENT_DATA_INT;
        qe.intValue = value;
        qe.delay = 0;
        qe.elapsed = 0;
        qe.targetEntity = -1;
        g_eventQueue.push_back(qe);
    }

    void Framework_Event_QueueFloat(int eventId, float value) {
        QueuedEvent qe;
        qe.eventId = eventId;
        qe.dataType = EVENT_DATA_FLOAT;
        qe.floatValue = value;
        qe.delay = 0;
        qe.elapsed = 0;
        qe.targetEntity = -1;
        g_eventQueue.push_back(qe);
    }

    void Framework_Event_QueueString(int eventId, const char* value) {
        QueuedEvent qe;
        qe.eventId = eventId;
        qe.dataType = EVENT_DATA_STRING;
        qe.stringValue = value ? value : "";
        qe.delay = 0;
        qe.elapsed = 0;
        qe.targetEntity = -1;
        g_eventQueue.push_back(qe);
    }

    void Framework_Event_QueueDelayed(int eventId, float delay) {
        QueuedEvent qe;
        qe.eventId = eventId;
        qe.dataType = EVENT_DATA_NONE;
        qe.delay = delay;
        qe.elapsed = 0;
        qe.targetEntity = -1;
        g_eventQueue.push_back(qe);
    }

    void Framework_Event_QueueDelayedInt(int eventId, int value, float delay) {
        QueuedEvent qe;
        qe.eventId = eventId;
        qe.dataType = EVENT_DATA_INT;
        qe.intValue = value;
        qe.delay = delay;
        qe.elapsed = 0;
        qe.targetEntity = -1;
        g_eventQueue.push_back(qe);
    }

    // Entity-specific events
    int Framework_Event_SubscribeToEntity(int entity, int eventId, EventCallbackEntity callback, void* userData) {
        return CreateSubscription(eventId, SUB_TYPE_ENTITY, (void*)callback, userData, false, entity);
    }

    void Framework_Event_PublishToEntity(int entity, int eventId) {
        DispatchEvent(eventId, EVENT_DATA_ENTITY, entity, 0.0f, nullptr, 0, 0, entity);
    }

    void Framework_Event_PublishToEntityInt(int entity, int eventId, int value) {
        DispatchEvent(eventId, EVENT_DATA_INT, value, 0.0f, nullptr, 0, 0, entity);
    }

    void Framework_Event_UnsubscribeFromEntity(int entity, int eventId) {
        auto* evt = GetEvent(eventId);
        if (!evt) return;

        std::vector<int> toRemove;
        for (int subId : evt->subscriptionIds) {
            auto* sub = GetSubscription(subId);
            if (sub && sub->targetEntity == entity) {
                toRemove.push_back(subId);
            }
        }
        for (int subId : toRemove) {
            Framework_Event_Unsubscribe(subId);
        }
    }

    void Framework_Event_UnsubscribeAllFromEntity(int entity) {
        std::vector<int> toRemove;
        for (auto& pair : g_subscriptions) {
            if (pair.second.targetEntity == entity) {
                toRemove.push_back(pair.first);
            }
        }
        for (int subId : toRemove) {
            Framework_Event_Unsubscribe(subId);
        }
    }

    // Priority control
    void Framework_Event_SetPriority(int subscriptionId, int priority) {
        auto* sub = GetSubscription(subscriptionId);
        if (!sub) return;
        sub->priority = priority;
        SortEventSubscriptions(sub->eventId);
    }

    int Framework_Event_GetPriority(int subscriptionId) {
        auto* sub = GetSubscription(subscriptionId);
        return sub ? sub->priority : 0;
    }

    // Event state and management
    void Framework_Event_SetEnabled(int subscriptionId, bool enabled) {
        auto* sub = GetSubscription(subscriptionId);
        if (sub) sub->enabled = enabled;
    }

    bool Framework_Event_IsEnabled(int subscriptionId) {
        auto* sub = GetSubscription(subscriptionId);
        return sub ? sub->enabled : false;
    }

    bool Framework_Event_IsSubscriptionValid(int subscriptionId) {
        return GetSubscription(subscriptionId) != nullptr;
    }

    int Framework_Event_GetSubscriberCount(int eventId) {
        auto* evt = GetEvent(eventId);
        return evt ? (int)evt->subscriptionIds.size() : 0;
    }

    // Queue processing
    void Framework_Event_ProcessQueue(float dt) {
        if (g_eventsPaused) return;

        std::vector<int> toFire;

        for (size_t i = 0; i < g_eventQueue.size(); i++) {
            QueuedEvent& qe = g_eventQueue[i];
            qe.elapsed += dt;
            if (qe.elapsed >= qe.delay) {
                toFire.push_back((int)i);
            }
        }

        // Fire events in order and remove from queue (reverse order to maintain indices)
        for (int i = (int)toFire.size() - 1; i >= 0; i--) {
            int idx = toFire[i];
            QueuedEvent& qe = g_eventQueue[idx];

            switch (qe.dataType) {
            case EVENT_DATA_NONE:
                if (qe.targetEntity >= 0)
                    Framework_Event_PublishToEntity(qe.targetEntity, qe.eventId);
                else
                    Framework_Event_Publish(qe.eventId);
                break;
            case EVENT_DATA_INT:
                if (qe.targetEntity >= 0)
                    Framework_Event_PublishToEntityInt(qe.targetEntity, qe.eventId, qe.intValue);
                else
                    Framework_Event_PublishInt(qe.eventId, qe.intValue);
                break;
            case EVENT_DATA_FLOAT:
                Framework_Event_PublishFloat(qe.eventId, qe.floatValue);
                break;
            case EVENT_DATA_STRING:
                Framework_Event_PublishString(qe.eventId, qe.stringValue.c_str());
                break;
            case EVENT_DATA_VECTOR2:
                Framework_Event_PublishVector2(qe.eventId, qe.x, qe.y);
                break;
            default:
                break;
            }

            g_eventQueue.erase(g_eventQueue.begin() + idx);
        }
    }

    void Framework_Event_ClearQueue() {
        g_eventQueue.clear();
    }

    int Framework_Event_GetQueuedCount() {
        return (int)g_eventQueue.size();
    }

    // Global event system management
    void Framework_Event_PauseAll() {
        g_eventsPaused = true;
    }

    void Framework_Event_ResumeAll() {
        g_eventsPaused = false;
    }

    bool Framework_Event_IsPaused() {
        return g_eventsPaused;
    }

    void Framework_Event_Clear() {
        g_events.clear();
        g_eventIdByName.clear();
        g_subscriptions.clear();
        g_eventQueue.clear();
        g_nextEventId = 1;
        g_nextSubscriptionId = 1;
        g_eventsPaused = false;
    }

    int Framework_Event_GetEventCount() {
        return (int)g_events.size();
    }

    int Framework_Event_GetTotalSubscriptions() {
        return (int)g_subscriptions.size();
    }

    // ========================================================================
    // TIMER SYSTEM - Delayed execution and scheduling
    // ========================================================================

    enum TimerType {
        TIMER_ONESHOT = 0,
        TIMER_REPEATING = 1,
        TIMER_FRAME_ONESHOT = 2,
        TIMER_FRAME_REPEATING = 3
    };

    enum TimerCallbackType {
        TIMER_CB_BASIC = 0,
        TIMER_CB_INT = 1,
        TIMER_CB_FLOAT = 2
    };

    struct Timer {
        int id;
        TimerType type;
        TimerCallbackType callbackType;
        TimerState state;
        void* callback;
        void* userData;
        int intValue;
        float floatValue;
        float delay;           // Initial delay before first fire
        float interval;        // Time between fires (for repeating)
        float elapsed;         // Time since timer started
        float timeScale;       // Per-timer time scale
        int repeatCount;       // -1 = infinite, 0+ = limited
        int currentRepeat;     // Current repeat iteration
        int targetEntity;      // -1 for global, >= 0 for entity-bound
        int frameDelay;        // For frame-based timers
        int frameInterval;     // For frame-based repeating
        int frameCounter;      // Current frame count
        bool hasInitialDelay;  // For AfterThenEvery pattern
        bool initialDelayDone; // Has initial delay passed
    };

    struct TimerSequenceEntry {
        float delay;
        TimerCallbackType callbackType;
        void* callback;
        void* userData;
        int intValue;
        bool fired;
    };

    struct TimerSequence {
        int id;
        std::vector<TimerSequenceEntry> entries;
        float elapsed;
        float duration;
        TimerState state;
        bool loop;
    };

    // Timer system globals
    static std::unordered_map<int, Timer> g_timers;
    static std::unordered_map<int, TimerSequence> g_timerSequences;
    static int g_nextTimerId = 1;
    static int g_nextTimerSeqId = 1;
    static bool g_timersPaused = false;
    static float g_globalTimerTimeScale = 1.0f;

    // Helper to get timer
    Timer* GetTimer(int timerId) {
        auto it = g_timers.find(timerId);
        return it != g_timers.end() ? &it->second : nullptr;
    }

    // Helper to get sequence
    TimerSequence* GetTimerSequence(int seqId) {
        auto it = g_timerSequences.find(seqId);
        return it != g_timerSequences.end() ? &it->second : nullptr;
    }

    // Internal timer creation
    int CreateTimer(TimerType type, TimerCallbackType cbType, void* callback, void* userData,
                    float delay, float interval, int repeatCount, int entity) {
        if (!callback) return -1;

        Timer t;
        t.id = g_nextTimerId++;
        t.type = type;
        t.callbackType = cbType;
        t.state = delay > 0 ? TIMER_STATE_PENDING : TIMER_STATE_RUNNING;
        t.callback = callback;
        t.userData = userData;
        t.intValue = 0;
        t.floatValue = 0.0f;
        t.delay = delay;
        t.interval = interval;
        t.elapsed = 0.0f;
        t.timeScale = 1.0f;
        t.repeatCount = repeatCount;
        t.currentRepeat = 0;
        t.targetEntity = entity;
        t.frameDelay = 0;
        t.frameInterval = 0;
        t.frameCounter = 0;
        t.hasInitialDelay = false;
        t.initialDelayDone = false;
        g_timers[t.id] = t;
        return t.id;
    }

    // Basic timers (one-shot)
    int Framework_Timer_After(float delay, TimerCallback callback, void* userData) {
        return CreateTimer(TIMER_ONESHOT, TIMER_CB_BASIC, (void*)callback, userData, delay, 0, 1, -1);
    }

    int Framework_Timer_AfterInt(float delay, TimerCallbackInt callback, int value, void* userData) {
        int id = CreateTimer(TIMER_ONESHOT, TIMER_CB_INT, (void*)callback, userData, delay, 0, 1, -1);
        if (auto* t = GetTimer(id)) t->intValue = value;
        return id;
    }

    int Framework_Timer_AfterFloat(float delay, TimerCallbackFloat callback, float value, void* userData) {
        int id = CreateTimer(TIMER_ONESHOT, TIMER_CB_FLOAT, (void*)callback, userData, delay, 0, 1, -1);
        if (auto* t = GetTimer(id)) t->floatValue = value;
        return id;
    }

    // Repeating timers
    int Framework_Timer_Every(float interval, TimerCallback callback, void* userData) {
        return CreateTimer(TIMER_REPEATING, TIMER_CB_BASIC, (void*)callback, userData, 0, interval, -1, -1);
    }

    int Framework_Timer_EveryInt(float interval, TimerCallbackInt callback, int value, void* userData) {
        int id = CreateTimer(TIMER_REPEATING, TIMER_CB_INT, (void*)callback, userData, 0, interval, -1, -1);
        if (auto* t = GetTimer(id)) t->intValue = value;
        return id;
    }

    int Framework_Timer_EveryLimit(float interval, int repeatCount, TimerCallback callback, void* userData) {
        return CreateTimer(TIMER_REPEATING, TIMER_CB_BASIC, (void*)callback, userData, 0, interval, repeatCount, -1);
    }

    int Framework_Timer_AfterThenEvery(float delay, float interval, TimerCallback callback, void* userData) {
        int id = CreateTimer(TIMER_REPEATING, TIMER_CB_BASIC, (void*)callback, userData, delay, interval, -1, -1);
        if (auto* t = GetTimer(id)) {
            t->hasInitialDelay = true;
            t->initialDelayDone = false;
        }
        return id;
    }

    // Timer control
    void Framework_Timer_Cancel(int timerId) {
        auto* t = GetTimer(timerId);
        if (t) t->state = TIMER_STATE_CANCELLED;
    }

    void Framework_Timer_Pause(int timerId) {
        auto* t = GetTimer(timerId);
        if (t && t->state == TIMER_STATE_RUNNING) t->state = TIMER_STATE_PAUSED;
    }

    void Framework_Timer_Resume(int timerId) {
        auto* t = GetTimer(timerId);
        if (t && t->state == TIMER_STATE_PAUSED) t->state = TIMER_STATE_RUNNING;
    }

    void Framework_Timer_Reset(int timerId) {
        auto* t = GetTimer(timerId);
        if (!t) return;
        t->elapsed = 0.0f;
        t->currentRepeat = 0;
        t->frameCounter = 0;
        t->initialDelayDone = false;
        t->state = t->delay > 0 ? TIMER_STATE_PENDING : TIMER_STATE_RUNNING;
    }

    // Timer state queries
    bool Framework_Timer_IsValid(int timerId) {
        return GetTimer(timerId) != nullptr;
    }

    bool Framework_Timer_IsRunning(int timerId) {
        auto* t = GetTimer(timerId);
        return t && t->state == TIMER_STATE_RUNNING;
    }

    bool Framework_Timer_IsPaused(int timerId) {
        auto* t = GetTimer(timerId);
        return t && t->state == TIMER_STATE_PAUSED;
    }

    int Framework_Timer_GetState(int timerId) {
        auto* t = GetTimer(timerId);
        return t ? t->state : TIMER_STATE_CANCELLED;
    }

    float Framework_Timer_GetElapsed(int timerId) {
        auto* t = GetTimer(timerId);
        return t ? t->elapsed : 0.0f;
    }

    float Framework_Timer_GetRemaining(int timerId) {
        auto* t = GetTimer(timerId);
        if (!t) return 0.0f;
        if (t->type == TIMER_ONESHOT) {
            return t->delay - t->elapsed;
        }
        else {
            float targetTime = t->hasInitialDelay && !t->initialDelayDone ? t->delay : t->interval;
            float cycleElapsed = t->hasInitialDelay && !t->initialDelayDone ? t->elapsed : fmodf(t->elapsed, t->interval);
            return targetTime - cycleElapsed;
        }
    }

    int Framework_Timer_GetRepeatCount(int timerId) {
        auto* t = GetTimer(timerId);
        return t ? t->repeatCount : 0;
    }

    int Framework_Timer_GetCurrentRepeat(int timerId) {
        auto* t = GetTimer(timerId);
        return t ? t->currentRepeat : 0;
    }

    // Timer configuration
    void Framework_Timer_SetTimeScale(int timerId, float scale) {
        auto* t = GetTimer(timerId);
        if (t) t->timeScale = scale;
    }

    float Framework_Timer_GetTimeScale(int timerId) {
        auto* t = GetTimer(timerId);
        return t ? t->timeScale : 1.0f;
    }

    void Framework_Timer_SetInterval(int timerId, float interval) {
        auto* t = GetTimer(timerId);
        if (t) t->interval = interval;
    }

    float Framework_Timer_GetInterval(int timerId) {
        auto* t = GetTimer(timerId);
        return t ? t->interval : 0.0f;
    }

    // Entity-bound timers
    int Framework_Timer_AfterEntity(int entity, float delay, TimerCallback callback, void* userData) {
        return CreateTimer(TIMER_ONESHOT, TIMER_CB_BASIC, (void*)callback, userData, delay, 0, 1, entity);
    }

    int Framework_Timer_EveryEntity(int entity, float interval, TimerCallback callback, void* userData) {
        return CreateTimer(TIMER_REPEATING, TIMER_CB_BASIC, (void*)callback, userData, 0, interval, -1, entity);
    }

    void Framework_Timer_CancelAllForEntity(int entity) {
        for (auto& pair : g_timers) {
            if (pair.second.targetEntity == entity) {
                pair.second.state = TIMER_STATE_CANCELLED;
            }
        }
    }

    // Sequence building
    int Framework_Timer_CreateSequence() {
        TimerSequence seq;
        seq.id = g_nextTimerSeqId++;
        seq.elapsed = 0.0f;
        seq.duration = 0.0f;
        seq.state = TIMER_STATE_PENDING;
        seq.loop = false;
        g_timerSequences[seq.id] = seq;
        return seq.id;
    }

    void Framework_Timer_SequenceAppend(int seqId, float delay, TimerCallback callback, void* userData) {
        auto* seq = GetTimerSequence(seqId);
        if (!seq) return;

        TimerSequenceEntry entry;
        entry.delay = seq->duration + delay;
        entry.callbackType = TIMER_CB_BASIC;
        entry.callback = (void*)callback;
        entry.userData = userData;
        entry.intValue = 0;
        entry.fired = false;
        seq->entries.push_back(entry);
        seq->duration = entry.delay;
    }

    void Framework_Timer_SequenceAppendInt(int seqId, float delay, TimerCallbackInt callback, int value, void* userData) {
        auto* seq = GetTimerSequence(seqId);
        if (!seq) return;

        TimerSequenceEntry entry;
        entry.delay = seq->duration + delay;
        entry.callbackType = TIMER_CB_INT;
        entry.callback = (void*)callback;
        entry.userData = userData;
        entry.intValue = value;
        entry.fired = false;
        seq->entries.push_back(entry);
        seq->duration = entry.delay;
    }

    void Framework_Timer_SequenceStart(int seqId) {
        auto* seq = GetTimerSequence(seqId);
        if (seq) {
            seq->state = TIMER_STATE_RUNNING;
            seq->elapsed = 0.0f;
            for (auto& e : seq->entries) e.fired = false;
        }
    }

    void Framework_Timer_SequencePause(int seqId) {
        auto* seq = GetTimerSequence(seqId);
        if (seq && seq->state == TIMER_STATE_RUNNING) seq->state = TIMER_STATE_PAUSED;
    }

    void Framework_Timer_SequenceResume(int seqId) {
        auto* seq = GetTimerSequence(seqId);
        if (seq && seq->state == TIMER_STATE_PAUSED) seq->state = TIMER_STATE_RUNNING;
    }

    void Framework_Timer_SequenceCancel(int seqId) {
        auto* seq = GetTimerSequence(seqId);
        if (seq) seq->state = TIMER_STATE_CANCELLED;
    }

    void Framework_Timer_SequenceReset(int seqId) {
        auto* seq = GetTimerSequence(seqId);
        if (seq) {
            seq->elapsed = 0.0f;
            seq->state = TIMER_STATE_PENDING;
            for (auto& e : seq->entries) e.fired = false;
        }
    }

    bool Framework_Timer_SequenceIsValid(int seqId) {
        return GetTimerSequence(seqId) != nullptr;
    }

    bool Framework_Timer_SequenceIsRunning(int seqId) {
        auto* seq = GetTimerSequence(seqId);
        return seq && seq->state == TIMER_STATE_RUNNING;
    }

    float Framework_Timer_SequenceGetDuration(int seqId) {
        auto* seq = GetTimerSequence(seqId);
        return seq ? seq->duration : 0.0f;
    }

    float Framework_Timer_SequenceGetElapsed(int seqId) {
        auto* seq = GetTimerSequence(seqId);
        return seq ? seq->elapsed : 0.0f;
    }

    void Framework_Timer_SequenceSetLoop(int seqId, bool loop) {
        auto* seq = GetTimerSequence(seqId);
        if (seq) seq->loop = loop;
    }

    // Fire timer callback
    void FireTimerCallback(Timer& t) {
        switch (t.callbackType) {
        case TIMER_CB_BASIC:
            ((TimerCallback)t.callback)(t.id, t.userData);
            break;
        case TIMER_CB_INT:
            ((TimerCallbackInt)t.callback)(t.id, t.intValue, t.userData);
            break;
        case TIMER_CB_FLOAT:
            ((TimerCallbackFloat)t.callback)(t.id, t.floatValue, t.userData);
            break;
        }
    }

    // Global timer management
    void Framework_Timer_Update(float dt) {
        if (g_timersPaused) return;

        float scaledDt = dt * g_globalTimerTimeScale;
        std::vector<int> toRemove;

        // Update all timers
        for (auto& pair : g_timers) {
            Timer& t = pair.second;

            // Skip inactive timers
            if (t.state != TIMER_STATE_RUNNING && t.state != TIMER_STATE_PENDING) continue;

            // Check entity-bound timers
            if (t.targetEntity >= 0 && !Framework_Ecs_IsAlive(t.targetEntity)) {
                t.state = TIMER_STATE_CANCELLED;
                continue;
            }

            float timerDt = scaledDt * t.timeScale;

            // Handle frame-based timers
            if (t.type == TIMER_FRAME_ONESHOT || t.type == TIMER_FRAME_REPEATING) {
                t.frameCounter++;

                if (t.type == TIMER_FRAME_ONESHOT) {
                    if (t.frameCounter >= t.frameDelay) {
                        FireTimerCallback(t);
                        t.state = TIMER_STATE_COMPLETED;
                    }
                }
                else {
                    if (t.frameCounter >= t.frameInterval) {
                        FireTimerCallback(t);
                        t.frameCounter = 0;
                        t.currentRepeat++;
                        if (t.repeatCount >= 0 && t.currentRepeat >= t.repeatCount) {
                            t.state = TIMER_STATE_COMPLETED;
                        }
                    }
                }
                continue;
            }

            // Time-based timers
            t.elapsed += timerDt;

            if (t.type == TIMER_ONESHOT) {
                if (t.elapsed >= t.delay) {
                    FireTimerCallback(t);
                    t.state = TIMER_STATE_COMPLETED;
                }
                else if (t.state == TIMER_STATE_PENDING) {
                    t.state = TIMER_STATE_RUNNING;
                }
            }
            else if (t.type == TIMER_REPEATING) {
                // Handle initial delay for AfterThenEvery
                if (t.hasInitialDelay && !t.initialDelayDone) {
                    if (t.elapsed >= t.delay) {
                        FireTimerCallback(t);
                        t.initialDelayDone = true;
                        t.elapsed = 0.0f;
                        t.currentRepeat++;
                    }
                }
                else {
                    // Regular repeating
                    while (t.elapsed >= t.interval && t.state == TIMER_STATE_RUNNING) {
                        FireTimerCallback(t);
                        t.elapsed -= t.interval;
                        t.currentRepeat++;

                        if (t.repeatCount >= 0 && t.currentRepeat >= t.repeatCount) {
                            t.state = TIMER_STATE_COMPLETED;
                            break;
                        }
                    }
                }

                if (t.state == TIMER_STATE_PENDING) {
                    t.state = TIMER_STATE_RUNNING;
                }
            }
        }

        // Update sequences
        for (auto& pair : g_timerSequences) {
            TimerSequence& seq = pair.second;
            if (seq.state != TIMER_STATE_RUNNING) continue;

            seq.elapsed += scaledDt;

            // Fire callbacks that are due
            for (auto& entry : seq.entries) {
                if (!entry.fired && seq.elapsed >= entry.delay) {
                    entry.fired = true;
                    switch (entry.callbackType) {
                    case TIMER_CB_BASIC:
                        ((TimerCallback)entry.callback)(seq.id, entry.userData);
                        break;
                    case TIMER_CB_INT:
                        ((TimerCallbackInt)entry.callback)(seq.id, entry.intValue, entry.userData);
                        break;
                    default:
                        break;
                    }
                }
            }

            // Check if sequence is complete
            if (seq.elapsed >= seq.duration) {
                if (seq.loop) {
                    seq.elapsed = 0.0f;
                    for (auto& e : seq.entries) e.fired = false;
                }
                else {
                    seq.state = TIMER_STATE_COMPLETED;
                }
            }
        }
    }

    void Framework_Timer_PauseAll() {
        g_timersPaused = true;
    }

    void Framework_Timer_ResumeAll() {
        g_timersPaused = false;
    }

    void Framework_Timer_CancelAll() {
        for (auto& pair : g_timers) {
            pair.second.state = TIMER_STATE_CANCELLED;
        }
        for (auto& pair : g_timerSequences) {
            pair.second.state = TIMER_STATE_CANCELLED;
        }
    }

    int Framework_Timer_GetActiveCount() {
        int count = 0;
        for (auto& pair : g_timers) {
            if (pair.second.state == TIMER_STATE_RUNNING || pair.second.state == TIMER_STATE_PENDING) {
                count++;
            }
        }
        return count;
    }

    void Framework_Timer_SetGlobalTimeScale(float scale) {
        g_globalTimerTimeScale = scale;
    }

    float Framework_Timer_GetGlobalTimeScale() {
        return g_globalTimerTimeScale;
    }

    // Frame-based timers
    int Framework_Timer_AfterFrames(int frames, TimerCallback callback, void* userData) {
        int id = CreateTimer(TIMER_FRAME_ONESHOT, TIMER_CB_BASIC, (void*)callback, userData, 0, 0, 1, -1);
        if (auto* t = GetTimer(id)) {
            t->frameDelay = frames;
        }
        return id;
    }

    int Framework_Timer_EveryFrames(int frames, TimerCallback callback, void* userData) {
        int id = CreateTimer(TIMER_FRAME_REPEATING, TIMER_CB_BASIC, (void*)callback, userData, 0, 0, -1, -1);
        if (auto* t = GetTimer(id)) {
            t->frameInterval = frames;
        }
        return id;
    }

    // Utility functions
    void Framework_Timer_ClearCompleted() {
        std::vector<int> toRemove;
        for (auto& pair : g_timers) {
            if (pair.second.state == TIMER_STATE_COMPLETED || pair.second.state == TIMER_STATE_CANCELLED) {
                toRemove.push_back(pair.first);
            }
        }
        for (int id : toRemove) {
            g_timers.erase(id);
        }

        std::vector<int> seqToRemove;
        for (auto& pair : g_timerSequences) {
            if (pair.second.state == TIMER_STATE_COMPLETED || pair.second.state == TIMER_STATE_CANCELLED) {
                seqToRemove.push_back(pair.first);
            }
        }
        for (int id : seqToRemove) {
            g_timerSequences.erase(id);
        }
    }

    // ========================================================================
    // OBJECT POOLING - Efficient object reuse
    // ========================================================================

    struct PoolObject {
        bool active;
        int entityId;  // For entity pools, -1 for generic pools
    };

    struct ObjectPool {
        int id;
        std::string name;
        std::vector<PoolObject> objects;
        std::vector<int> availableIndices;  // Stack of available object indices
        int maxCapacity;
        bool autoGrow;
        int growAmount;
        int prefabId;  // For entity pools, -1 for generic
        bool isEntityPool;

        // Callbacks
        PoolResetCallback resetCallback;
        void* resetUserData;
        PoolInitCallback initCallback;
        void* initUserData;

        // Statistics
        int totalAcquires;
        int totalReleases;
        int peakUsage;
    };

    // Pool system globals
    static std::unordered_map<int, ObjectPool> g_pools;
    static std::unordered_map<std::string, int> g_poolIdByName;
    static int g_nextPoolId = 1;

    // Helper to get pool
    ObjectPool* GetPool(int poolId) {
        auto it = g_pools.find(poolId);
        return it != g_pools.end() ? &it->second : nullptr;
    }

    // Pool creation and management
    int Framework_Pool_Create(const char* poolName, int initialCapacity, int maxCapacity) {
        if (!poolName || initialCapacity < 0) return -1;
        if (maxCapacity > 0 && initialCapacity > maxCapacity) initialCapacity = maxCapacity;

        std::string name(poolName);
        auto it = g_poolIdByName.find(name);
        if (it != g_poolIdByName.end()) {
            return it->second;  // Already exists
        }

        ObjectPool pool;
        pool.id = g_nextPoolId++;
        pool.name = name;
        pool.maxCapacity = maxCapacity > 0 ? maxCapacity : INT_MAX;
        pool.autoGrow = true;
        pool.growAmount = 10;
        pool.prefabId = -1;
        pool.isEntityPool = false;
        pool.resetCallback = nullptr;
        pool.resetUserData = nullptr;
        pool.initCallback = nullptr;
        pool.initUserData = nullptr;
        pool.totalAcquires = 0;
        pool.totalReleases = 0;
        pool.peakUsage = 0;

        // Initialize objects
        pool.objects.resize(initialCapacity);
        for (int i = 0; i < initialCapacity; i++) {
            pool.objects[i].active = false;
            pool.objects[i].entityId = -1;
            pool.availableIndices.push_back(i);
        }

        g_pools[pool.id] = pool;
        g_poolIdByName[name] = pool.id;
        return pool.id;
    }

    int Framework_Pool_GetByName(const char* poolName) {
        if (!poolName) return -1;
        auto it = g_poolIdByName.find(std::string(poolName));
        return it != g_poolIdByName.end() ? it->second : -1;
    }

    void Framework_Pool_Destroy(int poolId) {
        auto* pool = GetPool(poolId);
        if (!pool) return;

        // For entity pools, destroy all entities
        if (pool->isEntityPool) {
            for (auto& obj : pool->objects) {
                if (obj.entityId >= 0) {
                    Framework_Ecs_DestroyEntity(obj.entityId);
                }
            }
        }

        g_poolIdByName.erase(pool->name);
        g_pools.erase(poolId);
    }

    bool Framework_Pool_IsValid(int poolId) {
        return GetPool(poolId) != nullptr;
    }

    // Pool configuration
    void Framework_Pool_SetAutoGrow(int poolId, bool autoGrow) {
        auto* pool = GetPool(poolId);
        if (pool) pool->autoGrow = autoGrow;
    }

    bool Framework_Pool_GetAutoGrow(int poolId) {
        auto* pool = GetPool(poolId);
        return pool ? pool->autoGrow : false;
    }

    void Framework_Pool_SetGrowAmount(int poolId, int amount) {
        auto* pool = GetPool(poolId);
        if (pool && amount > 0) pool->growAmount = amount;
    }

    int Framework_Pool_GetGrowAmount(int poolId) {
        auto* pool = GetPool(poolId);
        return pool ? pool->growAmount : 0;
    }

    void Framework_Pool_SetResetCallback(int poolId, PoolResetCallback callback, void* userData) {
        auto* pool = GetPool(poolId);
        if (pool) {
            pool->resetCallback = callback;
            pool->resetUserData = userData;
        }
    }

    void Framework_Pool_SetInitCallback(int poolId, PoolInitCallback callback, void* userData) {
        auto* pool = GetPool(poolId);
        if (pool) {
            pool->initCallback = callback;
            pool->initUserData = userData;
        }
    }

    // Internal: grow pool
    void GrowPool(ObjectPool* pool, int amount) {
        if (!pool) return;
        int currentSize = (int)pool->objects.size();
        int newSize = currentSize + amount;
        if (newSize > pool->maxCapacity) newSize = pool->maxCapacity;
        if (newSize <= currentSize) return;

        pool->objects.resize(newSize);
        for (int i = currentSize; i < newSize; i++) {
            pool->objects[i].active = false;
            pool->objects[i].entityId = -1;
            pool->availableIndices.push_back(i);

            // For entity pools, create entities
            if (pool->isEntityPool && pool->prefabId >= 0) {
                int entity = Framework_Prefab_Instantiate(pool->prefabId, -1, 0, 0);
                pool->objects[i].entityId = entity;
                Framework_Ecs_SetEnabled(entity, false);
            }

            // Call init callback
            if (pool->initCallback) {
                pool->initCallback(pool->id, i, pool->initUserData);
            }
        }
    }

    // Acquire and release objects
    int Framework_Pool_Acquire(int poolId) {
        auto* pool = GetPool(poolId);
        if (!pool) return -1;

        // Check if we need to grow
        if (pool->availableIndices.empty()) {
            if (pool->autoGrow && (int)pool->objects.size() < pool->maxCapacity) {
                GrowPool(pool, pool->growAmount);
            }
            if (pool->availableIndices.empty()) {
                return -1;  // Still empty, can't grow more
            }
        }

        // Get from available stack
        int index = pool->availableIndices.back();
        pool->availableIndices.pop_back();
        pool->objects[index].active = true;

        // Update stats
        pool->totalAcquires++;
        int activeCount = (int)pool->objects.size() - (int)pool->availableIndices.size();
        if (activeCount > pool->peakUsage) pool->peakUsage = activeCount;

        return index;
    }

    void Framework_Pool_Release(int poolId, int objectIndex) {
        auto* pool = GetPool(poolId);
        if (!pool) return;
        if (objectIndex < 0 || objectIndex >= (int)pool->objects.size()) return;
        if (!pool->objects[objectIndex].active) return;  // Already released

        pool->objects[objectIndex].active = false;
        pool->availableIndices.push_back(objectIndex);
        pool->totalReleases++;

        // Call reset callback
        if (pool->resetCallback) {
            pool->resetCallback(pool->id, objectIndex, pool->resetUserData);
        }
    }

    void Framework_Pool_ReleaseAll(int poolId) {
        auto* pool = GetPool(poolId);
        if (!pool) return;

        pool->availableIndices.clear();
        for (int i = 0; i < (int)pool->objects.size(); i++) {
            if (pool->objects[i].active) {
                pool->objects[i].active = false;
                pool->totalReleases++;
                if (pool->resetCallback) {
                    pool->resetCallback(pool->id, i, pool->resetUserData);
                }
            }
            pool->availableIndices.push_back(i);
        }
    }

    // Pool state queries
    int Framework_Pool_GetCapacity(int poolId) {
        auto* pool = GetPool(poolId);
        return pool ? (int)pool->objects.size() : 0;
    }

    int Framework_Pool_GetActiveCount(int poolId) {
        auto* pool = GetPool(poolId);
        if (!pool) return 0;
        return (int)pool->objects.size() - (int)pool->availableIndices.size();
    }

    int Framework_Pool_GetAvailableCount(int poolId) {
        auto* pool = GetPool(poolId);
        return pool ? (int)pool->availableIndices.size() : 0;
    }

    bool Framework_Pool_IsEmpty(int poolId) {
        auto* pool = GetPool(poolId);
        return pool ? pool->availableIndices.empty() : true;
    }

    bool Framework_Pool_IsFull(int poolId) {
        auto* pool = GetPool(poolId);
        if (!pool) return true;
        return pool->availableIndices.empty() && (int)pool->objects.size() >= pool->maxCapacity;
    }

    bool Framework_Pool_IsObjectActive(int poolId, int objectIndex) {
        auto* pool = GetPool(poolId);
        if (!pool || objectIndex < 0 || objectIndex >= (int)pool->objects.size()) return false;
        return pool->objects[objectIndex].active;
    }

    // Pool statistics
    int Framework_Pool_GetTotalAcquires(int poolId) {
        auto* pool = GetPool(poolId);
        return pool ? pool->totalAcquires : 0;
    }

    int Framework_Pool_GetTotalReleases(int poolId) {
        auto* pool = GetPool(poolId);
        return pool ? pool->totalReleases : 0;
    }

    int Framework_Pool_GetPeakUsage(int poolId) {
        auto* pool = GetPool(poolId);
        return pool ? pool->peakUsage : 0;
    }

    void Framework_Pool_ResetStats(int poolId) {
        auto* pool = GetPool(poolId);
        if (pool) {
            pool->totalAcquires = 0;
            pool->totalReleases = 0;
            pool->peakUsage = Framework_Pool_GetActiveCount(poolId);
        }
    }

    // Pre-warming
    void Framework_Pool_Warmup(int poolId, int count) {
        auto* pool = GetPool(poolId);
        if (!pool || count <= 0) return;

        int currentSize = (int)pool->objects.size();
        int targetSize = currentSize + count;
        if (targetSize > pool->maxCapacity) targetSize = pool->maxCapacity;

        GrowPool(pool, targetSize - currentSize);
    }

    void Framework_Pool_Shrink(int poolId) {
        auto* pool = GetPool(poolId);
        if (!pool) return;

        // Only shrink if we have inactive objects at the end
        // This is a simple shrink - just removes trailing inactive objects
        while (!pool->objects.empty() && !pool->objects.back().active) {
            int lastIndex = (int)pool->objects.size() - 1;

            // Remove from available indices
            auto it = std::find(pool->availableIndices.begin(), pool->availableIndices.end(), lastIndex);
            if (it != pool->availableIndices.end()) {
                pool->availableIndices.erase(it);
            }

            // For entity pools, destroy the entity
            if (pool->isEntityPool && pool->objects.back().entityId >= 0) {
                Framework_Ecs_DestroyEntity(pool->objects.back().entityId);
            }

            pool->objects.pop_back();
        }
    }

    // Entity pools
    int Framework_Pool_CreateEntityPool(const char* poolName, int prefabId, int initialCapacity, int maxCapacity) {
        int poolId = Framework_Pool_Create(poolName, 0, maxCapacity);  // Create empty first
        auto* pool = GetPool(poolId);
        if (!pool) return -1;

        pool->prefabId = prefabId;
        pool->isEntityPool = true;

        // Now add initial capacity with entities
        if (initialCapacity > 0) {
            GrowPool(pool, initialCapacity);
        }

        return poolId;
    }

    int Framework_Pool_AcquireEntity(int poolId) {
        auto* pool = GetPool(poolId);
        if (!pool || !pool->isEntityPool) return -1;

        int index = Framework_Pool_Acquire(poolId);
        if (index < 0) return -1;

        int entity = pool->objects[index].entityId;
        if (entity >= 0) {
            Framework_Ecs_SetEnabled(entity, true);
        }
        return entity;
    }

    void Framework_Pool_ReleaseEntity(int poolId, int entity) {
        auto* pool = GetPool(poolId);
        if (!pool || !pool->isEntityPool) return;

        // Find the object with this entity
        for (int i = 0; i < (int)pool->objects.size(); i++) {
            if (pool->objects[i].entityId == entity && pool->objects[i].active) {
                Framework_Ecs_SetEnabled(entity, false);
                Framework_Pool_Release(poolId, i);
                return;
            }
        }
    }

    // Iterate active objects
    int Framework_Pool_GetFirstActive(int poolId) {
        auto* pool = GetPool(poolId);
        if (!pool) return -1;

        for (int i = 0; i < (int)pool->objects.size(); i++) {
            if (pool->objects[i].active) return i;
        }
        return -1;
    }

    int Framework_Pool_GetNextActive(int poolId, int currentIndex) {
        auto* pool = GetPool(poolId);
        if (!pool) return -1;

        for (int i = currentIndex + 1; i < (int)pool->objects.size(); i++) {
            if (pool->objects[i].active) return i;
        }
        return -1;
    }

    // Bulk operations
    int Framework_Pool_AcquireMultiple(int poolId, int count, int* outIndices) {
        if (!outIndices || count <= 0) return 0;

        int acquired = 0;
        for (int i = 0; i < count; i++) {
            int index = Framework_Pool_Acquire(poolId);
            if (index < 0) break;
            outIndices[acquired++] = index;
        }
        return acquired;
    }

    void Framework_Pool_ReleaseMultiple(int poolId, int* indices, int count) {
        if (!indices || count <= 0) return;

        for (int i = 0; i < count; i++) {
            Framework_Pool_Release(poolId, indices[i]);
        }
    }

    // Global pool management
    int Framework_Pool_GetPoolCount() {
        return (int)g_pools.size();
    }

    void Framework_Pool_DestroyAll() {
        std::vector<int> poolIds;
        for (auto& pair : g_pools) {
            poolIds.push_back(pair.first);
        }
        for (int id : poolIds) {
            Framework_Pool_Destroy(id);
        }
    }

    void Framework_Pool_ReleaseAllPools() {
        for (auto& pair : g_pools) {
            Framework_Pool_ReleaseAll(pair.first);
        }
    }

    // Pool Statistics (real implementations now that g_pools is defined)
    long long Framework_Pool_GetTotalMemoryImpl() {
        long long total = 0;
        for (const auto& kv : g_pools) {
            total += kv.second.objects.size() * sizeof(PoolObject);
        }
        return total;
    }

    int Framework_Pool_GetActivePoolCountImpl() { return (int)g_pools.size(); }

    int Framework_Pool_GetTotalObjectCountImpl() {
        int total = 0;
        for (const auto& kv : g_pools) {
            total += (int)kv.second.objects.size();
        }
        return total;
    }

    int Framework_Pool_GetTotalAcquiredImpl() {
        int total = 0;
        for (const auto& kv : g_pools) {
            for (const auto& obj : kv.second.objects) {
                if (obj.active) total++;
            }
        }
        return total;
    }

    void Framework_Pool_ShrinkAllImpl() {
        for (auto& kv : g_pools) {
            auto& objs = kv.second.objects;
            objs.erase(
                std::remove_if(objs.begin(), objs.end(),
                    [](const PoolObject& o) { return !o.active; }),
                objs.end()
            );
            // Rebuild available indices
            kv.second.availableIndices.clear();
        }
    }

    // ========================================================================
    // STATE MACHINE SYSTEM
    // ========================================================================

    struct FSMState {
        int id;
        std::string name;
        StateEnterCallback enterCallback = nullptr;
        void* enterUserData = nullptr;
        StateUpdateCallback updateCallback = nullptr;
        void* updateUserData = nullptr;
        StateExitCallback exitCallback = nullptr;
        void* exitUserData = nullptr;
    };

    struct FSMTransition {
        int id;
        int fromState;
        int toState;
        bool isAnyState;  // Can trigger from any state
        TransitionCondition condition = nullptr;
        void* conditionUserData = nullptr;
    };

    struct FSMTrigger {
        int id;
        std::string name;
        int fromState;  // -1 for any state
        int toState;
        void* lastData = nullptr;
    };

    struct StateMachine {
        int id;
        std::string name;
        int entity = -1;  // -1 if not bound to entity

        std::unordered_map<int, FSMState> states;
        std::unordered_map<std::string, int> stateIdByName;
        int nextStateId = 0;

        std::unordered_map<int, FSMTransition> transitions;
        int nextTransitionId = 0;

        std::unordered_map<int, FSMTrigger> triggers;
        std::unordered_map<std::string, std::vector<int>> triggerIdsByName;
        int nextTriggerId = 0;

        int initialState = -1;
        int currentState = -1;
        int previousState = -1;

        bool running = false;
        bool paused = false;

        float timeInState = 0.0f;
        int stateChangeCount = 0;

        std::vector<int> stateHistory;
        int maxHistorySize = 10;

        bool debugEnabled = false;
    };

    static std::unordered_map<int, StateMachine> g_fsms;
    static std::unordered_map<std::string, int> g_fsmIdByName;
    static std::unordered_map<int, int> g_fsmIdByEntity;
    static int g_nextFsmId = 1;
    static bool g_fsmGlobalPaused = false;

    static StateMachine* GetFSM(int fsmId) {
        auto it = g_fsms.find(fsmId);
        return (it != g_fsms.end()) ? &it->second : nullptr;
    }

    static FSMState* GetFSMState(StateMachine* fsm, int stateId) {
        if (!fsm) return nullptr;
        auto it = fsm->states.find(stateId);
        return (it != fsm->states.end()) ? &it->second : nullptr;
    }

    static void FSMPerformTransition(StateMachine* fsm, int newState) {
        if (!fsm || newState == fsm->currentState) return;

        FSMState* oldStateObj = GetFSMState(fsm, fsm->currentState);
        FSMState* newStateObj = GetFSMState(fsm, newState);

        if (!newStateObj) return;

        // Exit old state
        if (oldStateObj && oldStateObj->exitCallback) {
            oldStateObj->exitCallback(fsm->id, fsm->currentState, newState, oldStateObj->exitUserData);
        }

        // Update history
        if (fsm->currentState >= 0) {
            fsm->stateHistory.insert(fsm->stateHistory.begin(), fsm->currentState);
            while ((int)fsm->stateHistory.size() > fsm->maxHistorySize) {
                fsm->stateHistory.pop_back();
            }
        }

        int prevState = fsm->currentState;
        fsm->previousState = prevState;
        fsm->currentState = newState;
        fsm->timeInState = 0.0f;
        fsm->stateChangeCount++;

        if (fsm->debugEnabled) {
            const char* fromName = prevState >= 0 ? fsm->states[prevState].name.c_str() : "none";
            const char* toName = newStateObj->name.c_str();
            TraceLog(LOG_INFO, "FSM[%s]: %s -> %s", fsm->name.c_str(), fromName, toName);
        }

        // Enter new state
        if (newStateObj->enterCallback) {
            newStateObj->enterCallback(fsm->id, newState, prevState, newStateObj->enterUserData);
        }
    }

    // FSM creation and management
    int Framework_FSM_Create(const char* name) {
        StateMachine fsm;
        fsm.id = g_nextFsmId++;
        fsm.name = name ? name : "";

        g_fsms[fsm.id] = fsm;
        if (name && strlen(name) > 0) {
            g_fsmIdByName[name] = fsm.id;
        }

        return fsm.id;
    }

    int Framework_FSM_CreateForEntity(const char* name, int entity) {
        int fsmId = Framework_FSM_Create(name);
        auto* fsm = GetFSM(fsmId);
        if (fsm) {
            fsm->entity = entity;
            g_fsmIdByEntity[entity] = fsmId;
        }
        return fsmId;
    }

    void Framework_FSM_Destroy(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm) return;

        // Stop if running
        if (fsm->running) {
            Framework_FSM_Stop(fsmId);
        }

        // Remove from lookup maps
        if (!fsm->name.empty()) {
            g_fsmIdByName.erase(fsm->name);
        }
        if (fsm->entity >= 0) {
            g_fsmIdByEntity.erase(fsm->entity);
        }

        g_fsms.erase(fsmId);
    }

    int Framework_FSM_GetByName(const char* name) {
        if (!name) return -1;
        auto it = g_fsmIdByName.find(name);
        return (it != g_fsmIdByName.end()) ? it->second : -1;
    }

    int Framework_FSM_GetForEntity(int entity) {
        auto it = g_fsmIdByEntity.find(entity);
        return (it != g_fsmIdByEntity.end()) ? it->second : -1;
    }

    bool Framework_FSM_IsValid(int fsmId) {
        return GetFSM(fsmId) != nullptr;
    }

    // State registration
    int Framework_FSM_AddState(int fsmId, const char* stateName) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm || !stateName) return -1;

        // Check if state already exists
        auto it = fsm->stateIdByName.find(stateName);
        if (it != fsm->stateIdByName.end()) {
            return it->second;
        }

        FSMState state;
        state.id = fsm->nextStateId++;
        state.name = stateName;

        fsm->states[state.id] = state;
        fsm->stateIdByName[stateName] = state.id;

        return state.id;
    }

    int Framework_FSM_GetState(int fsmId, const char* stateName) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm || !stateName) return -1;

        auto it = fsm->stateIdByName.find(stateName);
        return (it != fsm->stateIdByName.end()) ? it->second : -1;
    }

    const char* Framework_FSM_GetStateName(int fsmId, int stateId) {
        auto* fsm = GetFSM(fsmId);
        auto* state = GetFSMState(fsm, stateId);
        return state ? state->name.c_str() : "";
    }

    void Framework_FSM_RemoveState(int fsmId, int stateId) {
        auto* fsm = GetFSM(fsmId);
        auto* state = GetFSMState(fsm, stateId);
        if (!state) return;

        // Can't remove current state while running
        if (fsm->running && fsm->currentState == stateId) return;

        fsm->stateIdByName.erase(state->name);
        fsm->states.erase(stateId);

        // Remove transitions involving this state
        std::vector<int> toRemove;
        for (auto& pair : fsm->transitions) {
            if (pair.second.fromState == stateId || pair.second.toState == stateId) {
                toRemove.push_back(pair.first);
            }
        }
        for (int id : toRemove) {
            fsm->transitions.erase(id);
        }
    }

    int Framework_FSM_GetStateCount(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        return fsm ? (int)fsm->states.size() : 0;
    }

    // State callbacks
    void Framework_FSM_SetStateEnter(int fsmId, int stateId, StateEnterCallback callback, void* userData) {
        auto* fsm = GetFSM(fsmId);
        auto* state = GetFSMState(fsm, stateId);
        if (state) {
            state->enterCallback = callback;
            state->enterUserData = userData;
        }
    }

    void Framework_FSM_SetStateUpdate(int fsmId, int stateId, StateUpdateCallback callback, void* userData) {
        auto* fsm = GetFSM(fsmId);
        auto* state = GetFSMState(fsm, stateId);
        if (state) {
            state->updateCallback = callback;
            state->updateUserData = userData;
        }
    }

    void Framework_FSM_SetStateExit(int fsmId, int stateId, StateExitCallback callback, void* userData) {
        auto* fsm = GetFSM(fsmId);
        auto* state = GetFSMState(fsm, stateId);
        if (state) {
            state->exitCallback = callback;
            state->exitUserData = userData;
        }
    }

    // Transitions
    int Framework_FSM_AddTransition(int fsmId, int fromState, int toState) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm) return -1;

        FSMTransition transition;
        transition.id = fsm->nextTransitionId++;
        transition.fromState = fromState;
        transition.toState = toState;
        transition.isAnyState = false;

        fsm->transitions[transition.id] = transition;
        return transition.id;
    }

    void Framework_FSM_SetTransitionCondition(int fsmId, int transitionId, TransitionCondition condition, void* userData) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm) return;

        auto it = fsm->transitions.find(transitionId);
        if (it != fsm->transitions.end()) {
            it->second.condition = condition;
            it->second.conditionUserData = userData;
        }
    }

    void Framework_FSM_RemoveTransition(int fsmId, int transitionId) {
        auto* fsm = GetFSM(fsmId);
        if (fsm) {
            fsm->transitions.erase(transitionId);
        }
    }

    bool Framework_FSM_CanTransition(int fsmId, int fromState, int toState) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm) return false;

        for (auto& pair : fsm->transitions) {
            auto& t = pair.second;
            if ((t.fromState == fromState || t.isAnyState) && t.toState == toState) {
                if (!t.condition) return true;
                return t.condition(fsmId, fromState, toState, t.conditionUserData);
            }
        }
        return false;
    }

    // Any-state transitions
    int Framework_FSM_AddAnyTransition(int fsmId, int toState) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm) return -1;

        FSMTransition transition;
        transition.id = fsm->nextTransitionId++;
        transition.fromState = -1;
        transition.toState = toState;
        transition.isAnyState = true;

        fsm->transitions[transition.id] = transition;
        return transition.id;
    }

    void Framework_FSM_SetAnyTransitionCondition(int fsmId, int transitionId, TransitionCondition condition, void* userData) {
        Framework_FSM_SetTransitionCondition(fsmId, transitionId, condition, userData);
    }

    // State machine control
    void Framework_FSM_SetInitialState(int fsmId, int stateId) {
        auto* fsm = GetFSM(fsmId);
        if (fsm) {
            fsm->initialState = stateId;
        }
    }

    void Framework_FSM_Start(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm || fsm->running) return;

        fsm->running = true;
        fsm->paused = false;
        fsm->timeInState = 0.0f;
        fsm->stateChangeCount = 0;
        fsm->stateHistory.clear();
        fsm->previousState = -1;

        // Enter initial state
        if (fsm->initialState >= 0) {
            fsm->currentState = fsm->initialState;
            auto* state = GetFSMState(fsm, fsm->initialState);
            if (state && state->enterCallback) {
                state->enterCallback(fsm->id, fsm->initialState, -1, state->enterUserData);
            }
            if (fsm->debugEnabled) {
                TraceLog(LOG_INFO, "FSM[%s]: Started in state '%s'", fsm->name.c_str(), state ? state->name.c_str() : "unknown");
            }
        }
    }

    void Framework_FSM_Stop(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm || !fsm->running) return;

        // Exit current state
        auto* state = GetFSMState(fsm, fsm->currentState);
        if (state && state->exitCallback) {
            state->exitCallback(fsm->id, fsm->currentState, -1, state->exitUserData);
        }

        fsm->running = false;
        fsm->paused = false;
        fsm->currentState = -1;

        if (fsm->debugEnabled) {
            TraceLog(LOG_INFO, "FSM[%s]: Stopped", fsm->name.c_str());
        }
    }

    void Framework_FSM_Pause(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        if (fsm && fsm->running) {
            fsm->paused = true;
        }
    }

    void Framework_FSM_Resume(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        if (fsm && fsm->running) {
            fsm->paused = false;
        }
    }

    bool Framework_FSM_IsRunning(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        return fsm ? fsm->running : false;
    }

    bool Framework_FSM_IsPaused(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        return fsm ? fsm->paused : false;
    }

    // State queries
    int Framework_FSM_GetCurrentState(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        return fsm ? fsm->currentState : -1;
    }

    int Framework_FSM_GetPreviousState(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        return fsm ? fsm->previousState : -1;
    }

    float Framework_FSM_GetTimeInState(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        return fsm ? fsm->timeInState : 0.0f;
    }

    int Framework_FSM_GetStateChangeCount(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        return fsm ? fsm->stateChangeCount : 0;
    }

    // Manual transitions
    bool Framework_FSM_TransitionTo(int fsmId, int stateId) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm || !fsm->running) return false;

        auto* state = GetFSMState(fsm, stateId);
        if (!state) return false;

        FSMPerformTransition(fsm, stateId);
        return true;
    }

    bool Framework_FSM_TransitionToByName(int fsmId, const char* stateName) {
        int stateId = Framework_FSM_GetState(fsmId, stateName);
        return Framework_FSM_TransitionTo(fsmId, stateId);
    }

    bool Framework_FSM_TryTransition(int fsmId, int toState) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm || !fsm->running) return false;

        if (Framework_FSM_CanTransition(fsmId, fsm->currentState, toState)) {
            FSMPerformTransition(fsm, toState);
            return true;
        }
        return false;
    }

    void Framework_FSM_RevertToPrevious(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm || !fsm->running || fsm->previousState < 0) return;

        FSMPerformTransition(fsm, fsm->previousState);
    }

    // State history
    void Framework_FSM_SetHistorySize(int fsmId, int size) {
        auto* fsm = GetFSM(fsmId);
        if (fsm && size >= 0) {
            fsm->maxHistorySize = size;
            while ((int)fsm->stateHistory.size() > size) {
                fsm->stateHistory.pop_back();
            }
        }
    }

    int Framework_FSM_GetHistoryState(int fsmId, int index) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm || index < 0 || index >= (int)fsm->stateHistory.size()) return -1;
        return fsm->stateHistory[index];
    }

    int Framework_FSM_GetHistoryCount(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        return fsm ? (int)fsm->stateHistory.size() : 0;
    }

    // Triggers
    int Framework_FSM_AddTrigger(int fsmId, const char* triggerName, int fromState, int toState) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm || !triggerName) return -1;

        FSMTrigger trigger;
        trigger.id = fsm->nextTriggerId++;
        trigger.name = triggerName;
        trigger.fromState = fromState;
        trigger.toState = toState;

        fsm->triggers[trigger.id] = trigger;
        fsm->triggerIdsByName[triggerName].push_back(trigger.id);

        return trigger.id;
    }

    void Framework_FSM_FireTrigger(int fsmId, const char* triggerName) {
        Framework_FSM_FireTriggerWithData(fsmId, triggerName, nullptr);
    }

    void Framework_FSM_FireTriggerWithData(int fsmId, const char* triggerName, void* data) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm || !fsm->running || !triggerName) return;

        auto it = fsm->triggerIdsByName.find(triggerName);
        if (it == fsm->triggerIdsByName.end()) return;

        for (int triggerId : it->second) {
            auto trigIt = fsm->triggers.find(triggerId);
            if (trigIt == fsm->triggers.end()) continue;

            auto& trigger = trigIt->second;
            trigger.lastData = data;

            // Check if trigger applies to current state
            if (trigger.fromState < 0 || trigger.fromState == fsm->currentState) {
                if (fsm->debugEnabled) {
                    TraceLog(LOG_INFO, "FSM[%s]: Trigger '%s' fired", fsm->name.c_str(), triggerName);
                }
                FSMPerformTransition(fsm, trigger.toState);
                return;  // Only first matching trigger
            }
        }
    }

    void Framework_FSM_RemoveTrigger(int fsmId, int triggerId) {
        auto* fsm = GetFSM(fsmId);
        if (!fsm) return;

        auto it = fsm->triggers.find(triggerId);
        if (it == fsm->triggers.end()) return;

        // Remove from name lookup
        auto& triggerList = fsm->triggerIdsByName[it->second.name];
        triggerList.erase(std::remove(triggerList.begin(), triggerList.end(), triggerId), triggerList.end());
        if (triggerList.empty()) {
            fsm->triggerIdsByName.erase(it->second.name);
        }

        fsm->triggers.erase(triggerId);
    }

    // Update
    void Framework_FSM_Update(int fsmId, float deltaTime) {
        if (g_fsmGlobalPaused) return;

        auto* fsm = GetFSM(fsmId);
        if (!fsm || !fsm->running || fsm->paused) return;

        fsm->timeInState += deltaTime;

        // Check auto-transitions
        for (auto& pair : fsm->transitions) {
            auto& t = pair.second;
            if ((t.fromState == fsm->currentState || t.isAnyState) && t.condition) {
                if (t.condition(fsmId, fsm->currentState, t.toState, t.conditionUserData)) {
                    FSMPerformTransition(fsm, t.toState);
                    break;  // Only one transition per frame
                }
            }
        }

        // Update current state
        auto* state = GetFSMState(fsm, fsm->currentState);
        if (state && state->updateCallback) {
            state->updateCallback(fsm->id, fsm->currentState, deltaTime, state->updateUserData);
        }
    }

    void Framework_FSM_UpdateAll(float deltaTime) {
        if (g_fsmGlobalPaused) return;

        for (auto& pair : g_fsms) {
            Framework_FSM_Update(pair.first, deltaTime);
        }
    }

    // Global FSM management
    int Framework_FSM_GetCount() {
        return (int)g_fsms.size();
    }

    void Framework_FSM_DestroyAll() {
        // Stop all first
        for (auto& pair : g_fsms) {
            if (pair.second.running) {
                pair.second.running = false;
            }
        }

        g_fsms.clear();
        g_fsmIdByName.clear();
        g_fsmIdByEntity.clear();
    }

    void Framework_FSM_PauseAll() {
        g_fsmGlobalPaused = true;
    }

    void Framework_FSM_ResumeAll() {
        g_fsmGlobalPaused = false;
    }

    // Debug
    void Framework_FSM_SetDebugEnabled(int fsmId, bool enabled) {
        auto* fsm = GetFSM(fsmId);
        if (fsm) {
            fsm->debugEnabled = enabled;
        }
    }

    bool Framework_FSM_GetDebugEnabled(int fsmId) {
        auto* fsm = GetFSM(fsmId);
        return fsm ? fsm->debugEnabled : false;
    }

    // ========================================================================
    // AI & PATHFINDING SYSTEM
    // ========================================================================

    struct NavCell {
        bool walkable = true;
        float cost = 1.0f;
    };

    struct NavGrid {
        int id;
        int width;
        int height;
        float cellSize;
        float originX = 0;
        float originY = 0;
        std::vector<NavCell> cells;
        bool diagonalEnabled = true;
        float diagonalCost = 1.414f;
        int heuristic = 1;  // 0=Manhattan, 1=Euclidean, 2=Chebyshev
    };

    struct PathWaypoint {
        float x, y;
    };

    struct NavPath {
        int id;
        std::vector<PathWaypoint> waypoints;
        float totalDistance = 0;
    };

    struct BehaviorConfig {
        bool enabled = false;
        float weight = 1.0f;
    };

    struct SteeringAgent {
        int id;
        int entity;
        float maxSpeed = 100.0f;
        float maxForce = 50.0f;
        float mass = 1.0f;
        float velocityX = 0;
        float velocityY = 0;
        float steeringX = 0;
        float steeringY = 0;

        // Target
        float targetX = 0;
        float targetY = 0;
        int targetEntity = -1;

        // Path following
        int pathId = -1;
        int currentWaypoint = 0;
        float pathOffset = 20.0f;
        bool reachedTarget = false;
        bool reachedPathEnd = false;

        // Arrive behavior
        float slowingRadius = 50.0f;

        // Wander behavior
        float wanderRadius = 30.0f;
        float wanderDistance = 50.0f;
        float wanderJitter = 20.0f;
        float wanderAngle = 0;

        // Flocking
        float neighborRadius = 100.0f;
        float separationRadius = 30.0f;

        // Obstacle avoidance
        float avoidanceRadius = 50.0f;
        float avoidanceForce = 100.0f;

        // Behaviors
        BehaviorConfig behaviors[12];

        bool debugEnabled = false;
    };

    static std::unordered_map<int, NavGrid> g_navGrids;
    static int g_nextNavGridId = 1;

    static std::unordered_map<int, NavPath> g_navPaths;
    static int g_nextPathId = 1;

    static std::unordered_map<int, SteeringAgent> g_steerAgents;
    static std::unordered_map<int, int> g_agentByEntity;
    static int g_nextAgentId = 1;

    static NavGrid* GetNavGrid(int gridId) {
        auto it = g_navGrids.find(gridId);
        return (it != g_navGrids.end()) ? &it->second : nullptr;
    }

    static NavPath* GetNavPath(int pathId) {
        auto it = g_navPaths.find(pathId);
        return (it != g_navPaths.end()) ? &it->second : nullptr;
    }

    static SteeringAgent* GetSteerAgent(int agentId) {
        auto it = g_steerAgents.find(agentId);
        return (it != g_steerAgents.end()) ? &it->second : nullptr;
    }

    // Navigation grid functions
    int Framework_NavGrid_Create(int width, int height, float cellSize) {
        NavGrid grid;
        grid.id = g_nextNavGridId++;
        grid.width = width;
        grid.height = height;
        grid.cellSize = cellSize;
        grid.cells.resize(width * height);

        g_navGrids[grid.id] = grid;
        return grid.id;
    }

    void Framework_NavGrid_Destroy(int gridId) {
        g_navGrids.erase(gridId);
    }

    bool Framework_NavGrid_IsValid(int gridId) {
        return GetNavGrid(gridId) != nullptr;
    }

    void Framework_NavGrid_SetOrigin(int gridId, float x, float y) {
        auto* grid = GetNavGrid(gridId);
        if (grid) {
            grid->originX = x;
            grid->originY = y;
        }
    }

    void Framework_NavGrid_GetOrigin(int gridId, float* outX, float* outY) {
        auto* grid = GetNavGrid(gridId);
        if (grid) {
            if (outX) *outX = grid->originX;
            if (outY) *outY = grid->originY;
        }
    }

    void Framework_NavGrid_SetWalkable(int gridId, int cellX, int cellY, bool walkable) {
        auto* grid = GetNavGrid(gridId);
        if (!grid || cellX < 0 || cellX >= grid->width || cellY < 0 || cellY >= grid->height) return;
        grid->cells[cellY * grid->width + cellX].walkable = walkable;
    }

    bool Framework_NavGrid_IsWalkable(int gridId, int cellX, int cellY) {
        auto* grid = GetNavGrid(gridId);
        if (!grid || cellX < 0 || cellX >= grid->width || cellY < 0 || cellY >= grid->height) return false;
        return grid->cells[cellY * grid->width + cellX].walkable;
    }

    void Framework_NavGrid_SetCost(int gridId, int cellX, int cellY, float cost) {
        auto* grid = GetNavGrid(gridId);
        if (!grid || cellX < 0 || cellX >= grid->width || cellY < 0 || cellY >= grid->height) return;
        grid->cells[cellY * grid->width + cellX].cost = cost;
    }

    float Framework_NavGrid_GetCost(int gridId, int cellX, int cellY) {
        auto* grid = GetNavGrid(gridId);
        if (!grid || cellX < 0 || cellX >= grid->width || cellY < 0 || cellY >= grid->height) return 1.0f;
        return grid->cells[cellY * grid->width + cellX].cost;
    }

    void Framework_NavGrid_SetAllWalkable(int gridId, bool walkable) {
        auto* grid = GetNavGrid(gridId);
        if (!grid) return;
        for (auto& cell : grid->cells) cell.walkable = walkable;
    }

    // Alias for SetAllWalkable (used by VB wrapper)
    void Framework_NavGrid_Fill(int gridId, bool walkable) {
        Framework_NavGrid_SetAllWalkable(gridId, walkable);
    }

    int Framework_NavGrid_GetWidth(int gridId) {
        auto* grid = GetNavGrid(gridId);
        return grid ? grid->width : 0;
    }

    int Framework_NavGrid_GetHeight(int gridId) {
        auto* grid = GetNavGrid(gridId);
        return grid ? grid->height : 0;
    }

    float Framework_NavGrid_GetCellSize(int gridId) {
        auto* grid = GetNavGrid(gridId);
        return grid ? grid->cellSize : 0.0f;
    }

    void Framework_NavGrid_SetDiagonalEnabled(int gridId, bool enabled) {
        auto* grid = GetNavGrid(gridId);
        if (grid) grid->diagonalEnabled = enabled;
    }

    bool Framework_NavGrid_GetDiagonalEnabled(int gridId) {
        auto* grid = GetNavGrid(gridId);
        return grid ? grid->diagonalEnabled : false;
    }

    void Framework_NavGrid_SetDiagonalCost(int gridId, float cost) {
        auto* grid = GetNavGrid(gridId);
        if (grid) grid->diagonalCost = cost;
    }

    float Framework_NavGrid_GetDiagonalCost(int gridId) {
        auto* grid = GetNavGrid(gridId);
        return grid ? grid->diagonalCost : 1.414f;
    }

    void Framework_NavGrid_SetHeuristic(int gridId, int heuristic) {
        auto* grid = GetNavGrid(gridId);
        if (grid) grid->heuristic = heuristic;
    }

    int Framework_NavGrid_GetHeuristic(int gridId) {
        auto* grid = GetNavGrid(gridId);
        return grid ? grid->heuristic : 1;
    }

    void Framework_NavGrid_SetRect(int gridId, int x, int y, int w, int h, bool walkable) {
        auto* grid = GetNavGrid(gridId);
        if (!grid) return;
        for (int cy = y; cy < y + h && cy < grid->height; cy++) {
            for (int cx = x; cx < x + w && cx < grid->width; cx++) {
                if (cx >= 0 && cy >= 0) {
                    grid->cells[cy * grid->width + cx].walkable = walkable;
                }
            }
        }
    }

    void Framework_NavGrid_SetCircle(int gridId, int centerX, int centerY, int radius, bool walkable) {
        auto* grid = GetNavGrid(gridId);
        if (!grid) return;
        int r2 = radius * radius;
        for (int cy = centerY - radius; cy <= centerY + radius; cy++) {
            for (int cx = centerX - radius; cx <= centerX + radius; cx++) {
                if (cx >= 0 && cx < grid->width && cy >= 0 && cy < grid->height) {
                    int dx = cx - centerX;
                    int dy = cy - centerY;
                    if (dx * dx + dy * dy <= r2) {
                        grid->cells[cy * grid->width + cx].walkable = walkable;
                    }
                }
            }
        }
    }

    void Framework_NavGrid_WorldToCell(int gridId, float worldX, float worldY, int* outCellX, int* outCellY) {
        auto* grid = GetNavGrid(gridId);
        if (!grid) return;
        if (outCellX) *outCellX = (int)((worldX - grid->originX) / grid->cellSize);
        if (outCellY) *outCellY = (int)((worldY - grid->originY) / grid->cellSize);
    }

    void Framework_NavGrid_CellToWorld(int gridId, int cellX, int cellY, float* outWorldX, float* outWorldY) {
        auto* grid = GetNavGrid(gridId);
        if (!grid) return;
        if (outWorldX) *outWorldX = grid->originX + cellX * grid->cellSize + grid->cellSize * 0.5f;
        if (outWorldY) *outWorldY = grid->originY + cellY * grid->cellSize + grid->cellSize * 0.5f;
    }

    bool Framework_NavGrid_IsWorldPosWalkable(int gridId, float worldX, float worldY) {
        int cellX, cellY;
        Framework_NavGrid_WorldToCell(gridId, worldX, worldY, &cellX, &cellY);
        return Framework_NavGrid_IsWalkable(gridId, cellX, cellY);
    }

    // A* Pathfinding helper
    struct AStarNode {
        int x, y;
        float g, h, f;
        int parentX, parentY;
        bool operator>(const AStarNode& other) const { return f > other.f; }
    };

    static float Heuristic(int x1, int y1, int x2, int y2, int type) {
        float dx = (float)abs(x2 - x1);
        float dy = (float)abs(y2 - y1);
        switch (type) {
            case 0: return dx + dy;  // Manhattan
            case 1: return sqrtf(dx * dx + dy * dy);  // Euclidean
            case 2: return fmaxf(dx, dy);  // Chebyshev
            default: return sqrtf(dx * dx + dy * dy);
        }
    }

    int Framework_Path_FindCell(int gridId, int startCellX, int startCellY, int endCellX, int endCellY) {
        auto* grid = GetNavGrid(gridId);
        if (!grid) return -1;

        // Validate start and end
        if (!Framework_NavGrid_IsWalkable(gridId, startCellX, startCellY)) return -1;
        if (!Framework_NavGrid_IsWalkable(gridId, endCellX, endCellY)) return -1;

        // A* implementation
        std::priority_queue<AStarNode, std::vector<AStarNode>, std::greater<AStarNode>> openList;
        std::unordered_map<int, AStarNode> allNodes;
        std::unordered_set<int> closedSet;

        auto nodeKey = [&](int x, int y) { return y * grid->width + x; };

        AStarNode start;
        start.x = startCellX; start.y = startCellY;
        start.g = 0;
        start.h = Heuristic(startCellX, startCellY, endCellX, endCellY, grid->heuristic);
        start.f = start.g + start.h;
        start.parentX = -1; start.parentY = -1;

        openList.push(start);
        allNodes[nodeKey(startCellX, startCellY)] = start;

        int dx[] = { 0, 1, 0, -1, 1, 1, -1, -1 };
        int dy[] = { -1, 0, 1, 0, -1, 1, 1, -1 };
        int dirCount = grid->diagonalEnabled ? 8 : 4;

        while (!openList.empty()) {
            AStarNode current = openList.top();
            openList.pop();

            if (current.x == endCellX && current.y == endCellY) {
                // Reconstruct path
                NavPath path;
                path.id = g_nextPathId++;

                int cx = endCellX, cy = endCellY;
                while (cx != -1 && cy != -1) {
                    float wx, wy;
                    Framework_NavGrid_CellToWorld(gridId, cx, cy, &wx, &wy);
                    path.waypoints.insert(path.waypoints.begin(), PathWaypoint{ wx, wy });

                    int key = nodeKey(cx, cy);
                    auto it = allNodes.find(key);
                    if (it != allNodes.end()) {
                        cx = it->second.parentX;
                        cy = it->second.parentY;
                    } else {
                        break;
                    }
                }

                // Calculate total distance
                path.totalDistance = 0;
                for (size_t i = 1; i < path.waypoints.size(); i++) {
                    float dx = path.waypoints[i].x - path.waypoints[i - 1].x;
                    float dy = path.waypoints[i].y - path.waypoints[i - 1].y;
                    path.totalDistance += sqrtf(dx * dx + dy * dy);
                }

                g_navPaths[path.id] = path;
                return path.id;
            }

            closedSet.insert(nodeKey(current.x, current.y));

            for (int i = 0; i < dirCount; i++) {
                int nx = current.x + dx[i];
                int ny = current.y + dy[i];

                if (nx < 0 || nx >= grid->width || ny < 0 || ny >= grid->height) continue;
                if (!grid->cells[ny * grid->width + nx].walkable) continue;
                if (closedSet.count(nodeKey(nx, ny))) continue;

                // Check diagonal corners
                if (i >= 4) {
                    if (!Framework_NavGrid_IsWalkable(gridId, current.x + dx[i], current.y) ||
                        !Framework_NavGrid_IsWalkable(gridId, current.x, current.y + dy[i])) continue;
                }

                float moveCost = (i >= 4) ? grid->diagonalCost : 1.0f;
                float newG = current.g + moveCost * grid->cells[ny * grid->width + nx].cost;

                int nKey = nodeKey(nx, ny);
                auto it = allNodes.find(nKey);
                if (it == allNodes.end() || newG < it->second.g) {
                    AStarNode neighbor;
                    neighbor.x = nx; neighbor.y = ny;
                    neighbor.g = newG;
                    neighbor.h = Heuristic(nx, ny, endCellX, endCellY, grid->heuristic);
                    neighbor.f = neighbor.g + neighbor.h;
                    neighbor.parentX = current.x;
                    neighbor.parentY = current.y;

                    allNodes[nKey] = neighbor;
                    openList.push(neighbor);
                }
            }
        }

        return -1;  // No path found
    }

    int Framework_Path_Find(int gridId, float startX, float startY, float endX, float endY) {
        int startCellX, startCellY, endCellX, endCellY;
        Framework_NavGrid_WorldToCell(gridId, startX, startY, &startCellX, &startCellY);
        Framework_NavGrid_WorldToCell(gridId, endX, endY, &endCellX, &endCellY);
        return Framework_Path_FindCell(gridId, startCellX, startCellY, endCellX, endCellY);
    }

    void Framework_Path_Destroy(int pathId) {
        g_navPaths.erase(pathId);
    }

    bool Framework_Path_IsValid(int pathId) {
        return GetNavPath(pathId) != nullptr;
    }

    int Framework_Path_GetLength(int pathId) {
        auto* path = GetNavPath(pathId);
        return path ? (int)path->waypoints.size() : 0;
    }

    void Framework_Path_GetWaypoint(int pathId, int index, float* outX, float* outY) {
        auto* path = GetNavPath(pathId);
        if (!path || index < 0 || index >= (int)path->waypoints.size()) return;
        if (outX) *outX = path->waypoints[index].x;
        if (outY) *outY = path->waypoints[index].y;
    }

    float Framework_Path_GetTotalDistance(int pathId) {
        auto* path = GetNavPath(pathId);
        return path ? path->totalDistance : 0;
    }

    void Framework_Path_Smooth(int pathId) {
        auto* path = GetNavPath(pathId);
        if (!path || path->waypoints.size() < 3) return;

        std::vector<PathWaypoint> smoothed;
        smoothed.push_back(path->waypoints[0]);

        for (size_t i = 1; i < path->waypoints.size() - 1; i++) {
            // Simple averaging
            PathWaypoint wp;
            wp.x = (path->waypoints[i - 1].x + path->waypoints[i].x + path->waypoints[i + 1].x) / 3.0f;
            wp.y = (path->waypoints[i - 1].y + path->waypoints[i].y + path->waypoints[i + 1].y) / 3.0f;
            smoothed.push_back(wp);
        }

        smoothed.push_back(path->waypoints.back());
        path->waypoints = smoothed;

        // Recalculate distance
        path->totalDistance = 0;
        for (size_t i = 1; i < path->waypoints.size(); i++) {
            float dx = path->waypoints[i].x - path->waypoints[i - 1].x;
            float dy = path->waypoints[i].y - path->waypoints[i - 1].y;
            path->totalDistance += sqrtf(dx * dx + dy * dy);
        }
    }

    void Framework_Path_SimplifyRDP(int pathId, float epsilon) {
        auto* path = GetNavPath(pathId);
        if (!path || path->waypoints.size() < 3) return;

        std::function<void(int, int, std::vector<bool>&)> rdp = [&](int start, int end, std::vector<bool>& keep) {
            float maxDist = 0;
            int maxIdx = start;

            float x1 = path->waypoints[start].x, y1 = path->waypoints[start].y;
            float x2 = path->waypoints[end].x, y2 = path->waypoints[end].y;
            float dx = x2 - x1, dy = y2 - y1;
            float len = sqrtf(dx * dx + dy * dy);

            for (int i = start + 1; i < end; i++) {
                float dist;
                if (len < 0.0001f) {
                    dist = sqrtf((path->waypoints[i].x - x1) * (path->waypoints[i].x - x1) +
                                 (path->waypoints[i].y - y1) * (path->waypoints[i].y - y1));
                } else {
                    float t = ((path->waypoints[i].x - x1) * dx + (path->waypoints[i].y - y1) * dy) / (len * len);
                    t = fmaxf(0, fminf(1, t));
                    float projX = x1 + t * dx, projY = y1 + t * dy;
                    dist = sqrtf((path->waypoints[i].x - projX) * (path->waypoints[i].x - projX) +
                                 (path->waypoints[i].y - projY) * (path->waypoints[i].y - projY));
                }
                if (dist > maxDist) {
                    maxDist = dist;
                    maxIdx = i;
                }
            }

            if (maxDist > epsilon) {
                keep[maxIdx] = true;
                rdp(start, maxIdx, keep);
                rdp(maxIdx, end, keep);
            }
        };

        std::vector<bool> keep(path->waypoints.size(), false);
        keep[0] = true;
        keep[path->waypoints.size() - 1] = true;
        rdp(0, (int)path->waypoints.size() - 1, keep);

        std::vector<PathWaypoint> simplified;
        for (size_t i = 0; i < path->waypoints.size(); i++) {
            if (keep[i]) simplified.push_back(path->waypoints[i]);
        }
        path->waypoints = simplified;

        // Recalculate distance
        path->totalDistance = 0;
        for (size_t i = 1; i < path->waypoints.size(); i++) {
            float dx = path->waypoints[i].x - path->waypoints[i - 1].x;
            float dy = path->waypoints[i].y - path->waypoints[i - 1].y;
            path->totalDistance += sqrtf(dx * dx + dy * dy);
        }
    }

    void Framework_Path_SetDiagonalEnabled(int gridId, bool enabled) {
        auto* grid = GetNavGrid(gridId);
        if (grid) grid->diagonalEnabled = enabled;
    }

    void Framework_Path_SetDiagonalCost(int gridId, float cost) {
        auto* grid = GetNavGrid(gridId);
        if (grid) grid->diagonalCost = cost;
    }

    void Framework_Path_SetHeuristic(int gridId, int heuristic) {
        auto* grid = GetNavGrid(gridId);
        if (grid) grid->heuristic = heuristic;
    }

    // Steering agent functions
    int Framework_Steer_CreateAgent(int entity) {
        SteeringAgent agent;
        agent.id = g_nextAgentId++;
        agent.entity = entity;

        g_steerAgents[agent.id] = agent;
        g_agentByEntity[entity] = agent.id;
        return agent.id;
    }

    void Framework_Steer_DestroyAgent(int agentId) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) {
            g_agentByEntity.erase(agent->entity);
            g_steerAgents.erase(agentId);
        }
    }

    int Framework_Steer_GetAgentForEntity(int entity) {
        auto it = g_agentByEntity.find(entity);
        return (it != g_agentByEntity.end()) ? it->second : -1;
    }

    bool Framework_Steer_IsAgentValid(int agentId) {
        return GetSteerAgent(agentId) != nullptr;
    }

    void Framework_Steer_SetMaxSpeed(int agentId, float maxSpeed) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) agent->maxSpeed = maxSpeed;
    }

    float Framework_Steer_GetMaxSpeed(int agentId) {
        auto* agent = GetSteerAgent(agentId);
        return agent ? agent->maxSpeed : 0;
    }

    void Framework_Steer_SetMaxForce(int agentId, float maxForce) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) agent->maxForce = maxForce;
    }

    float Framework_Steer_GetMaxForce(int agentId) {
        auto* agent = GetSteerAgent(agentId);
        return agent ? agent->maxForce : 0;
    }

    void Framework_Steer_SetMass(int agentId, float mass) {
        auto* agent = GetSteerAgent(agentId);
        if (agent && mass > 0) agent->mass = mass;
    }

    float Framework_Steer_GetMass(int agentId) {
        auto* agent = GetSteerAgent(agentId);
        return agent ? agent->mass : 1.0f;
    }

    void Framework_Steer_SetSlowingRadius(int agentId, float radius) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) agent->slowingRadius = radius;
    }

    void Framework_Steer_SetWanderRadius(int agentId, float radius) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) agent->wanderRadius = radius;
    }

    void Framework_Steer_SetWanderDistance(int agentId, float distance) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) agent->wanderDistance = distance;
    }

    void Framework_Steer_SetWanderJitter(int agentId, float jitter) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) agent->wanderJitter = jitter;
    }

    void Framework_Steer_GetVelocity(int agentId, float* outX, float* outY) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) {
            if (outX) *outX = agent->velocityX;
            if (outY) *outY = agent->velocityY;
        }
    }

    void Framework_Steer_SetVelocity(int agentId, float x, float y) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) {
            agent->velocityX = x;
            agent->velocityY = y;
        }
    }

    void Framework_Steer_EnableBehavior(int agentId, int behavior, bool enabled) {
        auto* agent = GetSteerAgent(agentId);
        if (agent && behavior >= 0 && behavior < 12) {
            agent->behaviors[behavior].enabled = enabled;
        }
    }

    bool Framework_Steer_IsBehaviorEnabled(int agentId, int behavior) {
        auto* agent = GetSteerAgent(agentId);
        if (agent && behavior >= 0 && behavior < 12) {
            return agent->behaviors[behavior].enabled;
        }
        return false;
    }

    void Framework_Steer_SetBehaviorWeight(int agentId, int behavior, float weight) {
        auto* agent = GetSteerAgent(agentId);
        if (agent && behavior >= 0 && behavior < 12) {
            agent->behaviors[behavior].weight = weight;
        }
    }

    float Framework_Steer_GetBehaviorWeight(int agentId, int behavior) {
        auto* agent = GetSteerAgent(agentId);
        if (agent && behavior >= 0 && behavior < 12) {
            return agent->behaviors[behavior].weight;
        }
        return 1.0f;
    }

    void Framework_Steer_SetTargetPosition(int agentId, float x, float y) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) {
            agent->targetX = x;
            agent->targetY = y;
            agent->targetEntity = -1;
        }
    }

    void Framework_Steer_SetTargetEntity(int agentId, int targetEntity) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) {
            agent->targetEntity = targetEntity;
        }
    }

    void Framework_Steer_SetPath(int agentId, int pathId) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) {
            agent->pathId = pathId;
            agent->currentWaypoint = 0;
            agent->reachedPathEnd = false;
        }
    }

    void Framework_Steer_SetPathOffset(int agentId, float offset) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) agent->pathOffset = offset;
    }

    void Framework_Steer_SetNeighborRadius(int agentId, float radius) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) agent->neighborRadius = radius;
    }

    void Framework_Steer_SetSeparationRadius(int agentId, float radius) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) agent->separationRadius = radius;
    }

    void Framework_Steer_SetAvoidanceRadius(int agentId, float radius) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) agent->avoidanceRadius = radius;
    }

    void Framework_Steer_SetAvoidanceForce(int agentId, float force) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) agent->avoidanceForce = force;
    }

    static Vector2 Truncate(Vector2 v, float max) {
        float len = sqrtf(v.x * v.x + v.y * v.y);
        if (len > max && len > 0) {
            v.x = v.x / len * max;
            v.y = v.y / len * max;
        }
        return v;
    }

    static Vector2 Normalize(Vector2 v) {
        float len = sqrtf(v.x * v.x + v.y * v.y);
        if (len > 0) {
            v.x /= len;
            v.y /= len;
        }
        return v;
    }

    void Framework_Steer_Update(int agentId, float deltaTime) {
        auto* agent = GetSteerAgent(agentId);
        if (!agent) return;

        // Get agent position from entity
        Vector2 pos = GetWorldPositionInternal(agent->entity);
        Vector2 steering = { 0, 0 };

        // Get target position
        Vector2 target = { agent->targetX, agent->targetY };
        if (agent->targetEntity >= 0) {
            target = GetWorldPositionInternal(agent->targetEntity);
            agent->targetX = target.x;
            agent->targetY = target.y;
        }

        // Seek
        if (agent->behaviors[STEER_SEEK].enabled) {
            Vector2 desired = { target.x - pos.x, target.y - pos.y };
            desired = Normalize(desired);
            desired.x *= agent->maxSpeed;
            desired.y *= agent->maxSpeed;
            Vector2 force = { desired.x - agent->velocityX, desired.y - agent->velocityY };
            force.x *= agent->behaviors[STEER_SEEK].weight;
            force.y *= agent->behaviors[STEER_SEEK].weight;
            steering.x += force.x;
            steering.y += force.y;
        }

        // Flee
        if (agent->behaviors[STEER_FLEE].enabled) {
            Vector2 desired = { pos.x - target.x, pos.y - target.y };
            desired = Normalize(desired);
            desired.x *= agent->maxSpeed;
            desired.y *= agent->maxSpeed;
            Vector2 force = { desired.x - agent->velocityX, desired.y - agent->velocityY };
            force.x *= agent->behaviors[STEER_FLEE].weight;
            force.y *= agent->behaviors[STEER_FLEE].weight;
            steering.x += force.x;
            steering.y += force.y;
        }

        // Arrive
        if (agent->behaviors[STEER_ARRIVE].enabled) {
            Vector2 toTarget = { target.x - pos.x, target.y - pos.y };
            float dist = sqrtf(toTarget.x * toTarget.x + toTarget.y * toTarget.y);

            if (dist > 0.1f) {
                float speed = agent->maxSpeed;
                if (dist < agent->slowingRadius) {
                    speed = agent->maxSpeed * (dist / agent->slowingRadius);
                }
                Vector2 desired = Normalize(toTarget);
                desired.x *= speed;
                desired.y *= speed;
                Vector2 force = { desired.x - agent->velocityX, desired.y - agent->velocityY };
                force.x *= agent->behaviors[STEER_ARRIVE].weight;
                force.y *= agent->behaviors[STEER_ARRIVE].weight;
                steering.x += force.x;
                steering.y += force.y;
            }

            agent->reachedTarget = dist < 5.0f;
        }

        // Wander
        if (agent->behaviors[STEER_WANDER].enabled) {
            agent->wanderAngle += ((float)rand() / RAND_MAX - 0.5f) * agent->wanderJitter;
            float circleX = agent->velocityX;
            float circleY = agent->velocityY;
            Vector2 circleDir = Normalize(Vector2{ circleX, circleY });
            if (circleDir.x == 0 && circleDir.y == 0) {
                circleDir.x = 1;
            }
            float cx = pos.x + circleDir.x * agent->wanderDistance;
            float cy = pos.y + circleDir.y * agent->wanderDistance;
            float tx = cx + cosf(agent->wanderAngle) * agent->wanderRadius;
            float ty = cy + sinf(agent->wanderAngle) * agent->wanderRadius;

            Vector2 desired = { tx - pos.x, ty - pos.y };
            desired = Normalize(desired);
            desired.x *= agent->maxSpeed;
            desired.y *= agent->maxSpeed;
            Vector2 force = { desired.x - agent->velocityX, desired.y - agent->velocityY };
            force.x *= agent->behaviors[STEER_WANDER].weight;
            force.y *= agent->behaviors[STEER_WANDER].weight;
            steering.x += force.x;
            steering.y += force.y;
        }

        // Path follow
        if (agent->behaviors[STEER_PATH_FOLLOW].enabled && agent->pathId >= 0) {
            auto* path = GetNavPath(agent->pathId);
            if (path && !path->waypoints.empty() && agent->currentWaypoint < (int)path->waypoints.size()) {
                Vector2 wp = { path->waypoints[agent->currentWaypoint].x, path->waypoints[agent->currentWaypoint].y };
                float dx = wp.x - pos.x;
                float dy = wp.y - pos.y;
                float dist = sqrtf(dx * dx + dy * dy);

                if (dist < agent->pathOffset) {
                    agent->currentWaypoint++;
                    if (agent->currentWaypoint >= (int)path->waypoints.size()) {
                        agent->reachedPathEnd = true;
                    }
                }

                if (!agent->reachedPathEnd) {
                    Vector2 desired = { wp.x - pos.x, wp.y - pos.y };
                    desired = Normalize(desired);
                    desired.x *= agent->maxSpeed;
                    desired.y *= agent->maxSpeed;
                    Vector2 force = { desired.x - agent->velocityX, desired.y - agent->velocityY };
                    force.x *= agent->behaviors[STEER_PATH_FOLLOW].weight;
                    force.y *= agent->behaviors[STEER_PATH_FOLLOW].weight;
                    steering.x += force.x;
                    steering.y += force.y;
                }
            }
        }

        // Truncate and apply steering
        steering = Truncate(steering, agent->maxForce);
        steering.x /= agent->mass;
        steering.y /= agent->mass;

        agent->steeringX = steering.x;
        agent->steeringY = steering.y;

        // Update velocity
        agent->velocityX += steering.x * deltaTime;
        agent->velocityY += steering.y * deltaTime;
        Vector2 vel = Truncate(Vector2{ agent->velocityX, agent->velocityY }, agent->maxSpeed);
        agent->velocityX = vel.x;
        agent->velocityY = vel.y;

        // Update entity position
        auto it = g_transform2D.find(agent->entity);
        if (it != g_transform2D.end()) {
            it->second.position.x += agent->velocityX * deltaTime;
            it->second.position.y += agent->velocityY * deltaTime;
        }
    }

    void Framework_Steer_UpdateAll(float deltaTime) {
        for (auto& pair : g_steerAgents) {
            Framework_Steer_Update(pair.first, deltaTime);
        }
    }

    void Framework_Steer_GetSteeringForce(int agentId, float* outX, float* outY) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) {
            if (outX) *outX = agent->steeringX;
            if (outY) *outY = agent->steeringY;
        }
    }

    int Framework_Steer_GetCurrentWaypoint(int agentId) {
        auto* agent = GetSteerAgent(agentId);
        return agent ? agent->currentWaypoint : 0;
    }

    bool Framework_Steer_HasReachedTarget(int agentId) {
        auto* agent = GetSteerAgent(agentId);
        return agent ? agent->reachedTarget : false;
    }

    bool Framework_Steer_HasReachedPathEnd(int agentId) {
        auto* agent = GetSteerAgent(agentId);
        return agent ? agent->reachedPathEnd : false;
    }

    void Framework_Steer_ResetPath(int agentId) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) {
            agent->currentWaypoint = 0;
            agent->reachedPathEnd = false;
        }
    }

    // Debug visualization
    void Framework_NavGrid_DrawDebug(int gridId) {
        auto* grid = GetNavGrid(gridId);
        if (!grid) return;

        for (int y = 0; y < grid->height; y++) {
            for (int x = 0; x < grid->width; x++) {
                float wx = grid->originX + x * grid->cellSize;
                float wy = grid->originY + y * grid->cellSize;
                Color col = grid->cells[y * grid->width + x].walkable ? Color{ 0, 100, 0, 50 } : Color{ 100, 0, 0, 100 };
                DrawRectangle((int)wx, (int)wy, (int)grid->cellSize - 1, (int)grid->cellSize - 1, col);
            }
        }
    }

    void Framework_Path_DrawDebug(int pathId, unsigned char r, unsigned char g, unsigned char b) {
        auto* path = GetNavPath(pathId);
        if (!path || path->waypoints.size() < 2) return;

        Color col = { r, g, b, 255 };
        for (size_t i = 0; i < path->waypoints.size() - 1; i++) {
            DrawLineV(Vector2{ path->waypoints[i].x, path->waypoints[i].y },
                      Vector2{ path->waypoints[i + 1].x, path->waypoints[i + 1].y }, col);
        }

        for (auto& wp : path->waypoints) {
            DrawCircle((int)wp.x, (int)wp.y, 3, col);
        }
    }

    void Framework_Steer_DrawDebug(int agentId) {
        auto* agent = GetSteerAgent(agentId);
        if (!agent || !agent->debugEnabled) return;

        Vector2 pos = GetWorldPositionInternal(agent->entity);

        // Draw velocity
        DrawLineV(pos, Vector2{ pos.x + agent->velocityX * 0.5f, pos.y + agent->velocityY * 0.5f }, GREEN);

        // Draw steering
        DrawLineV(pos, Vector2{ pos.x + agent->steeringX * 0.5f, pos.y + agent->steeringY * 0.5f }, RED);

        // Draw target
        DrawCircle((int)agent->targetX, (int)agent->targetY, 5, YELLOW);
    }

    void Framework_Steer_SetDebugEnabled(int agentId, bool enabled) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) agent->debugEnabled = enabled;
    }

    // Aliases for VB wrapper compatibility
    bool Framework_Steer_IsValid(int agentId) {
        return Framework_Steer_IsAgentValid(agentId);
    }

    void Framework_Steer_SetTarget(int agentId, float x, float y) {
        Framework_Steer_SetTargetPosition(agentId, x, y);
    }

    void Framework_Steer_ClearTarget(int agentId) {
        auto* agent = GetSteerAgent(agentId);
        if (agent) {
            agent->targetX = 0;
            agent->targetY = 0;
            agent->targetEntity = -1;
            agent->reachedTarget = true;  // Consider target cleared as "reached"
        }
    }

    // Obstacle management for steering
    static std::vector<Vector3> g_obstacles;  // x, y, radius

    void Framework_Steer_AddObstacle(float x, float y, float radius) {
        g_obstacles.push_back({ x, y, radius });
    }

    void Framework_Steer_ClearObstacles() {
        g_obstacles.clear();
    }

    int Framework_Steer_GetObstacleCount() {
        return (int)g_obstacles.size();
    }

    // AI/Pathfinding global counts
    int Framework_AI_GetAgentCount() {
        return (int)g_steerAgents.size();
    }

    int Framework_AI_GetPathCount() {
        return (int)g_navPaths.size();
    }

    int Framework_AI_GetGridCount() {
        return (int)g_navGrids.size();
    }

    void Framework_AI_DestroyAll() {
        g_navGrids.clear();
        g_navPaths.clear();
        g_steerAgents.clear();
        g_agentByEntity.clear();
        g_obstacles.clear();
    }

    // Global management
    void Framework_NavGrid_DestroyAll() {
        g_navGrids.clear();
    }

    void Framework_Path_DestroyAll() {
        g_navPaths.clear();
    }

    void Framework_Steer_DestroyAllAgents() {
        g_steerAgents.clear();
        g_agentByEntity.clear();
    }

    // ========================================================================
    // DIALOGUE SYSTEM
    // ========================================================================

    struct DialogueChoice {
        std::string text;
        int targetNodeId = -1;
        std::string condition;
    };

    struct DialogueNode {
        int id = 0;
        std::string tag;
        std::string speaker;
        std::string text;
        int portrait = -1;
        int nextNodeId = -1;
        std::string condition;
        std::string eventName;
        std::vector<DialogueChoice> choices;
    };

    struct Dialogue {
        int id = 0;
        std::string name;
        int startNodeId = -1;
        std::unordered_map<int, DialogueNode> nodes;
        int nextNodeId = 0;
    };

    struct Speaker {
        std::string id;
        std::string displayName;
        int portrait = -1;
    };

    struct DialogueHistoryEntry {
        std::string speaker;
        std::string text;
    };

    // Dialogue variable union for storage
    struct DialogueVar {
        enum Type { INT, FLOAT, BOOL, STRING } type = INT;
        int intVal = 0;
        float floatVal = 0.0f;
        bool boolVal = false;
        std::string strVal;
    };

    // Global dialogue state
    namespace {
        std::unordered_map<int, Dialogue> g_dialogues;
        std::unordered_map<std::string, int> g_dialogueByName;
        int g_nextDialogueId = 1;

        std::unordered_map<std::string, Speaker> g_speakers;
        std::unordered_map<std::string, DialogueVar> g_dialogueVars;

        // Active playback state
        int g_activeDialogueId = -1;
        int g_activeNodeId = -1;

        // Typewriter state
        bool g_typewriterEnabled = true;
        float g_typewriterSpeed = 30.0f;  // chars per second
        float g_typewriterProgress = 0.0f;
        bool g_typewriterComplete = false;
        std::string g_visibleText;

        // Callbacks
        DialogueCallback g_onDialogueStart = nullptr;
        DialogueCallback g_onDialogueEnd = nullptr;
        DialogueCallback g_onNodeEnter = nullptr;
        DialogueCallback g_onNodeExit = nullptr;
        DialogueChoiceCallback g_onChoice = nullptr;
        DialogueConditionCallback g_conditionHandler = nullptr;
        void* g_dialogueStartUserData = nullptr;
        void* g_dialogueEndUserData = nullptr;
        void* g_nodeEnterUserData = nullptr;
        void* g_nodeExitUserData = nullptr;
        void* g_choiceUserData = nullptr;
        void* g_conditionUserData = nullptr;

        // History
        bool g_historyEnabled = false;
        std::vector<DialogueHistoryEntry> g_dialogueHistory;

        // Static buffers for string returns
        static char s_dialogueSpeakerBuf[256] = {0};
        static char s_dialogueTextBuf[2048] = {0};
        static char s_dialogueChoiceBuf[512] = {0};
        static char s_dialogueVarBuf[512] = {0};
        static char s_dialogueVisibleBuf[2048] = {0};
    }

    Dialogue* GetDialogue(int id) {
        auto it = g_dialogues.find(id);
        return it != g_dialogues.end() ? &it->second : nullptr;
    }

    DialogueNode* GetDialogueNode(int dialogueId, int nodeId) {
        auto* dlg = GetDialogue(dialogueId);
        if (!dlg) return nullptr;
        auto it = dlg->nodes.find(nodeId);
        return it != dlg->nodes.end() ? &it->second : nullptr;
    }

    // Dialogue creation and management
    int Framework_Dialogue_Create(const char* name) {
        Dialogue dlg;
        dlg.id = g_nextDialogueId++;
        dlg.name = name ? name : "";
        g_dialogues[dlg.id] = dlg;
        if (name && strlen(name) > 0) {
            g_dialogueByName[name] = dlg.id;
        }
        return dlg.id;
    }

    void Framework_Dialogue_Destroy(int dialogueId) {
        auto* dlg = GetDialogue(dialogueId);
        if (dlg) {
            if (!dlg->name.empty()) {
                g_dialogueByName.erase(dlg->name);
            }
            g_dialogues.erase(dialogueId);
            if (g_activeDialogueId == dialogueId) {
                g_activeDialogueId = -1;
                g_activeNodeId = -1;
            }
        }
    }

    int Framework_Dialogue_GetByName(const char* name) {
        if (!name) return -1;
        auto it = g_dialogueByName.find(name);
        return it != g_dialogueByName.end() ? it->second : -1;
    }

    bool Framework_Dialogue_IsValid(int dialogueId) {
        return GetDialogue(dialogueId) != nullptr;
    }

    void Framework_Dialogue_Clear(int dialogueId) {
        auto* dlg = GetDialogue(dialogueId);
        if (dlg) {
            dlg->nodes.clear();
            dlg->startNodeId = -1;
            dlg->nextNodeId = 0;
        }
    }

    // Node creation
    int Framework_Dialogue_AddNode(int dialogueId, const char* nodeTag) {
        auto* dlg = GetDialogue(dialogueId);
        if (!dlg) return -1;

        DialogueNode node;
        node.id = dlg->nextNodeId++;
        node.tag = nodeTag ? nodeTag : "";
        dlg->nodes[node.id] = node;

        if (dlg->startNodeId < 0) {
            dlg->startNodeId = node.id;
        }

        return node.id;
    }

    void Framework_Dialogue_RemoveNode(int dialogueId, int nodeId) {
        auto* dlg = GetDialogue(dialogueId);
        if (dlg) {
            dlg->nodes.erase(nodeId);
        }
    }

    int Framework_Dialogue_GetNodeByTag(int dialogueId, const char* tag) {
        auto* dlg = GetDialogue(dialogueId);
        if (!dlg || !tag) return -1;

        for (auto& kv : dlg->nodes) {
            if (kv.second.tag == tag) return kv.first;
        }
        return -1;
    }

    int Framework_Dialogue_GetNodeCount(int dialogueId) {
        auto* dlg = GetDialogue(dialogueId);
        return dlg ? (int)dlg->nodes.size() : 0;
    }

    // Node content
    void Framework_Dialogue_SetNodeSpeaker(int dialogueId, int nodeId, const char* speaker) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node) node->speaker = speaker ? speaker : "";
    }

    const char* Framework_Dialogue_GetNodeSpeaker(int dialogueId, int nodeId) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node && !node->speaker.empty()) {
            strncpy(s_dialogueSpeakerBuf, node->speaker.c_str(), sizeof(s_dialogueSpeakerBuf) - 1);
            return s_dialogueSpeakerBuf;
        }
        return "";
    }

    void Framework_Dialogue_SetNodeText(int dialogueId, int nodeId, const char* text) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node) node->text = text ? text : "";
    }

    const char* Framework_Dialogue_GetNodeText(int dialogueId, int nodeId) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node && !node->text.empty()) {
            strncpy(s_dialogueTextBuf, node->text.c_str(), sizeof(s_dialogueTextBuf) - 1);
            return s_dialogueTextBuf;
        }
        return "";
    }

    void Framework_Dialogue_SetNodePortrait(int dialogueId, int nodeId, int textureHandle) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node) node->portrait = textureHandle;
    }

    int Framework_Dialogue_GetNodePortrait(int dialogueId, int nodeId) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        return node ? node->portrait : -1;
    }

    // Node connections
    void Framework_Dialogue_SetNextNode(int dialogueId, int nodeId, int nextNodeId) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node) node->nextNodeId = nextNodeId;
    }

    int Framework_Dialogue_GetNextNode(int dialogueId, int nodeId) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        return node ? node->nextNodeId : -1;
    }

    void Framework_Dialogue_SetStartNode(int dialogueId, int nodeId) {
        auto* dlg = GetDialogue(dialogueId);
        if (dlg) dlg->startNodeId = nodeId;
    }

    int Framework_Dialogue_GetStartNode(int dialogueId) {
        auto* dlg = GetDialogue(dialogueId);
        return dlg ? dlg->startNodeId : -1;
    }

    // Choices
    int Framework_Dialogue_AddChoice(int dialogueId, int nodeId, const char* choiceText, int targetNodeId) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (!node) return -1;

        DialogueChoice choice;
        choice.text = choiceText ? choiceText : "";
        choice.targetNodeId = targetNodeId;
        node->choices.push_back(choice);
        return (int)node->choices.size() - 1;
    }

    void Framework_Dialogue_RemoveChoice(int dialogueId, int nodeId, int choiceIndex) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node && choiceIndex >= 0 && choiceIndex < (int)node->choices.size()) {
            node->choices.erase(node->choices.begin() + choiceIndex);
        }
    }

    int Framework_Dialogue_GetChoiceCount(int dialogueId, int nodeId) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        return node ? (int)node->choices.size() : 0;
    }

    const char* Framework_Dialogue_GetChoiceText(int dialogueId, int nodeId, int choiceIndex) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node && choiceIndex >= 0 && choiceIndex < (int)node->choices.size()) {
            strncpy(s_dialogueChoiceBuf, node->choices[choiceIndex].text.c_str(), sizeof(s_dialogueChoiceBuf) - 1);
            return s_dialogueChoiceBuf;
        }
        return "";
    }

    int Framework_Dialogue_GetChoiceTarget(int dialogueId, int nodeId, int choiceIndex) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node && choiceIndex >= 0 && choiceIndex < (int)node->choices.size()) {
            return node->choices[choiceIndex].targetNodeId;
        }
        return -1;
    }

    void Framework_Dialogue_SetChoiceCondition(int dialogueId, int nodeId, int choiceIndex, const char* condition) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node && choiceIndex >= 0 && choiceIndex < (int)node->choices.size()) {
            node->choices[choiceIndex].condition = condition ? condition : "";
        }
    }

    const char* Framework_Dialogue_GetChoiceCondition(int dialogueId, int nodeId, int choiceIndex) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node && choiceIndex >= 0 && choiceIndex < (int)node->choices.size()) {
            strncpy(s_dialogueChoiceBuf, node->choices[choiceIndex].condition.c_str(), sizeof(s_dialogueChoiceBuf) - 1);
            return s_dialogueChoiceBuf;
        }
        return "";
    }

    // Conditional nodes
    void Framework_Dialogue_SetNodeCondition(int dialogueId, int nodeId, const char* condition) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node) node->condition = condition ? condition : "";
    }

    const char* Framework_Dialogue_GetNodeCondition(int dialogueId, int nodeId) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node && !node->condition.empty()) {
            strncpy(s_dialogueTextBuf, node->condition.c_str(), sizeof(s_dialogueTextBuf) - 1);
            return s_dialogueTextBuf;
        }
        return "";
    }

    // Node events
    void Framework_Dialogue_SetNodeEvent(int dialogueId, int nodeId, const char* eventName) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node) node->eventName = eventName ? eventName : "";
    }

    const char* Framework_Dialogue_GetNodeEvent(int dialogueId, int nodeId) {
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node && !node->eventName.empty()) {
            strncpy(s_dialogueTextBuf, node->eventName.c_str(), sizeof(s_dialogueTextBuf) - 1);
            return s_dialogueTextBuf;
        }
        return "";
    }

    // Variables
    void Framework_Dialogue_SetVarInt(const char* varName, int value) {
        if (!varName) return;
        DialogueVar& v = g_dialogueVars[varName];
        v.type = DialogueVar::INT;
        v.intVal = value;
    }

    int Framework_Dialogue_GetVarInt(const char* varName) {
        if (!varName) return 0;
        auto it = g_dialogueVars.find(varName);
        if (it != g_dialogueVars.end() && it->second.type == DialogueVar::INT) {
            return it->second.intVal;
        }
        return 0;
    }

    void Framework_Dialogue_SetVarFloat(const char* varName, float value) {
        if (!varName) return;
        DialogueVar& v = g_dialogueVars[varName];
        v.type = DialogueVar::FLOAT;
        v.floatVal = value;
    }

    float Framework_Dialogue_GetVarFloat(const char* varName) {
        if (!varName) return 0.0f;
        auto it = g_dialogueVars.find(varName);
        if (it != g_dialogueVars.end() && it->second.type == DialogueVar::FLOAT) {
            return it->second.floatVal;
        }
        return 0.0f;
    }

    void Framework_Dialogue_SetVarBool(const char* varName, bool value) {
        if (!varName) return;
        DialogueVar& v = g_dialogueVars[varName];
        v.type = DialogueVar::BOOL;
        v.boolVal = value;
    }

    bool Framework_Dialogue_GetVarBool(const char* varName) {
        if (!varName) return false;
        auto it = g_dialogueVars.find(varName);
        if (it != g_dialogueVars.end() && it->second.type == DialogueVar::BOOL) {
            return it->second.boolVal;
        }
        return false;
    }

    void Framework_Dialogue_SetVarString(const char* varName, const char* value) {
        if (!varName) return;
        DialogueVar& v = g_dialogueVars[varName];
        v.type = DialogueVar::STRING;
        v.strVal = value ? value : "";
    }

    const char* Framework_Dialogue_GetVarString(const char* varName) {
        if (!varName) return "";
        auto it = g_dialogueVars.find(varName);
        if (it != g_dialogueVars.end() && it->second.type == DialogueVar::STRING) {
            strncpy(s_dialogueVarBuf, it->second.strVal.c_str(), sizeof(s_dialogueVarBuf) - 1);
            return s_dialogueVarBuf;
        }
        return "";
    }

    void Framework_Dialogue_ClearVar(const char* varName) {
        if (varName) g_dialogueVars.erase(varName);
    }

    void Framework_Dialogue_ClearAllVars() {
        g_dialogueVars.clear();
    }

    // Internal helper to enter a node
    void EnterDialogueNode(int dialogueId, int nodeId) {
        g_activeDialogueId = dialogueId;
        g_activeNodeId = nodeId;
        g_typewriterProgress = 0.0f;
        g_typewriterComplete = !g_typewriterEnabled;
        g_visibleText = "";

        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (node) {
            if (g_typewriterComplete) {
                g_visibleText = node->text;
            }

            // Add to history
            if (g_historyEnabled && !node->text.empty()) {
                DialogueHistoryEntry entry;
                entry.speaker = node->speaker;
                entry.text = node->text;
                g_dialogueHistory.push_back(entry);
            }

            // Trigger node enter callback
            if (g_onNodeEnter) {
                g_onNodeEnter(dialogueId, nodeId, g_nodeEnterUserData);
            }
        }
    }

    // Playback
    void Framework_Dialogue_Start(int dialogueId) {
        auto* dlg = GetDialogue(dialogueId);
        if (!dlg || dlg->startNodeId < 0) return;

        if (g_onDialogueStart) {
            g_onDialogueStart(dialogueId, dlg->startNodeId, g_dialogueStartUserData);
        }

        EnterDialogueNode(dialogueId, dlg->startNodeId);
    }

    void Framework_Dialogue_StartAtNode(int dialogueId, int nodeId) {
        auto* dlg = GetDialogue(dialogueId);
        if (!dlg) return;
        auto* node = GetDialogueNode(dialogueId, nodeId);
        if (!node) return;

        if (g_onDialogueStart) {
            g_onDialogueStart(dialogueId, nodeId, g_dialogueStartUserData);
        }

        EnterDialogueNode(dialogueId, nodeId);
    }

    void Framework_Dialogue_Stop() {
        if (g_activeDialogueId >= 0) {
            if (g_onDialogueEnd) {
                g_onDialogueEnd(g_activeDialogueId, g_activeNodeId, g_dialogueEndUserData);
            }
        }
        g_activeDialogueId = -1;
        g_activeNodeId = -1;
        g_typewriterProgress = 0.0f;
        g_typewriterComplete = false;
        g_visibleText = "";
    }

    bool Framework_Dialogue_IsActive() {
        return g_activeDialogueId >= 0;
    }

    int Framework_Dialogue_GetActiveDialogue() {
        return g_activeDialogueId;
    }

    int Framework_Dialogue_GetCurrentNode() {
        return g_activeNodeId;
    }

    bool Framework_Dialogue_Continue() {
        if (g_activeDialogueId < 0 || g_activeNodeId < 0) return false;

        auto* node = GetDialogueNode(g_activeDialogueId, g_activeNodeId);
        if (!node) return false;

        // If has choices, cannot continue automatically
        if (!node->choices.empty()) return false;

        // Trigger node exit
        if (g_onNodeExit) {
            g_onNodeExit(g_activeDialogueId, g_activeNodeId, g_nodeExitUserData);
        }

        int nextId = node->nextNodeId;
        if (nextId < 0) {
            Framework_Dialogue_Stop();
            return false;
        }

        EnterDialogueNode(g_activeDialogueId, nextId);
        return true;
    }

    bool Framework_Dialogue_SelectChoice(int choiceIndex) {
        if (g_activeDialogueId < 0 || g_activeNodeId < 0) return false;

        auto* node = GetDialogueNode(g_activeDialogueId, g_activeNodeId);
        if (!node || choiceIndex < 0 || choiceIndex >= (int)node->choices.size()) return false;

        // Check condition
        auto& choice = node->choices[choiceIndex];
        if (!choice.condition.empty() && g_conditionHandler) {
            if (!g_conditionHandler(g_activeDialogueId, choice.condition.c_str(), g_conditionUserData)) {
                return false;
            }
        }

        // Trigger choice callback
        if (g_onChoice) {
            g_onChoice(g_activeDialogueId, g_activeNodeId, choiceIndex, g_choiceUserData);
        }

        // Trigger node exit
        if (g_onNodeExit) {
            g_onNodeExit(g_activeDialogueId, g_activeNodeId, g_nodeExitUserData);
        }

        int targetId = choice.targetNodeId;
        if (targetId < 0) {
            Framework_Dialogue_Stop();
            return true;
        }

        EnterDialogueNode(g_activeDialogueId, targetId);
        return true;
    }

    // Current node queries
    const char* Framework_Dialogue_GetCurrentSpeaker() {
        auto* node = GetDialogueNode(g_activeDialogueId, g_activeNodeId);
        if (node && !node->speaker.empty()) {
            // Check if speaker is registered
            auto sit = g_speakers.find(node->speaker);
            if (sit != g_speakers.end()) {
                strncpy(s_dialogueSpeakerBuf, sit->second.displayName.c_str(), sizeof(s_dialogueSpeakerBuf) - 1);
            } else {
                strncpy(s_dialogueSpeakerBuf, node->speaker.c_str(), sizeof(s_dialogueSpeakerBuf) - 1);
            }
            return s_dialogueSpeakerBuf;
        }
        return "";
    }

    const char* Framework_Dialogue_GetCurrentText() {
        auto* node = GetDialogueNode(g_activeDialogueId, g_activeNodeId);
        if (node) {
            strncpy(s_dialogueTextBuf, node->text.c_str(), sizeof(s_dialogueTextBuf) - 1);
            return s_dialogueTextBuf;
        }
        return "";
    }

    int Framework_Dialogue_GetCurrentPortrait() {
        auto* node = GetDialogueNode(g_activeDialogueId, g_activeNodeId);
        if (node) {
            if (node->portrait >= 0) return node->portrait;
            // Check speaker default portrait
            auto sit = g_speakers.find(node->speaker);
            if (sit != g_speakers.end()) {
                return sit->second.portrait;
            }
        }
        return -1;
    }

    int Framework_Dialogue_GetCurrentChoiceCount() {
        auto* node = GetDialogueNode(g_activeDialogueId, g_activeNodeId);
        return node ? (int)node->choices.size() : 0;
    }

    const char* Framework_Dialogue_GetCurrentChoiceText(int choiceIndex) {
        auto* node = GetDialogueNode(g_activeDialogueId, g_activeNodeId);
        if (node && choiceIndex >= 0 && choiceIndex < (int)node->choices.size()) {
            strncpy(s_dialogueChoiceBuf, node->choices[choiceIndex].text.c_str(), sizeof(s_dialogueChoiceBuf) - 1);
            return s_dialogueChoiceBuf;
        }
        return "";
    }

    bool Framework_Dialogue_IsCurrentChoiceAvailable(int choiceIndex) {
        auto* node = GetDialogueNode(g_activeDialogueId, g_activeNodeId);
        if (!node || choiceIndex < 0 || choiceIndex >= (int)node->choices.size()) return false;

        auto& choice = node->choices[choiceIndex];
        if (choice.condition.empty()) return true;

        if (g_conditionHandler) {
            return g_conditionHandler(g_activeDialogueId, choice.condition.c_str(), g_conditionUserData);
        }
        return true;
    }

    // Typewriter effect
    void Framework_Dialogue_SetTypewriterEnabled(bool enabled) {
        g_typewriterEnabled = enabled;
    }

    bool Framework_Dialogue_IsTypewriterEnabled() {
        return g_typewriterEnabled;
    }

    void Framework_Dialogue_SetTypewriterSpeed(float charsPerSecond) {
        g_typewriterSpeed = charsPerSecond > 0 ? charsPerSecond : 1.0f;
    }

    float Framework_Dialogue_GetTypewriterSpeed() {
        return g_typewriterSpeed;
    }

    void Framework_Dialogue_SkipTypewriter() {
        g_typewriterComplete = true;
        auto* node = GetDialogueNode(g_activeDialogueId, g_activeNodeId);
        if (node) {
            g_visibleText = node->text;
            g_typewriterProgress = (float)node->text.length();
        }
    }

    bool Framework_Dialogue_IsTypewriterComplete() {
        return g_typewriterComplete;
    }

    const char* Framework_Dialogue_GetVisibleText() {
        strncpy(s_dialogueVisibleBuf, g_visibleText.c_str(), sizeof(s_dialogueVisibleBuf) - 1);
        return s_dialogueVisibleBuf;
    }

    int Framework_Dialogue_GetVisibleCharCount() {
        return (int)g_visibleText.length();
    }

    // Callbacks
    void Framework_Dialogue_SetOnStartCallback(DialogueCallback callback, void* userData) {
        g_onDialogueStart = callback;
        g_dialogueStartUserData = userData;
    }

    void Framework_Dialogue_SetOnEndCallback(DialogueCallback callback, void* userData) {
        g_onDialogueEnd = callback;
        g_dialogueEndUserData = userData;
    }

    void Framework_Dialogue_SetOnNodeEnterCallback(DialogueCallback callback, void* userData) {
        g_onNodeEnter = callback;
        g_nodeEnterUserData = userData;
    }

    void Framework_Dialogue_SetOnNodeExitCallback(DialogueCallback callback, void* userData) {
        g_onNodeExit = callback;
        g_nodeExitUserData = userData;
    }

    void Framework_Dialogue_SetOnChoiceCallback(DialogueChoiceCallback callback, void* userData) {
        g_onChoice = callback;
        g_choiceUserData = userData;
    }

    void Framework_Dialogue_SetConditionHandler(DialogueConditionCallback callback, void* userData) {
        g_conditionHandler = callback;
        g_conditionUserData = userData;
    }

    // Dialogue update
    void Framework_Dialogue_Update(float dt) {
        if (!g_typewriterEnabled || g_typewriterComplete) return;
        if (g_activeDialogueId < 0 || g_activeNodeId < 0) return;

        auto* node = GetDialogueNode(g_activeDialogueId, g_activeNodeId);
        if (!node) return;

        g_typewriterProgress += g_typewriterSpeed * dt;
        int charCount = (int)g_typewriterProgress;
        int textLen = (int)node->text.length();

        if (charCount >= textLen) {
            g_visibleText = node->text;
            g_typewriterComplete = true;
        } else {
            g_visibleText = node->text.substr(0, charCount);
        }
    }

    // Speaker management
    void Framework_Dialogue_RegisterSpeaker(const char* speakerId, const char* displayName, int defaultPortrait) {
        if (!speakerId) return;
        Speaker spk;
        spk.id = speakerId;
        spk.displayName = displayName ? displayName : speakerId;
        spk.portrait = defaultPortrait;
        g_speakers[speakerId] = spk;
    }

    void Framework_Dialogue_UnregisterSpeaker(const char* speakerId) {
        if (speakerId) g_speakers.erase(speakerId);
    }

    const char* Framework_Dialogue_GetSpeakerDisplayName(const char* speakerId) {
        if (!speakerId) return "";
        auto it = g_speakers.find(speakerId);
        if (it != g_speakers.end()) {
            strncpy(s_dialogueSpeakerBuf, it->second.displayName.c_str(), sizeof(s_dialogueSpeakerBuf) - 1);
            return s_dialogueSpeakerBuf;
        }
        return "";
    }

    int Framework_Dialogue_GetSpeakerPortrait(const char* speakerId) {
        if (!speakerId) return -1;
        auto it = g_speakers.find(speakerId);
        return it != g_speakers.end() ? it->second.portrait : -1;
    }

    void Framework_Dialogue_SetSpeakerPortrait(const char* speakerId, int textureHandle) {
        if (!speakerId) return;
        auto it = g_speakers.find(speakerId);
        if (it != g_speakers.end()) {
            it->second.portrait = textureHandle;
        }
    }

    // History
    void Framework_Dialogue_SetHistoryEnabled(bool enabled) {
        g_historyEnabled = enabled;
    }

    bool Framework_Dialogue_IsHistoryEnabled() {
        return g_historyEnabled;
    }

    int Framework_Dialogue_GetHistoryCount() {
        return (int)g_dialogueHistory.size();
    }

    const char* Framework_Dialogue_GetHistorySpeaker(int index) {
        if (index >= 0 && index < (int)g_dialogueHistory.size()) {
            strncpy(s_dialogueSpeakerBuf, g_dialogueHistory[index].speaker.c_str(), sizeof(s_dialogueSpeakerBuf) - 1);
            return s_dialogueSpeakerBuf;
        }
        return "";
    }

    const char* Framework_Dialogue_GetHistoryText(int index) {
        if (index >= 0 && index < (int)g_dialogueHistory.size()) {
            strncpy(s_dialogueTextBuf, g_dialogueHistory[index].text.c_str(), sizeof(s_dialogueTextBuf) - 1);
            return s_dialogueTextBuf;
        }
        return "";
    }

    void Framework_Dialogue_ClearHistory() {
        g_dialogueHistory.clear();
    }

    // Save/Load
    bool Framework_Dialogue_SaveToFile(int dialogueId, const char* filename) {
        auto* dlg = GetDialogue(dialogueId);
        if (!dlg || !filename) return false;

        std::ofstream file(filename);
        if (!file.is_open()) return false;

        file << "DIALOGUE " << dlg->name << "\n";
        file << "START " << dlg->startNodeId << "\n";

        for (auto& kv : dlg->nodes) {
            auto& node = kv.second;
            file << "NODE " << node.id << " " << node.tag << "\n";
            file << "SPEAKER " << node.speaker << "\n";
            file << "TEXT " << node.text << "\n";
            file << "NEXT " << node.nextNodeId << "\n";
            file << "PORTRAIT " << node.portrait << "\n";

            for (auto& choice : node.choices) {
                file << "CHOICE " << choice.targetNodeId << " " << choice.text << "\n";
            }
            file << "ENDNODE\n";
        }

        file << "ENDDIALOGUE\n";
        return true;
    }

    int Framework_Dialogue_LoadFromFile(const char* filename) {
        // Simple load - a full implementation would parse the file properly
        // For now just return -1 as placeholder
        return -1;
    }

    // Global management
    void Framework_Dialogue_DestroyAll() {
        g_dialogues.clear();
        g_dialogueByName.clear();
        g_activeDialogueId = -1;
        g_activeNodeId = -1;
    }

    int Framework_Dialogue_GetCount() {
        return (int)g_dialogues.size();
    }

    // ========================================================================
    // INVENTORY SYSTEM
    // ========================================================================

    // Item definition structure
    struct ItemDefinition {
        int id = 0;
        std::string name;         // Internal name
        std::string displayName;  // Display name
        std::string description;
        int iconTexture = -1;
        Rectangle iconRect = { 0, 0, 0, 0 };
        bool stackable = true;
        int maxStack = 99;
        std::string category;
        int rarity = ITEM_RARITY_COMMON;
        int equipSlot = EQUIP_SLOT_NONE;
        std::unordered_map<std::string, int> statsInt;
        std::unordered_map<std::string, float> statsFloat;
        int value = 0;
        float weight = 0.0f;
        bool usable = false;
        bool consumable = false;
    };

    // Inventory slot
    struct InventorySlot {
        int itemDefId = -1;
        int quantity = 0;
    };

    // Inventory container
    struct Inventory {
        int id = 0;
        std::string name;
        int slotCount = 20;
        float maxWeight = 0.0f; // 0 = unlimited
        bool autoStack = true;  // Auto-stack items when adding
        std::vector<InventorySlot> slots;

        // Callbacks
        InventoryCallback onAddCallback = nullptr;
        InventoryCallback onRemoveCallback = nullptr;
        InventoryCallback onChangeCallback = nullptr;
        ItemUseCallback onUseCallback = nullptr;
        ItemDropCallback onDropCallback = nullptr;
        void* addUserData = nullptr;
        void* removeUserData = nullptr;
        void* changeUserData = nullptr;
        void* useUserData = nullptr;
        void* dropUserData = nullptr;
    };

    // Equipment
    struct Equipment {
        int id = 0;
        std::string name;
        std::unordered_map<int, int> slots; // slot -> itemDefId
    };

    // Loot entry
    struct LootEntry {
        int itemDefId = 0;
        float weight = 1.0f;
        int minQuantity = 1;
        int maxQuantity = 1;
    };

    // Loot table
    struct LootTable {
        int id = 0;
        std::string name;
        std::vector<LootEntry> entries;
    };

    // Global state
    static std::unordered_map<int, ItemDefinition> g_itemDefs;
    static std::unordered_map<std::string, int> g_itemDefByName;
    static int g_nextItemDefId = 1;

    static std::unordered_map<int, Inventory> g_inventories;
    static std::unordered_map<std::string, int> g_inventoryByName;
    static int g_nextInventoryId = 1;

    static std::unordered_map<int, Equipment> g_equipments;
    static std::unordered_map<std::string, int> g_equipmentByName;
    static int g_nextEquipmentId = 1;

    static std::unordered_map<int, LootTable> g_lootTables;
    static std::unordered_map<std::string, int> g_lootTableByName;
    static int g_nextLootTableId = 1;

    // String buffers
    static char s_itemNameBuf[256];
    static char s_itemDescBuf[1024];
    static char s_categoryBuf[256];

    // Helpers
    static ItemDefinition* GetItemDef(int id) {
        auto it = g_itemDefs.find(id);
        return (it != g_itemDefs.end()) ? &it->second : nullptr;
    }

    static Inventory* GetInventory(int id) {
        auto it = g_inventories.find(id);
        return (it != g_inventories.end()) ? &it->second : nullptr;
    }

    static Equipment* GetEquipment(int id) {
        auto it = g_equipments.find(id);
        return (it != g_equipments.end()) ? &it->second : nullptr;
    }

    static LootTable* GetLootTable(int id) {
        auto it = g_lootTables.find(id);
        return (it != g_lootTables.end()) ? &it->second : nullptr;
    }

    static float GetInventoryWeight(Inventory* inv) {
        if (!inv) return 0.0f;
        float weight = 0.0f;
        for (auto& slot : inv->slots) {
            if (slot.itemDefId >= 0) {
                auto* item = GetItemDef(slot.itemDefId);
                if (item) weight += item->weight * slot.quantity;
            }
        }
        return weight;
    }

    // ---- Item Definition API ----

    int Framework_Item_Define(const char* itemName, const char* description) {
        ItemDefinition item;
        item.id = g_nextItemDefId++;
        item.name = itemName ? itemName : "";
        item.displayName = item.name;
        item.description = description ? description : "";

        g_itemDefs[item.id] = item;
        if (itemName) g_itemDefByName[itemName] = item.id;

        return item.id;
    }

    void Framework_Item_Undefine(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        if (!item) return;
        g_itemDefByName.erase(item->name);
        g_itemDefs.erase(itemDefId);
    }

    int Framework_Item_GetDefByName(const char* itemName) {
        if (!itemName) return -1;
        auto it = g_itemDefByName.find(itemName);
        return (it != g_itemDefByName.end()) ? it->second : -1;
    }

    bool Framework_Item_IsDefValid(int itemDefId) {
        return GetItemDef(itemDefId) != nullptr;
    }

    const char* Framework_Item_GetName(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        if (!item) return "";
        strncpy(s_itemNameBuf, item->name.c_str(), sizeof(s_itemNameBuf) - 1);
        s_itemNameBuf[sizeof(s_itemNameBuf) - 1] = '\0';
        return s_itemNameBuf;
    }

    void Framework_Item_SetDisplayName(int itemDefId, const char* displayName) {
        auto* item = GetItemDef(itemDefId);
        if (item && displayName) item->displayName = displayName;
    }

    const char* Framework_Item_GetDisplayName(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        if (!item) return "";
        strncpy(s_itemNameBuf, item->displayName.c_str(), sizeof(s_itemNameBuf) - 1);
        s_itemNameBuf[sizeof(s_itemNameBuf) - 1] = '\0';
        return s_itemNameBuf;
    }

    void Framework_Item_SetDescription(int itemDefId, const char* description) {
        auto* item = GetItemDef(itemDefId);
        if (item && description) item->description = description;
    }

    const char* Framework_Item_GetDescription(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        if (!item) return "";
        strncpy(s_itemDescBuf, item->description.c_str(), sizeof(s_itemDescBuf) - 1);
        s_itemDescBuf[sizeof(s_itemDescBuf) - 1] = '\0';
        return s_itemDescBuf;
    }

    void Framework_Item_SetIcon(int itemDefId, int textureHandle) {
        auto* item = GetItemDef(itemDefId);
        if (item) item->iconTexture = textureHandle;
    }

    int Framework_Item_GetIcon(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        return item ? item->iconTexture : -1;
    }

    void Framework_Item_SetIconRect(int itemDefId, float x, float y, float w, float h) {
        auto* item = GetItemDef(itemDefId);
        if (item) item->iconRect = { x, y, w, h };
    }

    void Framework_Item_SetStackable(int itemDefId, bool stackable, int maxStack) {
        auto* item = GetItemDef(itemDefId);
        if (item) {
            item->stackable = stackable;
            item->maxStack = maxStack;
        }
    }

    bool Framework_Item_IsStackable(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        return item ? item->stackable : false;
    }

    void Framework_Item_SetMaxStack(int itemDefId, int maxStack) {
        auto* item = GetItemDef(itemDefId);
        if (item) item->maxStack = maxStack;
    }

    int Framework_Item_GetMaxStack(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        return item ? item->maxStack : 1;
    }

    void Framework_Item_SetCategory(int itemDefId, const char* category) {
        auto* item = GetItemDef(itemDefId);
        if (item && category) item->category = category;
    }

    const char* Framework_Item_GetCategory(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        if (!item) return "";
        strncpy(s_categoryBuf, item->category.c_str(), sizeof(s_categoryBuf) - 1);
        s_categoryBuf[sizeof(s_categoryBuf) - 1] = '\0';
        return s_categoryBuf;
    }

    void Framework_Item_SetRarity(int itemDefId, int rarity) {
        auto* item = GetItemDef(itemDefId);
        if (item) item->rarity = rarity;
    }

    int Framework_Item_GetRarity(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        return item ? item->rarity : ITEM_RARITY_COMMON;
    }

    void Framework_Item_SetEquipSlot(int itemDefId, int equipSlot) {
        auto* item = GetItemDef(itemDefId);
        if (item) item->equipSlot = equipSlot;
    }

    int Framework_Item_GetEquipSlot(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        return item ? item->equipSlot : EQUIP_SLOT_NONE;
    }

    void Framework_Item_SetUsable(int itemDefId, bool usable) {
        auto* item = GetItemDef(itemDefId);
        if (item) item->usable = usable;
    }

    bool Framework_Item_IsUsable(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        return item ? item->usable : false;
    }

    void Framework_Item_SetConsumable(int itemDefId, bool consumable) {
        auto* item = GetItemDef(itemDefId);
        if (item) item->consumable = consumable;
    }

    bool Framework_Item_IsConsumable(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        return item ? item->consumable : false;
    }

    void Framework_Item_SetStatInt(int itemDefId, const char* statName, int value) {
        auto* item = GetItemDef(itemDefId);
        if (item && statName) item->statsInt[statName] = value;
    }

    int Framework_Item_GetStatInt(int itemDefId, const char* statName) {
        auto* item = GetItemDef(itemDefId);
        if (!item || !statName) return 0;
        auto it = item->statsInt.find(statName);
        return (it != item->statsInt.end()) ? it->second : 0;
    }

    void Framework_Item_SetStatFloat(int itemDefId, const char* statName, float value) {
        auto* item = GetItemDef(itemDefId);
        if (item && statName) item->statsFloat[statName] = value;
    }

    float Framework_Item_GetStatFloat(int itemDefId, const char* statName) {
        auto* item = GetItemDef(itemDefId);
        if (!item || !statName) return 0.0f;
        auto it = item->statsFloat.find(statName);
        return (it != item->statsFloat.end()) ? it->second : 0.0f;
    }

    void Framework_Item_SetValue(int itemDefId, int value) {
        auto* item = GetItemDef(itemDefId);
        if (item) item->value = value;
    }

    int Framework_Item_GetValue(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        return item ? item->value : 0;
    }

    void Framework_Item_SetWeight(int itemDefId, float weight) {
        auto* item = GetItemDef(itemDefId);
        if (item) item->weight = weight;
    }

    float Framework_Item_GetWeight(int itemDefId) {
        auto* item = GetItemDef(itemDefId);
        return item ? item->weight : 0.0f;
    }

    // ---- Inventory Container API ----

    int Framework_Inventory_Create(const char* name, int slotCount) {
        Inventory inv;
        inv.id = g_nextInventoryId++;
        inv.name = name ? name : "";
        inv.slotCount = slotCount > 0 ? slotCount : 20;
        inv.slots.resize(inv.slotCount);

        g_inventories[inv.id] = inv;
        if (name) g_inventoryByName[name] = inv.id;

        return inv.id;
    }

    void Framework_Inventory_Destroy(int inventoryId) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return;
        g_inventoryByName.erase(inv->name);
        g_inventories.erase(inventoryId);
    }

    int Framework_Inventory_GetByName(const char* name) {
        if (!name) return -1;
        auto it = g_inventoryByName.find(name);
        return (it != g_inventoryByName.end()) ? it->second : -1;
    }

    bool Framework_Inventory_IsValid(int inventoryId) {
        return GetInventory(inventoryId) != nullptr;
    }

    void Framework_Inventory_SetSlotCount(int inventoryId, int slotCount) {
        auto* inv = GetInventory(inventoryId);
        if (!inv || slotCount <= 0) return;
        inv->slotCount = slotCount;
        inv->slots.resize(slotCount);
    }

    int Framework_Inventory_GetSlotCount(int inventoryId) {
        auto* inv = GetInventory(inventoryId);
        return inv ? inv->slotCount : 0;
    }

    void Framework_Inventory_SetMaxWeight(int inventoryId, float maxWeight) {
        auto* inv = GetInventory(inventoryId);
        if (inv) inv->maxWeight = maxWeight;
    }

    float Framework_Inventory_GetMaxWeight(int inventoryId) {
        auto* inv = GetInventory(inventoryId);
        return inv ? inv->maxWeight : 0.0f;
    }

    float Framework_Inventory_GetCurrentWeight(int inventoryId) {
        auto* inv = GetInventory(inventoryId);
        return inv ? GetInventoryWeight(inv) : 0.0f;
    }

    bool Framework_Inventory_IsWeightLimited(int inventoryId) {
        auto* inv = GetInventory(inventoryId);
        return inv ? (inv->maxWeight > 0.0f) : false;
    }

    int Framework_Inventory_GetCapacity(int inventoryId) {
        return Framework_Inventory_GetSlotCount(inventoryId);
    }

    void Framework_Inventory_SetAutoStack(int inventoryId, bool autoStack) {
        auto* inv = GetInventory(inventoryId);
        if (inv) inv->autoStack = autoStack;
    }

    bool Framework_Inventory_GetAutoStack(int inventoryId) {
        auto* inv = GetInventory(inventoryId);
        return inv ? inv->autoStack : true;
    }

    // Adding items
    bool Framework_Inventory_AddItem(int inventoryId, int itemDefId, int quantity) {
        auto* inv = GetInventory(inventoryId);
        auto* item = GetItemDef(itemDefId);
        if (!inv || !item || quantity <= 0) return false;

        int remaining = quantity;

        // Try to stack with existing items first
        if (item->stackable) {
            for (int i = 0; i < inv->slotCount && remaining > 0; i++) {
                auto& slot = inv->slots[i];
                if (slot.itemDefId == itemDefId) {
                    int spaceInSlot = item->maxStack - slot.quantity;
                    int toAdd = (remaining < spaceInSlot) ? remaining : spaceInSlot;
                    if (toAdd > 0) {
                        slot.quantity += toAdd;
                        remaining -= toAdd;
                        if (inv->onChangeCallback) {
                            inv->onChangeCallback(inventoryId, i, itemDefId, inv->changeUserData);
                        }
                    }
                }
            }
        }

        // Add to empty slots
        for (int i = 0; i < inv->slotCount && remaining > 0; i++) {
            auto& slot = inv->slots[i];
            if (slot.itemDefId < 0) {
                int toAdd = item->stackable ? ((remaining < item->maxStack) ? remaining : item->maxStack) : 1;
                slot.itemDefId = itemDefId;
                slot.quantity = toAdd;
                remaining -= toAdd;

                if (inv->onAddCallback) {
                    inv->onAddCallback(inventoryId, i, itemDefId, inv->addUserData);
                }
            }
        }

        return remaining == 0;
    }

    bool Framework_Inventory_AddItemToSlot(int inventoryId, int slotIndex, int itemDefId, int quantity) {
        auto* inv = GetInventory(inventoryId);
        auto* item = GetItemDef(itemDefId);
        if (!inv || !item || quantity <= 0) return false;
        if (slotIndex < 0 || slotIndex >= inv->slotCount) return false;

        auto& slot = inv->slots[slotIndex];
        if (slot.itemDefId >= 0 && slot.itemDefId != itemDefId) return false;

        int currentQty = (slot.itemDefId == itemDefId) ? slot.quantity : 0;
        int maxAdd = item->stackable ? (item->maxStack - currentQty) : (currentQty == 0 ? 1 : 0);
        if (quantity > maxAdd) return false;

        bool wasEmpty = slot.itemDefId < 0;
        slot.itemDefId = itemDefId;
        slot.quantity += quantity;

        if (wasEmpty && inv->onAddCallback) {
            inv->onAddCallback(inventoryId, slotIndex, itemDefId, inv->addUserData);
        } else if (inv->onChangeCallback) {
            inv->onChangeCallback(inventoryId, slotIndex, itemDefId, inv->changeUserData);
        }

        return true;
    }

    int Framework_Inventory_AddItemGetRemaining(int inventoryId, int itemDefId, int quantity) {
        auto* inv = GetInventory(inventoryId);
        auto* item = GetItemDef(itemDefId);
        if (!inv || !item || quantity <= 0) return quantity;

        int remaining = quantity;

        if (item->stackable) {
            for (int i = 0; i < inv->slotCount && remaining > 0; i++) {
                auto& slot = inv->slots[i];
                if (slot.itemDefId == itemDefId) {
                    int spaceInSlot = item->maxStack - slot.quantity;
                    int toAdd = (remaining < spaceInSlot) ? remaining : spaceInSlot;
                    if (toAdd > 0) {
                        slot.quantity += toAdd;
                        remaining -= toAdd;
                    }
                }
            }
        }

        for (int i = 0; i < inv->slotCount && remaining > 0; i++) {
            auto& slot = inv->slots[i];
            if (slot.itemDefId < 0) {
                int toAdd = item->stackable ? ((remaining < item->maxStack) ? remaining : item->maxStack) : 1;
                slot.itemDefId = itemDefId;
                slot.quantity = toAdd;
                remaining -= toAdd;
            }
        }

        return remaining;
    }

    // Removing items
    bool Framework_Inventory_RemoveItem(int inventoryId, int itemDefId, int quantity) {
        auto* inv = GetInventory(inventoryId);
        if (!inv || quantity <= 0) return false;

        int total = Framework_Inventory_CountItem(inventoryId, itemDefId);
        if (total < quantity) return false;

        int remaining = quantity;
        for (int i = inv->slotCount - 1; i >= 0 && remaining > 0; i--) {
            auto& slot = inv->slots[i];
            if (slot.itemDefId == itemDefId) {
                int toRemove = (remaining < slot.quantity) ? remaining : slot.quantity;
                slot.quantity -= toRemove;
                remaining -= toRemove;

                if (slot.quantity <= 0) {
                    int oldId = slot.itemDefId;
                    slot.itemDefId = -1;
                    slot.quantity = 0;
                    if (inv->onRemoveCallback) {
                        inv->onRemoveCallback(inventoryId, i, oldId, inv->removeUserData);
                    }
                }
            }
        }

        return true;
    }

    bool Framework_Inventory_RemoveItemFromSlot(int inventoryId, int slotIndex, int quantity) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return false;
        if (slotIndex < 0 || slotIndex >= inv->slotCount) return false;

        auto& slot = inv->slots[slotIndex];
        if (slot.itemDefId < 0 || slot.quantity < quantity) return false;

        slot.quantity -= quantity;
        if (slot.quantity <= 0) {
            int oldId = slot.itemDefId;
            slot.itemDefId = -1;
            slot.quantity = 0;
            if (inv->onRemoveCallback) {
                inv->onRemoveCallback(inventoryId, slotIndex, oldId, inv->removeUserData);
            }
        }

        return true;
    }

    int Framework_Inventory_RemoveFromSlot(int inventoryId, int slotIndex, int quantity) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return 0;
        if (slotIndex < 0 || slotIndex >= inv->slotCount) return 0;

        auto& slot = inv->slots[slotIndex];
        if (slot.itemDefId < 0) return 0;

        int removed = (slot.quantity < quantity) ? slot.quantity : quantity;
        slot.quantity -= removed;

        if (slot.quantity <= 0) {
            int oldId = slot.itemDefId;
            slot.itemDefId = -1;
            slot.quantity = 0;
            if (inv->onRemoveCallback) {
                inv->onRemoveCallback(inventoryId, slotIndex, oldId, inv->removeUserData);
            }
        }

        return removed;
    }

    void Framework_Inventory_ClearSlot(int inventoryId, int slotIndex) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return;
        if (slotIndex < 0 || slotIndex >= inv->slotCount) return;

        auto& slot = inv->slots[slotIndex];
        if (slot.itemDefId >= 0) {
            int oldId = slot.itemDefId;
            slot.itemDefId = -1;
            slot.quantity = 0;
            if (inv->onRemoveCallback) {
                inv->onRemoveCallback(inventoryId, slotIndex, oldId, inv->removeUserData);
            }
        }
    }

    void Framework_Inventory_Clear(int inventoryId) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return;

        for (int i = 0; i < inv->slotCount; i++) {
            auto& slot = inv->slots[i];
            if (slot.itemDefId >= 0) {
                int oldId = slot.itemDefId;
                slot.itemDefId = -1;
                slot.quantity = 0;
                if (inv->onRemoveCallback) {
                    inv->onRemoveCallback(inventoryId, i, oldId, inv->removeUserData);
                }
            }
        }
    }

    // Slot queries
    int Framework_Inventory_GetItemAt(int inventoryId, int slotIndex) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return -1;
        if (slotIndex < 0 || slotIndex >= inv->slotCount) return -1;
        return inv->slots[slotIndex].itemDefId;
    }

    int Framework_Inventory_GetSlotItem(int inventoryId, int slotIndex) {
        return Framework_Inventory_GetItemAt(inventoryId, slotIndex);
    }

    int Framework_Inventory_GetQuantityAt(int inventoryId, int slotIndex) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return 0;
        if (slotIndex < 0 || slotIndex >= inv->slotCount) return 0;
        return inv->slots[slotIndex].quantity;
    }

    int Framework_Inventory_GetSlotQuantity(int inventoryId, int slotIndex) {
        return Framework_Inventory_GetQuantityAt(inventoryId, slotIndex);
    }

    bool Framework_Inventory_IsSlotEmpty(int inventoryId, int slotIndex) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return true;
        if (slotIndex < 0 || slotIndex >= inv->slotCount) return true;
        return inv->slots[slotIndex].itemDefId < 0;
    }

    int Framework_Inventory_GetFirstEmptySlot(int inventoryId) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return -1;
        for (int i = 0; i < inv->slotCount; i++) {
            if (inv->slots[i].itemDefId < 0) return i;
        }
        return -1;
    }

    int Framework_Inventory_GetEmptySlotCount(int inventoryId) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return 0;

        int count = 0;
        for (auto& slot : inv->slots) {
            if (slot.itemDefId < 0) count++;
        }
        return count;
    }

    int Framework_Inventory_GetUsedSlotCount(int inventoryId) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return 0;

        int count = 0;
        for (auto& slot : inv->slots) {
            if (slot.itemDefId >= 0) count++;
        }
        return count;
    }

    // Item queries
    bool Framework_Inventory_HasItem(int inventoryId, int itemDefId) {
        return Framework_Inventory_FindItem(inventoryId, itemDefId) >= 0;
    }

    int Framework_Inventory_CountItem(int inventoryId, int itemDefId) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return 0;

        int count = 0;
        for (auto& slot : inv->slots) {
            if (slot.itemDefId == itemDefId) {
                count += slot.quantity;
            }
        }
        return count;
    }

    int Framework_Inventory_FindItem(int inventoryId, int itemDefId) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return -1;

        for (int i = 0; i < inv->slotCount; i++) {
            if (inv->slots[i].itemDefId == itemDefId) {
                return i;
            }
        }
        return -1;
    }

    int Framework_Inventory_FindItemByCategory(int inventoryId, const char* category) {
        auto* inv = GetInventory(inventoryId);
        if (!inv || !category) return -1;

        for (int i = 0; i < inv->slotCount; i++) {
            auto* item = GetItemDef(inv->slots[i].itemDefId);
            if (item && item->category == category) {
                return i;
            }
        }
        return -1;
    }

    // Moving/swapping items
    bool Framework_Inventory_MoveItem(int inventoryId, int fromSlot, int toSlot) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return false;
        if (fromSlot < 0 || fromSlot >= inv->slotCount) return false;
        if (toSlot < 0 || toSlot >= inv->slotCount) return false;
        if (fromSlot == toSlot) return true;

        auto& from = inv->slots[fromSlot];
        auto& to = inv->slots[toSlot];

        if (from.itemDefId < 0) return false;
        if (to.itemDefId >= 0) return false;

        to = from;
        from.itemDefId = -1;
        from.quantity = 0;
        return true;
    }

    bool Framework_Inventory_SwapSlots(int inventoryId, int slotA, int slotB) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return false;
        if (slotA < 0 || slotA >= inv->slotCount) return false;
        if (slotB < 0 || slotB >= inv->slotCount) return false;
        if (slotA == slotB) return true;

        std::swap(inv->slots[slotA], inv->slots[slotB]);
        return true;
    }

    bool Framework_Inventory_TransferItem(int fromInvId, int fromSlot, int toInvId, int toSlot, int quantity) {
        auto* fromInv = GetInventory(fromInvId);
        auto* toInv = GetInventory(toInvId);
        if (!fromInv || !toInv) return false;
        if (fromSlot < 0 || fromSlot >= fromInv->slotCount) return false;
        if (toSlot < 0 || toSlot >= toInv->slotCount) return false;

        auto& from = fromInv->slots[fromSlot];
        if (from.itemDefId < 0 || from.quantity < quantity) return false;

        if (!Framework_Inventory_AddItemToSlot(toInvId, toSlot, from.itemDefId, quantity)) {
            return false;
        }

        Framework_Inventory_RemoveItemFromSlot(fromInvId, fromSlot, quantity);
        return true;
    }

    bool Framework_Inventory_SplitStack(int inventoryId, int slotIndex, int quantity, int targetSlot) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return false;
        if (slotIndex < 0 || slotIndex >= inv->slotCount) return false;
        if (targetSlot < 0 || targetSlot >= inv->slotCount) return false;
        if (slotIndex == targetSlot) return false;

        auto& from = inv->slots[slotIndex];
        auto& to = inv->slots[targetSlot];

        if (from.itemDefId < 0 || from.quantity <= quantity) return false;
        if (to.itemDefId >= 0) return false;

        to.itemDefId = from.itemDefId;
        to.quantity = quantity;
        from.quantity -= quantity;
        return true;
    }

    // Sorting
    void Framework_Inventory_Sort(int inventoryId, int sortMode) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return;

        // Collect non-empty slots
        std::vector<InventorySlot> items;
        for (auto& slot : inv->slots) {
            if (slot.itemDefId >= 0) {
                items.push_back(slot);
            }
        }

        // Sort based on mode: 0=name, 1=rarity, 2=value, 3=weight
        std::sort(items.begin(), items.end(), [sortMode](const InventorySlot& a, const InventorySlot& b) {
            auto* itemA = GetItemDef(a.itemDefId);
            auto* itemB = GetItemDef(b.itemDefId);
            if (!itemA || !itemB) return false;

            switch (sortMode) {
                case 1: // Rarity (descending)
                    return itemA->rarity > itemB->rarity;
                case 2: // Value (descending)
                    return itemA->value > itemB->value;
                case 3: // Weight (ascending)
                    return itemA->weight < itemB->weight;
                default: // 0 = Name/Category
                    if (itemA->category != itemB->category) return itemA->category < itemB->category;
                    return itemA->name < itemB->name;
            }
        });

        // Clear slots and refill
        int itemIdx = 0;
        for (auto& slot : inv->slots) {
            if (itemIdx < (int)items.size()) {
                slot = items[itemIdx++];
            } else {
                slot.itemDefId = -1;
                slot.quantity = 0;
            }
        }
    }

    void Framework_Inventory_SortByRarity(int inventoryId) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return;

        std::vector<InventorySlot> items;
        for (auto& slot : inv->slots) {
            if (slot.itemDefId >= 0) {
                items.push_back(slot);
            }
        }

        std::sort(items.begin(), items.end(), [](const InventorySlot& a, const InventorySlot& b) {
            auto* itemA = GetItemDef(a.itemDefId);
            auto* itemB = GetItemDef(b.itemDefId);
            if (!itemA || !itemB) return false;
            return itemA->rarity > itemB->rarity;
        });

        int itemIdx = 0;
        for (auto& slot : inv->slots) {
            if (itemIdx < (int)items.size()) {
                slot = items[itemIdx++];
            } else {
                slot.itemDefId = -1;
                slot.quantity = 0;
            }
        }
    }

    void Framework_Inventory_Compact(int inventoryId) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return;

        std::vector<InventorySlot> items;
        for (auto& slot : inv->slots) {
            if (slot.itemDefId >= 0) {
                items.push_back(slot);
            }
        }

        int itemIdx = 0;
        for (auto& slot : inv->slots) {
            if (itemIdx < (int)items.size()) {
                slot = items[itemIdx++];
            } else {
                slot.itemDefId = -1;
                slot.quantity = 0;
            }
        }
    }

    // Using items
    bool Framework_Inventory_UseItem(int inventoryId, int slotIndex) {
        auto* inv = GetInventory(inventoryId);
        if (!inv) return false;
        if (slotIndex < 0 || slotIndex >= inv->slotCount) return false;

        auto& slot = inv->slots[slotIndex];
        if (slot.itemDefId < 0) return false;

        auto* item = GetItemDef(slot.itemDefId);
        if (!item || !item->usable) return false;

        if (inv->onUseCallback) {
            inv->onUseCallback(inventoryId, slotIndex, slot.itemDefId, slot.quantity, inv->useUserData);
        }

        if (item->consumable) {
            Framework_Inventory_RemoveItemFromSlot(inventoryId, slotIndex, 1);
        }

        return true;
    }

    void Framework_Inventory_SetUseCallback(int inventoryId, ItemUseCallback callback, void* userData) {
        auto* inv = GetInventory(inventoryId);
        if (inv) {
            inv->onUseCallback = callback;
            inv->useUserData = userData;
        }
    }

    // ---- Equipment System ----

    int Framework_Equipment_Create(const char* name) {
        Equipment equip;
        equip.id = g_nextEquipmentId++;
        equip.name = name ? name : "";

        g_equipments[equip.id] = equip;
        if (name) g_equipmentByName[name] = equip.id;

        return equip.id;
    }

    void Framework_Equipment_Destroy(int equipId) {
        auto* equip = GetEquipment(equipId);
        if (!equip) return;
        g_equipmentByName.erase(equip->name);
        g_equipments.erase(equipId);
    }

    int Framework_Equipment_GetByName(const char* name) {
        if (!name) return -1;
        auto it = g_equipmentByName.find(name);
        return (it != g_equipmentByName.end()) ? it->second : -1;
    }

    bool Framework_Equipment_IsValid(int equipId) {
        return GetEquipment(equipId) != nullptr;
    }

    bool Framework_Equipment_Equip(int equipId, int itemDefId, int slot) {
        auto* equip = GetEquipment(equipId);
        auto* item = GetItemDef(itemDefId);
        if (!equip || !item) return false;

        equip->slots[slot] = itemDefId;
        return true;
    }

    bool Framework_Equipment_EquipFromInventory(int equipId, int inventoryId, int invSlot, int equipSlot) {
        auto* equip = GetEquipment(equipId);
        auto* inv = GetInventory(inventoryId);
        if (!equip || !inv) return false;
        if (invSlot < 0 || invSlot >= inv->slotCount) return false;

        auto& slot = inv->slots[invSlot];
        if (slot.itemDefId < 0) return false;

        int itemId = slot.itemDefId;
        Framework_Inventory_RemoveItemFromSlot(inventoryId, invSlot, 1);
        equip->slots[equipSlot] = itemId;
        return true;
    }

    int Framework_Equipment_Unequip(int equipId, int slot) {
        auto* equip = GetEquipment(equipId);
        if (!equip) return -1;

        auto it = equip->slots.find(slot);
        if (it == equip->slots.end() || it->second < 0) return -1;

        int itemId = it->second;
        equip->slots.erase(it);

        return itemId;
    }

    bool Framework_Equipment_UnequipToInventory(int equipId, int slot, int inventoryId) {
        auto* equip = GetEquipment(equipId);
        auto* inv = GetInventory(inventoryId);
        if (!equip || !inv) return false;

        int itemId = Framework_Equipment_Unequip(equipId, slot);
        if (itemId < 0) return false;

        return Framework_Inventory_AddItem(inventoryId, itemId, 1);
    }

    void Framework_Equipment_UnequipAll(int equipId) {
        auto* equip = GetEquipment(equipId);
        if (equip) equip->slots.clear();
    }

    int Framework_Equipment_GetItemAt(int equipId, int slot) {
        auto* equip = GetEquipment(equipId);
        if (!equip) return -1;

        auto it = equip->slots.find(slot);
        return (it != equip->slots.end()) ? it->second : -1;
    }

    bool Framework_Equipment_IsSlotEmpty(int equipId, int slot) {
        return Framework_Equipment_GetItemAt(equipId, slot) < 0;
    }

    bool Framework_Equipment_CanEquip(int equipId, int itemDefId, int slot) {
        auto* equip = GetEquipment(equipId);
        auto* item = GetItemDef(itemDefId);
        if (!equip || !item) return false;
        return item->equipSlot == slot || item->equipSlot == EQUIP_SLOT_NONE;
    }

    int Framework_Equipment_GetTotalStatInt(int equipId, const char* statName) {
        auto* equip = GetEquipment(equipId);
        if (!equip || !statName) return 0;

        int total = 0;
        for (auto& kv : equip->slots) {
            if (kv.second >= 0) {
                auto* item = GetItemDef(kv.second);
                if (item) {
                    auto it = item->statsInt.find(statName);
                    if (it != item->statsInt.end()) {
                        total += it->second;
                    }
                }
            }
        }
        return total;
    }

    float Framework_Equipment_GetTotalStatFloat(int equipId, const char* statName) {
        auto* equip = GetEquipment(equipId);
        if (!equip || !statName) return 0.0f;

        float total = 0.0f;
        for (auto& kv : equip->slots) {
            if (kv.second >= 0) {
                auto* item = GetItemDef(kv.second);
                if (item) {
                    auto it = item->statsFloat.find(statName);
                    if (it != item->statsFloat.end()) {
                        total += it->second;
                    }
                }
            }
        }
        return total;
    }

    // ---- Inventory Callbacks ----

    void Framework_Inventory_SetOnAddCallback(int inventoryId, InventoryCallback callback, void* userData) {
        auto* inv = GetInventory(inventoryId);
        if (inv) {
            inv->onAddCallback = callback;
            inv->addUserData = userData;
        }
    }

    void Framework_Inventory_SetOnRemoveCallback(int inventoryId, InventoryCallback callback, void* userData) {
        auto* inv = GetInventory(inventoryId);
        if (inv) {
            inv->onRemoveCallback = callback;
            inv->removeUserData = userData;
        }
    }

    void Framework_Inventory_SetOnChangeCallback(int inventoryId, InventoryCallback callback, void* userData) {
        auto* inv = GetInventory(inventoryId);
        if (inv) {
            inv->onChangeCallback = callback;
            inv->changeUserData = userData;
        }
    }

    void Framework_Inventory_SetDropCallback(int inventoryId, ItemDropCallback callback, void* userData) {
        auto* inv = GetInventory(inventoryId);
        if (inv) {
            inv->onDropCallback = callback;
            inv->dropUserData = userData;
        }
    }

    // ---- Loot Tables ----

    int Framework_LootTable_Create(const char* name) {
        LootTable table;
        table.id = g_nextLootTableId++;
        table.name = name ? name : "";

        g_lootTables[table.id] = table;
        if (name) g_lootTableByName[name] = table.id;

        return table.id;
    }

    void Framework_LootTable_Destroy(int tableId) {
        auto* table = GetLootTable(tableId);
        if (!table) return;
        g_lootTableByName.erase(table->name);
        g_lootTables.erase(tableId);
    }

    void Framework_LootTable_AddEntry(int tableId, int itemDefId, float weight, int minQty, int maxQty) {
        auto* table = GetLootTable(tableId);
        if (!table) return;

        LootEntry entry;
        entry.itemDefId = itemDefId;
        entry.weight = weight > 0.0f ? weight : 1.0f;
        entry.minQuantity = minQty > 0 ? minQty : 1;
        entry.maxQuantity = maxQty > minQty ? maxQty : minQty;

        table->entries.push_back(entry);
    }

    void Framework_LootTable_RemoveEntry(int tableId, int itemDefId) {
        auto* table = GetLootTable(tableId);
        if (!table) return;

        table->entries.erase(
            std::remove_if(table->entries.begin(), table->entries.end(),
                [itemDefId](const LootEntry& e) { return e.itemDefId == itemDefId; }),
            table->entries.end());
    }

    int Framework_LootTable_Roll(int tableId, int* outQuantity) {
        auto* table = GetLootTable(tableId);
        if (!table || table->entries.empty()) {
            if (outQuantity) *outQuantity = 0;
            return -1;
        }

        float totalWeight = 0.0f;
        for (auto& entry : table->entries) {
            totalWeight += entry.weight;
        }

        float roll = (float)GetRandomValue(0, 10000) / 10000.0f * totalWeight;
        float cumulative = 0.0f;

        for (auto& entry : table->entries) {
            cumulative += entry.weight;
            if (roll <= cumulative) {
                int qty = entry.minQuantity;
                if (entry.maxQuantity > entry.minQuantity) {
                    qty += GetRandomValue(0, entry.maxQuantity - entry.minQuantity);
                }
                if (outQuantity) *outQuantity = qty;
                return entry.itemDefId;
            }
        }

        if (outQuantity) *outQuantity = 0;
        return -1;
    }

    void Framework_LootTable_RollMultiple(int tableId, int rolls, int* outItems, int* outQuantities, int bufferSize) {
        if (!outItems || !outQuantities || bufferSize <= 0) return;

        for (int i = 0; i < rolls && i < bufferSize; i++) {
            outItems[i] = Framework_LootTable_Roll(tableId, &outQuantities[i]);
        }
    }

    // ---- Save/Load ----

    bool Framework_Inventory_SaveToSlot(int inventoryId, int saveSlot, const char* key) {
        // Simplified implementation - would use save system
        return true;
    }

    bool Framework_Inventory_LoadFromSlot(int inventoryId, int saveSlot, const char* key) {
        return true;
    }

    bool Framework_Equipment_SaveToSlot(int equipId, int saveSlot, const char* key) {
        return true;
    }

    bool Framework_Equipment_LoadFromSlot(int equipId, int saveSlot, const char* key) {
        return true;
    }

    // ---- Global Management ----

    void Framework_Item_UndefineAll() {
        g_itemDefs.clear();
        g_itemDefByName.clear();
    }

    void Framework_Inventory_DestroyAll() {
        g_inventories.clear();
        g_inventoryByName.clear();
    }

    void Framework_Equipment_DestroyAll() {
        g_equipments.clear();
        g_equipmentByName.clear();
    }

    void Framework_LootTable_DestroyAll() {
        g_lootTables.clear();
        g_lootTableByName.clear();
    }

    int Framework_Item_GetDefCount() {
        return (int)g_itemDefs.size();
    }

    int Framework_Inventory_GetCount() {
        return (int)g_inventories.size();
    }

    int Framework_Equipment_GetCount() {
        return (int)g_equipments.size();
    }

    // ========================================================================
    // QUEST SYSTEM
    // ========================================================================
    // Note: Quest states and objective types are defined in framework.h as macros

    struct QuestObjective {
        int type = OBJECTIVE_TYPE_CUSTOM;
        std::string description;
        int requiredCount = 1;
        int currentProgress = 0;
        std::string targetId;       // For kill, talk, interact
        float locationX = 0;        // For reach/explore
        float locationY = 0;
        float locationRadius = 50;
        bool optional = false;
        bool hidden = false;
        bool completed = false;
    };

    struct QuestReward {
        std::vector<std::pair<int, int>> items;  // itemDefId, quantity
        int experience = 0;
        std::unordered_map<int, int> currency;   // currencyType -> amount
        std::vector<std::string> unlocks;
    };

    struct Quest {
        int handle = 0;
        std::string stringId;
        std::string name;
        std::string description;
        std::string category;
        int level = 1;
        int state = QUEST_STATE_NOT_STARTED;
        bool repeatable = false;
        bool autoComplete = true;
        bool hidden = false;
        float timeLimit = 0;        // 0 = no limit
        float timeElapsed = 0;
        int minLevel = 0;
        std::vector<std::string> prerequisites;
        std::vector<QuestObjective> objectives;
        QuestReward rewards;
        bool tracked = false;
    };

    struct QuestChain {
        int handle = 0;
        std::string stringId;
        std::vector<int> questHandles;
        int currentIndex = 0;
    };

    // Quest system state
    static std::unordered_map<int, Quest> g_quests;
    static std::unordered_map<std::string, int> g_questByStringId;
    static std::unordered_map<int, QuestChain> g_questChains;
    static std::unordered_map<std::string, int> g_chainByStringId;
    static int g_nextQuestHandle = 1;
    static int g_nextChainHandle = 1;
    static int g_maxTracked = 3;
    static QuestStateCallback g_questStateCallback = nullptr;
    static ObjectiveUpdateCallback g_objectiveUpdateCallback = nullptr;

    // Static buffers for string returns
    static char g_questNameBuf[256];
    static char g_questDescBuf[1024];
    static char g_questCatBuf[128];
    static char g_questIdBuf[128];
    static char g_objDescBuf[512];

    // Helper: Check if all required objectives are complete
    static bool AreRequiredObjectivesComplete(const Quest& q) {
        for (const auto& obj : q.objectives) {
            if (!obj.optional && !obj.completed) return false;
        }
        return true;
    }

    // Helper: Update objective completion status
    static void UpdateObjectiveCompletion(Quest& q, int objIndex) {
        if (objIndex < 0 || objIndex >= (int)q.objectives.size()) return;
        auto& obj = q.objectives[objIndex];
        bool wasComplete = obj.completed;
        obj.completed = (obj.currentProgress >= obj.requiredCount);

        // Fire callback if progress changed
        if (g_objectiveUpdateCallback) {
            g_objectiveUpdateCallback(q.handle, objIndex, obj.currentProgress, obj.requiredCount);
        }

        // Check for auto-complete
        if (!wasComplete && obj.completed && q.autoComplete && q.state == QUEST_STATE_IN_PROGRESS) {
            if (AreRequiredObjectivesComplete(q)) {
                q.state = QUEST_STATE_COMPLETED;
                if (g_questStateCallback) {
                    g_questStateCallback(q.handle, QUEST_STATE_COMPLETED);
                }
            }
        }
    }

    // ---- Quest Definition ----
    int Framework_Quest_Define(const char* questId) {
        if (!questId) return -1;

        // Check if already defined
        auto it = g_questByStringId.find(questId);
        if (it != g_questByStringId.end()) {
            return it->second;
        }

        Quest q;
        q.handle = g_nextQuestHandle++;
        q.stringId = questId;
        q.name = questId;
        g_quests[q.handle] = q;
        g_questByStringId[questId] = q.handle;
        return q.handle;
    }

    void Framework_Quest_SetName(int questHandle, const char* name) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end() && name) {
            it->second.name = name;
        }
    }

    void Framework_Quest_SetDescription(int questHandle, const char* description) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end() && description) {
            it->second.description = description;
        }
    }

    void Framework_Quest_SetCategory(int questHandle, const char* category) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end() && category) {
            it->second.category = category;
        }
    }

    void Framework_Quest_SetLevel(int questHandle, int level) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end()) {
            it->second.level = level;
        }
    }

    void Framework_Quest_SetRepeatable(int questHandle, bool repeatable) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end()) {
            it->second.repeatable = repeatable;
        }
    }

    void Framework_Quest_SetAutoComplete(int questHandle, bool autoComplete) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end()) {
            it->second.autoComplete = autoComplete;
        }
    }

    void Framework_Quest_SetHidden(int questHandle, bool hidden) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end()) {
            it->second.hidden = hidden;
        }
    }

    void Framework_Quest_SetTimeLimit(int questHandle, float seconds) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end()) {
            it->second.timeLimit = seconds;
        }
    }

    // ---- Quest Prerequisites ----
    void Framework_Quest_AddPrerequisite(int questHandle, const char* requiredQuestId) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end() && requiredQuestId) {
            it->second.prerequisites.push_back(requiredQuestId);
        }
    }

    void Framework_Quest_SetMinLevel(int questHandle, int minLevel) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end()) {
            it->second.minLevel = minLevel;
        }
    }

    bool Framework_Quest_CheckPrerequisites(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return false;

        const Quest& q = it->second;
        for (const auto& prereqId : q.prerequisites) {
            auto prereqIt = g_questByStringId.find(prereqId);
            if (prereqIt == g_questByStringId.end()) return false;
            auto questIt = g_quests.find(prereqIt->second);
            if (questIt == g_quests.end()) return false;
            if (questIt->second.state != QUEST_STATE_COMPLETED) return false;
        }
        return true;
    }

    // ---- Objectives ----
    int Framework_Quest_AddObjective(int questHandle, int objectiveType, const char* description, int requiredCount) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return -1;

        QuestObjective obj;
        obj.type = objectiveType;
        obj.description = description ? description : "";
        obj.requiredCount = requiredCount > 0 ? requiredCount : 1;
        it->second.objectives.push_back(obj);
        return (int)it->second.objectives.size() - 1;
    }

    void Framework_Quest_SetObjectiveTarget(int questHandle, int objectiveIndex, const char* targetId) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return;
        if (objectiveIndex < 0 || objectiveIndex >= (int)it->second.objectives.size()) return;
        if (targetId) {
            it->second.objectives[objectiveIndex].targetId = targetId;
        }
    }

    void Framework_Quest_SetObjectiveLocation(int questHandle, int objectiveIndex, float x, float y, float radius) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return;
        if (objectiveIndex < 0 || objectiveIndex >= (int)it->second.objectives.size()) return;
        it->second.objectives[objectiveIndex].locationX = x;
        it->second.objectives[objectiveIndex].locationY = y;
        it->second.objectives[objectiveIndex].locationRadius = radius;
    }

    void Framework_Quest_SetObjectiveOptional(int questHandle, int objectiveIndex, bool optional) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return;
        if (objectiveIndex < 0 || objectiveIndex >= (int)it->second.objectives.size()) return;
        it->second.objectives[objectiveIndex].optional = optional;
    }

    void Framework_Quest_SetObjectiveHidden(int questHandle, int objectiveIndex, bool hidden) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return;
        if (objectiveIndex < 0 || objectiveIndex >= (int)it->second.objectives.size()) return;
        it->second.objectives[objectiveIndex].hidden = hidden;
    }

    int Framework_Quest_GetObjectiveCount(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return 0;
        return (int)it->second.objectives.size();
    }

    const char* Framework_Quest_GetObjectiveDescription(int questHandle, int objectiveIndex) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return "";
        if (objectiveIndex < 0 || objectiveIndex >= (int)it->second.objectives.size()) return "";
        strncpy(g_objDescBuf, it->second.objectives[objectiveIndex].description.c_str(), sizeof(g_objDescBuf) - 1);
        g_objDescBuf[sizeof(g_objDescBuf) - 1] = '\0';
        return g_objDescBuf;
    }

    int Framework_Quest_GetObjectiveType(int questHandle, int objectiveIndex) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return -1;
        if (objectiveIndex < 0 || objectiveIndex >= (int)it->second.objectives.size()) return -1;
        return it->second.objectives[objectiveIndex].type;
    }

    int Framework_Quest_GetObjectiveProgress(int questHandle, int objectiveIndex) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return 0;
        if (objectiveIndex < 0 || objectiveIndex >= (int)it->second.objectives.size()) return 0;
        return it->second.objectives[objectiveIndex].currentProgress;
    }

    int Framework_Quest_GetObjectiveRequired(int questHandle, int objectiveIndex) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return 0;
        if (objectiveIndex < 0 || objectiveIndex >= (int)it->second.objectives.size()) return 0;
        return it->second.objectives[objectiveIndex].requiredCount;
    }

    bool Framework_Quest_IsObjectiveComplete(int questHandle, int objectiveIndex) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return false;
        if (objectiveIndex < 0 || objectiveIndex >= (int)it->second.objectives.size()) return false;
        return it->second.objectives[objectiveIndex].completed;
    }

    // ---- Rewards ----
    void Framework_Quest_AddRewardItem(int questHandle, int itemDefId, int quantity) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end()) {
            it->second.rewards.items.push_back({ itemDefId, quantity });
        }
    }

    void Framework_Quest_SetRewardExperience(int questHandle, int experience) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end()) {
            it->second.rewards.experience = experience;
        }
    }

    void Framework_Quest_SetRewardCurrency(int questHandle, int currencyType, int amount) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end()) {
            it->second.rewards.currency[currencyType] = amount;
        }
    }

    void Framework_Quest_AddRewardUnlock(int questHandle, const char* unlockId) {
        auto it = g_quests.find(questHandle);
        if (it != g_quests.end() && unlockId) {
            it->second.rewards.unlocks.push_back(unlockId);
        }
    }

    // ---- Quest State Management ----
    bool Framework_Quest_Start(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return false;

        Quest& q = it->second;
        if (q.state == QUEST_STATE_IN_PROGRESS) return true;  // Already started
        if (q.state == QUEST_STATE_COMPLETED && !q.repeatable) return false;
        if (!Framework_Quest_CheckPrerequisites(questHandle)) return false;

        q.state = QUEST_STATE_IN_PROGRESS;
        q.timeElapsed = 0;

        // Reset progress for repeatable quests
        if (q.repeatable) {
            for (auto& obj : q.objectives) {
                obj.currentProgress = 0;
                obj.completed = false;
            }
        }

        if (g_questStateCallback) {
            g_questStateCallback(questHandle, QUEST_STATE_IN_PROGRESS);
        }
        return true;
    }

    bool Framework_Quest_Complete(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return false;
        if (it->second.state != QUEST_STATE_IN_PROGRESS) return false;

        it->second.state = QUEST_STATE_COMPLETED;
        it->second.tracked = false;

        if (g_questStateCallback) {
            g_questStateCallback(questHandle, QUEST_STATE_COMPLETED);
        }
        return true;
    }

    bool Framework_Quest_Fail(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return false;
        if (it->second.state != QUEST_STATE_IN_PROGRESS) return false;

        it->second.state = QUEST_STATE_FAILED;
        it->second.tracked = false;

        if (g_questStateCallback) {
            g_questStateCallback(questHandle, QUEST_STATE_FAILED);
        }
        return true;
    }

    bool Framework_Quest_Abandon(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return false;
        if (it->second.state != QUEST_STATE_IN_PROGRESS) return false;

        it->second.state = QUEST_STATE_NOT_STARTED;
        it->second.tracked = false;
        it->second.timeElapsed = 0;

        // Reset progress
        for (auto& obj : it->second.objectives) {
            obj.currentProgress = 0;
            obj.completed = false;
        }

        if (g_questStateCallback) {
            g_questStateCallback(questHandle, QUEST_STATE_NOT_STARTED);
        }
        return true;
    }

    bool Framework_Quest_Reset(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return false;

        it->second.state = QUEST_STATE_NOT_STARTED;
        it->second.tracked = false;
        it->second.timeElapsed = 0;

        for (auto& obj : it->second.objectives) {
            obj.currentProgress = 0;
            obj.completed = false;
        }
        return true;
    }

    int Framework_Quest_GetState(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return -1;
        return it->second.state;
    }

    bool Framework_Quest_IsActive(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return false;
        return it->second.state == QUEST_STATE_IN_PROGRESS;
    }

    bool Framework_Quest_IsCompleted(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return false;
        return it->second.state == QUEST_STATE_COMPLETED;
    }

    bool Framework_Quest_CanStart(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return false;

        const Quest& q = it->second;
        if (q.state == QUEST_STATE_IN_PROGRESS) return false;
        if (q.state == QUEST_STATE_COMPLETED && !q.repeatable) return false;
        return Framework_Quest_CheckPrerequisites(questHandle);
    }

    // ---- Progress Tracking ----
    void Framework_Quest_SetObjectiveProgress(int questHandle, int objectiveIndex, int progress) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return;
        if (objectiveIndex < 0 || objectiveIndex >= (int)it->second.objectives.size()) return;

        it->second.objectives[objectiveIndex].currentProgress = progress;
        UpdateObjectiveCompletion(it->second, objectiveIndex);
    }

    void Framework_Quest_AddObjectiveProgress(int questHandle, int objectiveIndex, int amount) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return;
        if (objectiveIndex < 0 || objectiveIndex >= (int)it->second.objectives.size()) return;

        it->second.objectives[objectiveIndex].currentProgress += amount;
        UpdateObjectiveCompletion(it->second, objectiveIndex);
    }

    float Framework_Quest_GetCompletionPercent(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return 0.0f;

        const Quest& q = it->second;
        if (q.objectives.empty()) return q.state == QUEST_STATE_COMPLETED ? 100.0f : 0.0f;

        int totalRequired = 0;
        int totalProgress = 0;
        for (const auto& obj : q.objectives) {
            if (!obj.optional) {
                totalRequired += obj.requiredCount;
                totalProgress += (obj.currentProgress < obj.requiredCount) ? obj.currentProgress : obj.requiredCount;
            }
        }
        if (totalRequired == 0) return 100.0f;
        return (float)totalProgress / (float)totalRequired * 100.0f;
    }

    // ---- Auto-Progress Reporting ----
    void Framework_Quest_ReportKill(const char* targetType, int count) {
        if (!targetType) return;
        std::string target = targetType;

        for (auto& kv : g_quests) {
            Quest& q = kv.second;
            if (q.state != QUEST_STATE_IN_PROGRESS) continue;

            for (int i = 0; i < (int)q.objectives.size(); i++) {
                auto& obj = q.objectives[i];
                if (obj.type == OBJECTIVE_TYPE_KILL && obj.targetId == target && !obj.completed) {
                    obj.currentProgress += count;
                    UpdateObjectiveCompletion(q, i);
                }
            }
        }
    }

    void Framework_Quest_ReportCollect(int itemDefId, int count) {
        std::string target = std::to_string(itemDefId);

        for (auto& kv : g_quests) {
            Quest& q = kv.second;
            if (q.state != QUEST_STATE_IN_PROGRESS) continue;

            for (int i = 0; i < (int)q.objectives.size(); i++) {
                auto& obj = q.objectives[i];
                if (obj.type == OBJECTIVE_TYPE_COLLECT && obj.targetId == target && !obj.completed) {
                    obj.currentProgress += count;
                    UpdateObjectiveCompletion(q, i);
                }
            }
        }
    }

    void Framework_Quest_ReportTalk(const char* npcId) {
        if (!npcId) return;
        std::string target = npcId;

        for (auto& kv : g_quests) {
            Quest& q = kv.second;
            if (q.state != QUEST_STATE_IN_PROGRESS) continue;

            for (int i = 0; i < (int)q.objectives.size(); i++) {
                auto& obj = q.objectives[i];
                if (obj.type == OBJECTIVE_TYPE_TALK && obj.targetId == target && !obj.completed) {
                    obj.currentProgress = obj.requiredCount;
                    UpdateObjectiveCompletion(q, i);
                }
            }
        }
    }

    void Framework_Quest_ReportLocation(float x, float y) {
        for (auto& kv : g_quests) {
            Quest& q = kv.second;
            if (q.state != QUEST_STATE_IN_PROGRESS) continue;

            for (int i = 0; i < (int)q.objectives.size(); i++) {
                auto& obj = q.objectives[i];
                if ((obj.type == OBJECTIVE_TYPE_REACH || obj.type == OBJECTIVE_TYPE_EXPLORE) && !obj.completed) {
                    float dx = x - obj.locationX;
                    float dy = y - obj.locationY;
                    float dist = sqrtf(dx * dx + dy * dy);
                    if (dist <= obj.locationRadius) {
                        obj.currentProgress = obj.requiredCount;
                        UpdateObjectiveCompletion(q, i);
                    }
                }
            }
        }
    }

    void Framework_Quest_ReportInteract(const char* objectId) {
        if (!objectId) return;
        std::string target = objectId;

        for (auto& kv : g_quests) {
            Quest& q = kv.second;
            if (q.state != QUEST_STATE_IN_PROGRESS) continue;

            for (int i = 0; i < (int)q.objectives.size(); i++) {
                auto& obj = q.objectives[i];
                if (obj.type == OBJECTIVE_TYPE_INTERACT && obj.targetId == target && !obj.completed) {
                    obj.currentProgress++;
                    UpdateObjectiveCompletion(q, i);
                }
            }
        }
    }

    void Framework_Quest_ReportCustom(const char* eventType, const char* eventData) {
        if (!eventType) return;
        std::string target = eventType;
        std::string data = eventData ? eventData : "";

        for (auto& kv : g_quests) {
            Quest& q = kv.second;
            if (q.state != QUEST_STATE_IN_PROGRESS) continue;

            for (int i = 0; i < (int)q.objectives.size(); i++) {
                auto& obj = q.objectives[i];
                if (obj.type == OBJECTIVE_TYPE_CUSTOM && obj.targetId == target && !obj.completed) {
                    obj.currentProgress++;
                    UpdateObjectiveCompletion(q, i);
                }
            }
        }
    }

    // ---- Quest Queries ----
    int Framework_Quest_GetByStringId(const char* questId) {
        if (!questId) return -1;
        auto it = g_questByStringId.find(questId);
        if (it == g_questByStringId.end()) return -1;
        return it->second;
    }

    const char* Framework_Quest_GetName(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return "";
        strncpy(g_questNameBuf, it->second.name.c_str(), sizeof(g_questNameBuf) - 1);
        g_questNameBuf[sizeof(g_questNameBuf) - 1] = '\0';
        return g_questNameBuf;
    }

    const char* Framework_Quest_GetDescription(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return "";
        strncpy(g_questDescBuf, it->second.description.c_str(), sizeof(g_questDescBuf) - 1);
        g_questDescBuf[sizeof(g_questDescBuf) - 1] = '\0';
        return g_questDescBuf;
    }

    const char* Framework_Quest_GetCategory(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return "";
        strncpy(g_questCatBuf, it->second.category.c_str(), sizeof(g_questCatBuf) - 1);
        g_questCatBuf[sizeof(g_questCatBuf) - 1] = '\0';
        return g_questCatBuf;
    }

    const char* Framework_Quest_GetStringId(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return "";
        strncpy(g_questIdBuf, it->second.stringId.c_str(), sizeof(g_questIdBuf) - 1);
        g_questIdBuf[sizeof(g_questIdBuf) - 1] = '\0';
        return g_questIdBuf;
    }

    int Framework_Quest_GetLevel(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return 0;
        return it->second.level;
    }

    float Framework_Quest_GetTimeRemaining(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return 0;
        if (it->second.timeLimit <= 0) return -1;  // No limit
        float remaining = it->second.timeLimit - it->second.timeElapsed;
        return remaining > 0 ? remaining : 0;
    }

    float Framework_Quest_GetTimeElapsed(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return 0;
        return it->second.timeElapsed;
    }

    // ---- Active Quest List ----
    int Framework_Quest_GetActiveCount() {
        int count = 0;
        for (const auto& kv : g_quests) {
            if (kv.second.state == QUEST_STATE_IN_PROGRESS && !kv.second.hidden) count++;
        }
        return count;
    }

    int Framework_Quest_GetActiveAt(int index) {
        int count = 0;
        for (const auto& kv : g_quests) {
            if (kv.second.state == QUEST_STATE_IN_PROGRESS && !kv.second.hidden) {
                if (count == index) return kv.first;
                count++;
            }
        }
        return -1;
    }

    int Framework_Quest_GetCompletedCount() {
        int count = 0;
        for (const auto& kv : g_quests) {
            if (kv.second.state == QUEST_STATE_COMPLETED) count++;
        }
        return count;
    }

    int Framework_Quest_GetCompletedAt(int index) {
        int count = 0;
        for (const auto& kv : g_quests) {
            if (kv.second.state == QUEST_STATE_COMPLETED) {
                if (count == index) return kv.first;
                count++;
            }
        }
        return -1;
    }

    int Framework_Quest_GetAvailableCount() {
        int count = 0;
        for (const auto& kv : g_quests) {
            if (kv.second.state == QUEST_STATE_NOT_STARTED && !kv.second.hidden) {
                if (Framework_Quest_CheckPrerequisites(kv.first)) count++;
            }
        }
        return count;
    }

    int Framework_Quest_GetAvailableAt(int index) {
        int count = 0;
        for (const auto& kv : g_quests) {
            if (kv.second.state == QUEST_STATE_NOT_STARTED && !kv.second.hidden) {
                if (Framework_Quest_CheckPrerequisites(kv.first)) {
                    if (count == index) return kv.first;
                    count++;
                }
            }
        }
        return -1;
    }

    // ---- Quest Tracking (HUD) ----
    void Framework_Quest_SetTracked(int questHandle, bool tracked) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return;

        if (tracked) {
            // Check max tracked limit
            int currentTracked = 0;
            for (const auto& kv : g_quests) {
                if (kv.second.tracked) currentTracked++;
            }
            if (currentTracked >= g_maxTracked && !it->second.tracked) {
                return;  // Can't track more
            }
        }
        it->second.tracked = tracked;
    }

    bool Framework_Quest_IsTracked(int questHandle) {
        auto it = g_quests.find(questHandle);
        if (it == g_quests.end()) return false;
        return it->second.tracked;
    }

    int Framework_Quest_GetTrackedCount() {
        int count = 0;
        for (const auto& kv : g_quests) {
            if (kv.second.tracked) count++;
        }
        return count;
    }

    int Framework_Quest_GetTrackedAt(int index) {
        int count = 0;
        for (const auto& kv : g_quests) {
            if (kv.second.tracked) {
                if (count == index) return kv.first;
                count++;
            }
        }
        return -1;
    }

    void Framework_Quest_SetMaxTracked(int maxTracked) {
        g_maxTracked = maxTracked > 0 ? maxTracked : 1;
    }

    // ---- Callbacks ----
    void Framework_Quest_SetOnStateChange(QuestStateCallback callback) {
        g_questStateCallback = callback;
    }

    void Framework_Quest_SetOnObjectiveUpdate(ObjectiveUpdateCallback callback) {
        g_objectiveUpdateCallback = callback;
    }

    // ---- Quest Chains ----
    int Framework_QuestChain_Create(const char* chainId) {
        if (!chainId) return -1;

        auto it = g_chainByStringId.find(chainId);
        if (it != g_chainByStringId.end()) {
            return it->second;
        }

        QuestChain chain;
        chain.handle = g_nextChainHandle++;
        chain.stringId = chainId;
        g_questChains[chain.handle] = chain;
        g_chainByStringId[chainId] = chain.handle;
        return chain.handle;
    }

    void Framework_QuestChain_AddQuest(int chainHandle, int questHandle) {
        auto it = g_questChains.find(chainHandle);
        if (it == g_questChains.end()) return;
        if (g_quests.find(questHandle) == g_quests.end()) return;
        it->second.questHandles.push_back(questHandle);
    }

    int Framework_QuestChain_GetCurrentQuest(int chainHandle) {
        auto it = g_questChains.find(chainHandle);
        if (it == g_questChains.end()) return -1;

        const QuestChain& chain = it->second;
        if (chain.questHandles.empty()) return -1;

        // Find first incomplete quest in chain
        for (int h : chain.questHandles) {
            auto qIt = g_quests.find(h);
            if (qIt != g_quests.end() && qIt->second.state != QUEST_STATE_COMPLETED) {
                return h;
            }
        }
        return -1;  // All complete
    }

    int Framework_QuestChain_GetProgress(int chainHandle) {
        auto it = g_questChains.find(chainHandle);
        if (it == g_questChains.end()) return 0;

        int completed = 0;
        for (int h : it->second.questHandles) {
            auto qIt = g_quests.find(h);
            if (qIt != g_quests.end() && qIt->second.state == QUEST_STATE_COMPLETED) {
                completed++;
            }
        }
        return completed;
    }

    int Framework_QuestChain_GetLength(int chainHandle) {
        auto it = g_questChains.find(chainHandle);
        if (it == g_questChains.end()) return 0;
        return (int)it->second.questHandles.size();
    }

    bool Framework_QuestChain_IsComplete(int chainHandle) {
        auto it = g_questChains.find(chainHandle);
        if (it == g_questChains.end()) return false;

        for (int h : it->second.questHandles) {
            auto qIt = g_quests.find(h);
            if (qIt == g_quests.end() || qIt->second.state != QUEST_STATE_COMPLETED) {
                return false;
            }
        }
        return !it->second.questHandles.empty();
    }

    // ---- Save/Load ----
    bool Framework_Quest_SaveProgress(int saveSlot, const char* key) {
        if (!Framework_Save_BeginSave(saveSlot)) return false;

        // Build save data string: questId:state:obj0progress:obj1progress...;
        std::string data;
        for (const auto& kv : g_quests) {
            const Quest& q = kv.second;
            data += q.stringId + ":" + std::to_string(q.state);
            for (const auto& obj : q.objectives) {
                data += ":" + std::to_string(obj.currentProgress);
            }
            data += ";";
        }
        Framework_Save_WriteString(key, data.c_str());
        return Framework_Save_EndSave();
    }

    bool Framework_Quest_LoadProgress(int saveSlot, const char* key) {
        if (!Framework_Save_BeginLoad(saveSlot)) return false;

        const char* data = Framework_Save_ReadString(key, "");
        if (!data || strlen(data) == 0) {
            Framework_Save_EndLoad();
            return false;
        }

        std::string str = data;
        size_t pos = 0;
        while ((pos = str.find(';')) != std::string::npos) {
            std::string entry = str.substr(0, pos);
            str.erase(0, pos + 1);

            // Parse questId:state:obj0:obj1:...
            std::vector<std::string> parts;
            size_t colonPos;
            while ((colonPos = entry.find(':')) != std::string::npos) {
                parts.push_back(entry.substr(0, colonPos));
                entry.erase(0, colonPos + 1);
            }
            parts.push_back(entry);

            if (parts.size() >= 2) {
                std::string questId = parts[0];
                int state = std::stoi(parts[1]);

                auto idIt = g_questByStringId.find(questId);
                if (idIt != g_questByStringId.end()) {
                    auto qIt = g_quests.find(idIt->second);
                    if (qIt != g_quests.end()) {
                        qIt->second.state = state;
                        for (size_t i = 2; i < parts.size() && (i - 2) < qIt->second.objectives.size(); i++) {
                            qIt->second.objectives[i - 2].currentProgress = std::stoi(parts[i]);
                            qIt->second.objectives[i - 2].completed =
                                qIt->second.objectives[i - 2].currentProgress >= qIt->second.objectives[i - 2].requiredCount;
                        }
                    }
                }
            }
        }
        Framework_Save_EndLoad();
        return true;
    }

    // ---- Global Management ----
    void Framework_Quest_Update(float deltaTime) {
        for (auto& kv : g_quests) {
            Quest& q = kv.second;
            if (q.state != QUEST_STATE_IN_PROGRESS) continue;

            // Update time
            q.timeElapsed += deltaTime;

            // Check time limit
            if (q.timeLimit > 0 && q.timeElapsed >= q.timeLimit) {
                q.state = QUEST_STATE_FAILED;
                q.tracked = false;
                if (g_questStateCallback) {
                    g_questStateCallback(q.handle, QUEST_STATE_FAILED);
                }
            }
        }
    }

    void Framework_Quest_UndefineAll() {
        g_quests.clear();
        g_questByStringId.clear();
        g_questChains.clear();
        g_chainByStringId.clear();
        g_nextQuestHandle = 1;
        g_nextChainHandle = 1;
    }

    void Framework_Quest_ResetAllProgress() {
        for (auto& kv : g_quests) {
            Quest& q = kv.second;
            q.state = QUEST_STATE_NOT_STARTED;
            q.tracked = false;
            q.timeElapsed = 0;
            for (auto& obj : q.objectives) {
                obj.currentProgress = 0;
                obj.completed = false;
            }
        }
    }

    int Framework_Quest_GetDefinedCount() {
        return (int)g_quests.size();
    }

    // ========================================================================
    // 2D LIGHTING SYSTEM
    // ========================================================================

    struct Light2D {
        int id = 0;
        int type = LIGHT_TYPE_POINT;
        float x = 0, y = 0;
        float radius = 100.0f;
        unsigned char r = 255, g = 255, b = 255;
        float intensity = 1.0f;
        float falloff = 1.0f;
        bool enabled = true;
        int layer = 0;

        // Spot light properties
        float direction = 0;      // Angle in degrees
        float coneAngle = 45.0f;  // Half-angle of cone
        float softEdge = 0.1f;    // Soft edge factor

        // Effects
        float flickerAmount = 0;
        float flickerSpeed = 0;
        float flickerPhase = 0;
        float pulseMin = 1.0f, pulseMax = 1.0f;
        float pulseSpeed = 0;
        float pulsePhase = 0;

        // Attachment
        int attachedEntity = -1;
        float offsetX = 0, offsetY = 0;
    };

    struct ShadowOccluder {
        int id = 0;
        int type = 0;  // 0=box, 1=circle, 2=polygon
        float x = 0, y = 0;
        float rotation = 0;
        float width = 0, height = 0;
        float radius = 0;
        std::vector<float> points;  // For polygon
        bool enabled = true;

        // Attachment
        int attachedEntity = -1;
        float offsetX = 0, offsetY = 0;
    };

    struct LightingState {
        bool initialized = false;
        bool enabled = true;
        int width = 800, height = 600;

        // Render targets
        RenderTexture2D lightMap;
        RenderTexture2D sceneBuffer;
        bool hasRenderTargets = false;

        // Ambient
        unsigned char ambientR = 50, ambientG = 50, ambientB = 70;
        float ambientIntensity = 0.3f;

        // Directional light
        bool directionalEnabled = false;
        float directionalAngle = -45.0f;
        unsigned char dirR = 255, dirG = 255, dirB = 200;
        float dirIntensity = 0.5f;

        // Shadows
        int shadowQuality = SHADOW_QUALITY_HARD;
        float shadowBlur = 2.0f;
        unsigned char shadowR = 0, shadowG = 0, shadowB = 0, shadowA = 200;

        // Day/Night cycle
        bool dayNightEnabled = false;
        float timeOfDay = 12.0f;  // 0-24
        float dayNightSpeed = 1.0f;
        float sunriseTime = 6.0f;
        float sunsetTime = 18.0f;
        unsigned char dayAmbientR = 200, dayAmbientG = 200, dayAmbientB = 220;
        float dayAmbientIntensity = 0.8f;
        unsigned char nightAmbientR = 20, nightAmbientG = 20, nightAmbientB = 50;
        float nightAmbientIntensity = 0.1f;
    };

    static LightingState g_lighting;
    static std::unordered_map<int, Light2D> g_lights;
    static std::unordered_map<int, ShadowOccluder> g_occluders;
    static int g_nextLightId = 1;
    static int g_nextOccluderId = 1;

    // Helper: Draw a single light to the light map
    static void DrawLight2D(const Light2D& light, float effectiveIntensity) {
        if (!light.enabled || effectiveIntensity <= 0) return;

        Color lightColor = { light.r, light.g, light.b, (unsigned char)(255 * effectiveIntensity) };

        if (light.type == LIGHT_TYPE_POINT) {
            // Draw radial gradient
            for (float r = light.radius; r > 0; r -= 2.0f) {
                float t = r / light.radius;
                float falloffFactor = powf(1.0f - t, light.falloff);
                unsigned char alpha = (unsigned char)(255 * effectiveIntensity * falloffFactor);
                Color c = { light.r, light.g, light.b, alpha };
                DrawCircle((int)light.x, (int)light.y, r, c);
            }
        }
        else if (light.type == LIGHT_TYPE_SPOT) {
            // Draw cone shape
            float dirRad = light.direction * DEG2RAD;
            float coneRad = light.coneAngle * DEG2RAD;

            int segments = 32;
            for (float r = light.radius; r > 0; r -= 3.0f) {
                float t = r / light.radius;
                float falloffFactor = powf(1.0f - t, light.falloff);
                unsigned char alpha = (unsigned char)(255 * effectiveIntensity * falloffFactor);
                Color c = { light.r, light.g, light.b, alpha };

                // Draw arc segments
                for (int i = 0; i < segments; i++) {
                    float a1 = dirRad - coneRad + (2.0f * coneRad * i / segments);
                    float a2 = dirRad - coneRad + (2.0f * coneRad * (i + 1) / segments);

                    Vector2 p1 = { light.x + cosf(a1) * r, light.y + sinf(a1) * r };
                    Vector2 p2 = { light.x + cosf(a2) * r, light.y + sinf(a2) * r };
                    Vector2 center = { light.x, light.y };

                    DrawTriangle(center, p1, p2, c);
                }
            }
        }
    }

    // ---- Lighting System Control ----
    void Framework_Lighting_Initialize(int width, int height) {
        g_lighting.width = width;
        g_lighting.height = height;

        if (g_lighting.hasRenderTargets) {
            UnloadRenderTexture(g_lighting.lightMap);
            UnloadRenderTexture(g_lighting.sceneBuffer);
        }

        g_lighting.lightMap = LoadRenderTexture(width, height);
        g_lighting.sceneBuffer = LoadRenderTexture(width, height);
        g_lighting.hasRenderTargets = true;
        g_lighting.initialized = true;
    }

    void Framework_Lighting_Shutdown() {
        if (g_lighting.hasRenderTargets) {
            UnloadRenderTexture(g_lighting.lightMap);
            UnloadRenderTexture(g_lighting.sceneBuffer);
            g_lighting.hasRenderTargets = false;
        }
        g_lights.clear();
        g_occluders.clear();
        g_lighting.initialized = false;
    }

    void Framework_Lighting_SetEnabled(bool enabled) {
        g_lighting.enabled = enabled;
    }

    bool Framework_Lighting_IsEnabled() {
        return g_lighting.enabled;
    }

    void Framework_Lighting_SetResolution(int width, int height) {
        if (g_lighting.initialized && (width != g_lighting.width || height != g_lighting.height)) {
            Framework_Lighting_Initialize(width, height);
        }
    }

    // ---- Ambient Light ----
    void Framework_Lighting_SetAmbientColor(unsigned char r, unsigned char g, unsigned char b) {
        g_lighting.ambientR = r;
        g_lighting.ambientG = g;
        g_lighting.ambientB = b;
    }

    void Framework_Lighting_SetAmbientIntensity(float intensity) {
        g_lighting.ambientIntensity = intensity < 0 ? 0 : (intensity > 1 ? 1 : intensity);
    }

    float Framework_Lighting_GetAmbientIntensity() {
        return g_lighting.ambientIntensity;
    }

    // ---- Point Lights ----
    int Framework_Light_CreatePoint(float x, float y, float radius) {
        Light2D light;
        light.id = g_nextLightId++;
        light.type = LIGHT_TYPE_POINT;
        light.x = x;
        light.y = y;
        light.radius = radius;
        g_lights[light.id] = light;
        return light.id;
    }

    void Framework_Light_Destroy(int lightId) {
        g_lights.erase(lightId);
    }

    void Framework_Light_SetPosition(int lightId, float x, float y) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.x = x;
            it->second.y = y;
        }
    }

    void Framework_Light_GetPosition(int lightId, float* x, float* y) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            if (x) *x = it->second.x;
            if (y) *y = it->second.y;
        }
    }

    void Framework_Light_SetColor(int lightId, unsigned char r, unsigned char g, unsigned char b) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.r = r;
            it->second.g = g;
            it->second.b = b;
        }
    }

    void Framework_Light_SetIntensity(int lightId, float intensity) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.intensity = intensity < 0 ? 0 : intensity;
        }
    }

    float Framework_Light_GetIntensity(int lightId) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            return it->second.intensity;
        }
        return 0;
    }

    void Framework_Light_SetRadius(int lightId, float radius) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.radius = radius > 0 ? radius : 1;
        }
    }

    float Framework_Light_GetRadius(int lightId) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            return it->second.radius;
        }
        return 0;
    }

    void Framework_Light_SetEnabled(int lightId, bool enabled) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.enabled = enabled;
        }
    }

    bool Framework_Light_IsEnabled(int lightId) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            return it->second.enabled;
        }
        return false;
    }

    // ---- Spot Lights ----
    int Framework_Light_CreateSpot(float x, float y, float radius, float angle, float coneAngle) {
        Light2D light;
        light.id = g_nextLightId++;
        light.type = LIGHT_TYPE_SPOT;
        light.x = x;
        light.y = y;
        light.radius = radius;
        light.direction = angle;
        light.coneAngle = coneAngle;
        g_lights[light.id] = light;
        return light.id;
    }

    void Framework_Light_SetDirection(int lightId, float angle) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.direction = angle;
        }
    }

    float Framework_Light_GetDirection(int lightId) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            return it->second.direction;
        }
        return 0;
    }

    void Framework_Light_SetConeAngle(int lightId, float angle) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.coneAngle = angle > 0 ? angle : 1;
        }
    }

    float Framework_Light_GetConeAngle(int lightId) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            return it->second.coneAngle;
        }
        return 0;
    }

    void Framework_Light_SetSoftEdge(int lightId, float softness) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.softEdge = softness < 0 ? 0 : (softness > 1 ? 1 : softness);
        }
    }

    // ---- Directional Light (Global) ----
    void Framework_Lighting_SetDirectionalAngle(float angle) {
        g_lighting.directionalAngle = angle;
    }

    void Framework_Lighting_SetDirectionalColor(unsigned char r, unsigned char g, unsigned char b) {
        g_lighting.dirR = r;
        g_lighting.dirG = g;
        g_lighting.dirB = b;
    }

    void Framework_Lighting_SetDirectionalIntensity(float intensity) {
        g_lighting.dirIntensity = intensity < 0 ? 0 : intensity;
    }

    void Framework_Lighting_SetDirectionalEnabled(bool enabled) {
        g_lighting.directionalEnabled = enabled;
    }

    // ---- Light Properties ----
    void Framework_Light_SetFalloff(int lightId, float falloff) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.falloff = falloff > 0 ? falloff : 0.1f;
        }
    }

    float Framework_Light_GetFalloff(int lightId) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            return it->second.falloff;
        }
        return 1.0f;
    }

    void Framework_Light_SetFlicker(int lightId, float amount, float speed) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.flickerAmount = amount;
            it->second.flickerSpeed = speed;
        }
    }

    void Framework_Light_SetPulse(int lightId, float minIntensity, float maxIntensity, float speed) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.pulseMin = minIntensity;
            it->second.pulseMax = maxIntensity;
            it->second.pulseSpeed = speed;
        }
    }

    void Framework_Light_SetLayer(int lightId, int layer) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.layer = layer;
        }
    }

    int Framework_Light_GetLayer(int lightId) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            return it->second.layer;
        }
        return 0;
    }

    // ---- Light Attachment ----
    void Framework_Light_AttachToEntity(int lightId, int entityId, float offsetX, float offsetY) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.attachedEntity = entityId;
            it->second.offsetX = offsetX;
            it->second.offsetY = offsetY;
        }
    }

    void Framework_Light_Detach(int lightId) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            it->second.attachedEntity = -1;
        }
    }

    // ---- Shadow Occluders ----
    int Framework_Shadow_CreateBox(float x, float y, float width, float height) {
        ShadowOccluder occ;
        occ.id = g_nextOccluderId++;
        occ.type = 0;
        occ.x = x;
        occ.y = y;
        occ.width = width;
        occ.height = height;
        g_occluders[occ.id] = occ;
        return occ.id;
    }

    int Framework_Shadow_CreateCircle(float x, float y, float radius) {
        ShadowOccluder occ;
        occ.id = g_nextOccluderId++;
        occ.type = 1;
        occ.x = x;
        occ.y = y;
        occ.radius = radius;
        g_occluders[occ.id] = occ;
        return occ.id;
    }

    int Framework_Shadow_CreatePolygon(const float* points, int pointCount) {
        ShadowOccluder occ;
        occ.id = g_nextOccluderId++;
        occ.type = 2;
        if (points && pointCount > 0) {
            occ.points.assign(points, points + pointCount * 2);
        }
        g_occluders[occ.id] = occ;
        return occ.id;
    }

    void Framework_Shadow_Destroy(int occluderId) {
        g_occluders.erase(occluderId);
    }

    void Framework_Shadow_SetPosition(int occluderId, float x, float y) {
        auto it = g_occluders.find(occluderId);
        if (it != g_occluders.end()) {
            it->second.x = x;
            it->second.y = y;
        }
    }

    void Framework_Shadow_SetRotation(int occluderId, float angle) {
        auto it = g_occluders.find(occluderId);
        if (it != g_occluders.end()) {
            it->second.rotation = angle;
        }
    }

    void Framework_Shadow_SetEnabled(int occluderId, bool enabled) {
        auto it = g_occluders.find(occluderId);
        if (it != g_occluders.end()) {
            it->second.enabled = enabled;
        }
    }

    void Framework_Shadow_AttachToEntity(int occluderId, int entityId, float offsetX, float offsetY) {
        auto it = g_occluders.find(occluderId);
        if (it != g_occluders.end()) {
            it->second.attachedEntity = entityId;
            it->second.offsetX = offsetX;
            it->second.offsetY = offsetY;
        }
    }

    void Framework_Shadow_Detach(int occluderId) {
        auto it = g_occluders.find(occluderId);
        if (it != g_occluders.end()) {
            it->second.attachedEntity = -1;
        }
    }

    // ---- Shadow Settings ----
    void Framework_Lighting_SetShadowQuality(int quality) {
        g_lighting.shadowQuality = quality;
    }

    int Framework_Lighting_GetShadowQuality() {
        return g_lighting.shadowQuality;
    }

    void Framework_Lighting_SetShadowBlur(float blur) {
        g_lighting.shadowBlur = blur > 0 ? blur : 0;
    }

    void Framework_Lighting_SetShadowColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        g_lighting.shadowR = r;
        g_lighting.shadowG = g;
        g_lighting.shadowB = b;
        g_lighting.shadowA = a;
    }

    // ---- Day/Night Cycle ----
    void Framework_Lighting_SetTimeOfDay(float time) {
        while (time < 0) time += 24.0f;
        while (time >= 24.0f) time -= 24.0f;
        g_lighting.timeOfDay = time;
    }

    float Framework_Lighting_GetTimeOfDay() {
        return g_lighting.timeOfDay;
    }

    void Framework_Lighting_SetDayNightSpeed(float speed) {
        g_lighting.dayNightSpeed = speed;
    }

    void Framework_Lighting_SetDayNightEnabled(bool enabled) {
        g_lighting.dayNightEnabled = enabled;
    }

    void Framework_Lighting_SetSunriseTime(float hour) {
        g_lighting.sunriseTime = hour;
    }

    void Framework_Lighting_SetSunsetTime(float hour) {
        g_lighting.sunsetTime = hour;
    }

    void Framework_Lighting_SetDayAmbient(unsigned char r, unsigned char g, unsigned char b, float intensity) {
        g_lighting.dayAmbientR = r;
        g_lighting.dayAmbientG = g;
        g_lighting.dayAmbientB = b;
        g_lighting.dayAmbientIntensity = intensity;
    }

    void Framework_Lighting_SetNightAmbient(unsigned char r, unsigned char g, unsigned char b, float intensity) {
        g_lighting.nightAmbientR = r;
        g_lighting.nightAmbientG = g;
        g_lighting.nightAmbientB = b;
        g_lighting.nightAmbientIntensity = intensity;
    }

    // ---- Rendering ----
    void Framework_Lighting_BeginLightPass() {
        if (!g_lighting.initialized || !g_lighting.hasRenderTargets) return;

        BeginTextureMode(g_lighting.sceneBuffer);
        ClearBackground(BLACK);
    }

    void Framework_Lighting_EndLightPass() {
        if (!g_lighting.initialized || !g_lighting.hasRenderTargets) return;
        EndTextureMode();
    }

    void Framework_Lighting_RenderToScreen() {
        if (!g_lighting.initialized || !g_lighting.hasRenderTargets || !g_lighting.enabled) return;

        // Render light map
        BeginTextureMode(g_lighting.lightMap);

        // Start with ambient color
        unsigned char ambR = g_lighting.ambientR;
        unsigned char ambG = g_lighting.ambientG;
        unsigned char ambB = g_lighting.ambientB;
        float ambInt = g_lighting.ambientIntensity;

        // Apply day/night cycle
        if (g_lighting.dayNightEnabled) {
            float t = g_lighting.timeOfDay;
            float dayFactor = 0;

            if (t >= g_lighting.sunriseTime && t < g_lighting.sunriseTime + 1) {
                dayFactor = (t - g_lighting.sunriseTime);
            }
            else if (t >= g_lighting.sunriseTime + 1 && t < g_lighting.sunsetTime) {
                dayFactor = 1.0f;
            }
            else if (t >= g_lighting.sunsetTime && t < g_lighting.sunsetTime + 1) {
                dayFactor = 1.0f - (t - g_lighting.sunsetTime);
            }

            ambR = (unsigned char)(g_lighting.nightAmbientR + dayFactor * (g_lighting.dayAmbientR - g_lighting.nightAmbientR));
            ambG = (unsigned char)(g_lighting.nightAmbientG + dayFactor * (g_lighting.dayAmbientG - g_lighting.nightAmbientG));
            ambB = (unsigned char)(g_lighting.nightAmbientB + dayFactor * (g_lighting.dayAmbientB - g_lighting.nightAmbientB));
            ambInt = g_lighting.nightAmbientIntensity + dayFactor * (g_lighting.dayAmbientIntensity - g_lighting.nightAmbientIntensity);
        }

        ClearBackground({ (unsigned char)(ambR * ambInt), (unsigned char)(ambG * ambInt), (unsigned char)(ambB * ambInt), 255 });

        // Draw all lights with additive blending
        BeginBlendMode(BLEND_ADDITIVE);

        for (auto& kv : g_lights) {
            Light2D& light = kv.second;
            if (!light.enabled) continue;

            // Calculate effective intensity with flicker/pulse
            float effectiveIntensity = light.intensity;

            if (light.flickerAmount > 0 && light.flickerSpeed > 0) {
                float flicker = sinf(light.flickerPhase) * light.flickerAmount;
                effectiveIntensity *= (1.0f + flicker);
            }

            if (light.pulseSpeed > 0) {
                float pulse = (sinf(light.pulsePhase) + 1.0f) * 0.5f;
                effectiveIntensity *= light.pulseMin + pulse * (light.pulseMax - light.pulseMin);
            }

            DrawLight2D(light, effectiveIntensity);
        }

        EndBlendMode();
        EndTextureMode();

        // Draw scene with lighting applied
        DrawTextureRec(
            g_lighting.sceneBuffer.texture,
            { 0, 0, (float)g_lighting.width, -(float)g_lighting.height },
            { 0, 0 },
            WHITE
        );

        // Apply light map with multiply blend
        BeginBlendMode(BLEND_MULTIPLIED);
        DrawTextureRec(
            g_lighting.lightMap.texture,
            { 0, 0, (float)g_lighting.width, -(float)g_lighting.height },
            { 0, 0 },
            WHITE
        );
        EndBlendMode();
    }

    void Framework_Lighting_Update(float deltaTime) {
        // Update day/night cycle
        if (g_lighting.dayNightEnabled) {
            g_lighting.timeOfDay += deltaTime * g_lighting.dayNightSpeed / 3600.0f;  // Convert to game hours
            while (g_lighting.timeOfDay >= 24.0f) g_lighting.timeOfDay -= 24.0f;
        }

        // Update light effects and attachments
        for (auto& kv : g_lights) {
            Light2D& light = kv.second;

            // Update flicker
            if (light.flickerSpeed > 0) {
                light.flickerPhase += deltaTime * light.flickerSpeed;
            }

            // Update pulse
            if (light.pulseSpeed > 0) {
                light.pulsePhase += deltaTime * light.pulseSpeed;
            }

            // Update attachment
            if (light.attachedEntity >= 0) {
                auto it = g_transform2D.find(light.attachedEntity);
                if (it != g_transform2D.end()) {
                    light.x = it->second.position.x + light.offsetX;
                    light.y = it->second.position.y + light.offsetY;
                }
            }
        }

        // Update occluder attachments
        for (auto& kv : g_occluders) {
            ShadowOccluder& occ = kv.second;
            if (occ.attachedEntity >= 0) {
                auto it = g_transform2D.find(occ.attachedEntity);
                if (it != g_transform2D.end()) {
                    occ.x = it->second.position.x + occ.offsetX;
                    occ.y = it->second.position.y + occ.offsetY;
                }
            }
        }
    }

    // ---- Light Queries ----
    int Framework_Light_GetCount() {
        return (int)g_lights.size();
    }

    int Framework_Light_GetAt(int index) {
        int i = 0;
        for (const auto& kv : g_lights) {
            if (i == index) return kv.first;
            i++;
        }
        return -1;
    }

    int Framework_Light_GetType(int lightId) {
        auto it = g_lights.find(lightId);
        if (it != g_lights.end()) {
            return it->second.type;
        }
        return -1;
    }

    float Framework_Light_GetBrightnessAt(float x, float y) {
        float totalBrightness = g_lighting.ambientIntensity;

        for (const auto& kv : g_lights) {
            const Light2D& light = kv.second;
            if (!light.enabled) continue;

            float dx = x - light.x;
            float dy = y - light.y;
            float dist = sqrtf(dx * dx + dy * dy);

            if (dist < light.radius) {
                float t = dist / light.radius;
                float contribution = light.intensity * powf(1.0f - t, light.falloff);

                if (light.type == LIGHT_TYPE_SPOT) {
                    // Check if point is within cone
                    float angleToPoint = atan2f(dy, dx) * RAD2DEG;
                    float angleDiff = fabsf(angleToPoint - light.direction);
                    while (angleDiff > 180) angleDiff -= 360;
                    angleDiff = fabsf(angleDiff);

                    if (angleDiff > light.coneAngle) {
                        contribution = 0;
                    }
                    else {
                        contribution *= 1.0f - (angleDiff / light.coneAngle);
                    }
                }

                totalBrightness += contribution;
            }
        }

        return totalBrightness > 1.0f ? 1.0f : totalBrightness;
    }

    // ---- Global Management ----
    void Framework_Light_DestroyAll() {
        g_lights.clear();
        g_nextLightId = 1;
    }

    void Framework_Shadow_DestroyAll() {
        g_occluders.clear();
        g_nextOccluderId = 1;
    }

    // ========================================================================
    // SCREEN EFFECTS SYSTEM
    // ========================================================================

    // Helper function for smooth interpolation
    static inline float smoothstep(float edge0, float edge1, float x) {
        float t = (x - edge0) / (edge1 - edge0);
        t = t < 0.0f ? 0.0f : (t > 1.0f ? 1.0f : t);  // clamp to [0,1]
        return t * t * (3.0f - 2.0f * t);
    }

    struct ScreenEffectsState {
        bool initialized = false;
        bool enabled = true;
        int width = 800, height = 600;

        // Render target
        RenderTexture2D sceneBuffer;
        RenderTexture2D effectBuffer;
        bool hasRenderTargets = false;
        bool isCapturing = false;  // Track if currently capturing

        // Vignette
        bool vignetteEnabled = false;
        float vignetteIntensity = 0.5f;
        float vignetteRadius = 0.8f;
        float vignetteSoftness = 0.4f;
        unsigned char vignetteR = 0, vignetteG = 0, vignetteB = 0;

        // Blur
        bool blurEnabled = false;
        float blurAmount = 2.0f;
        int blurIterations = 2;

        // Chromatic aberration
        bool chromaticEnabled = false;
        float chromaticOffset = 3.0f;
        float chromaticAngle = 0.0f;

        // Pixelate
        bool pixelateEnabled = false;
        int pixelateSize = 4;

        // Scanlines
        bool scanlinesEnabled = false;
        float scanlinesIntensity = 0.3f;
        int scanlinesCount = 240;
        float scanlinesSpeed = 0.0f;
        float scanlinesOffset = 0.0f;

        // CRT
        bool crtEnabled = false;
        float crtCurvature = 0.1f;
        float crtVignetteIntensity = 0.3f;

        // Color effects
        bool grayscaleEnabled = false;
        float grayscaleAmount = 1.0f;
        bool sepiaEnabled = false;
        float sepiaAmount = 1.0f;
        bool invertEnabled = false;
        float invertAmount = 1.0f;

        // Color grading
        bool tintEnabled = false;
        unsigned char tintR = 255, tintG = 255, tintB = 255;
        float tintAmount = 0.5f;
        float brightness = 1.0f;
        float contrast = 1.0f;
        float saturation = 1.0f;
        float gamma = 1.0f;

        // Film grain
        bool filmGrainEnabled = false;
        float filmGrainIntensity = 0.1f;
        float filmGrainSpeed = 10.0f;
        float filmGrainTime = 0.0f;

        // Flash
        bool flashActive = false;
        unsigned char flashR = 255, flashG = 255, flashB = 255;
        float flashDuration = 0.0f;
        float flashTimer = 0.0f;

        // Fade
        bool fadeActive = false;
        unsigned char fadeR = 0, fadeG = 0, fadeB = 0;
        float fadeAmount = 0.0f;
        float fadeTarget = 0.0f;
        float fadeDuration = 0.0f;
        float fadeTimer = 0.0f;

        // Shake
        bool shakeActive = false;
        float shakeIntensity = 0.0f;
        float shakeDuration = 0.0f;
        float shakeTimer = 0.0f;
        float shakeDecay = 1.0f;
        float shakeOffsetX = 0.0f;
        float shakeOffsetY = 0.0f;
    };

    static ScreenEffectsState g_effects;

    // Helper: Apply color grading to a pixel
    static Color ApplyColorGrading(Color c) {
        float r = c.r / 255.0f;
        float g = c.g / 255.0f;
        float b = c.b / 255.0f;

        // Brightness
        r *= g_effects.brightness;
        g *= g_effects.brightness;
        b *= g_effects.brightness;

        // Contrast
        r = ((r - 0.5f) * g_effects.contrast) + 0.5f;
        g = ((g - 0.5f) * g_effects.contrast) + 0.5f;
        b = ((b - 0.5f) * g_effects.contrast) + 0.5f;

        // Saturation
        float gray = 0.299f * r + 0.587f * g + 0.114f * b;
        r = gray + g_effects.saturation * (r - gray);
        g = gray + g_effects.saturation * (g - gray);
        b = gray + g_effects.saturation * (b - gray);

        // Gamma
        if (g_effects.gamma != 1.0f) {
            r = powf(r, 1.0f / g_effects.gamma);
            g = powf(g, 1.0f / g_effects.gamma);
            b = powf(b, 1.0f / g_effects.gamma);
        }

        // Clamp
        r = r < 0 ? 0 : (r > 1 ? 1 : r);
        g = g < 0 ? 0 : (g > 1 ? 1 : g);
        b = b < 0 ? 0 : (b > 1 ? 1 : b);

        return { (unsigned char)(r * 255), (unsigned char)(g * 255), (unsigned char)(b * 255), c.a };
    }

    // ---- System Control ----
    void Framework_Effects_Initialize(int width, int height) {
        g_effects.width = width;
        g_effects.height = height;

        if (g_effects.hasRenderTargets) {
            UnloadRenderTexture(g_effects.sceneBuffer);
            UnloadRenderTexture(g_effects.effectBuffer);
        }

        g_effects.sceneBuffer = LoadRenderTexture(width, height);
        g_effects.effectBuffer = LoadRenderTexture(width, height);
        g_effects.hasRenderTargets = true;
        g_effects.initialized = true;
    }

    void Framework_Effects_Shutdown() {
        if (g_effects.hasRenderTargets) {
            UnloadRenderTexture(g_effects.sceneBuffer);
            UnloadRenderTexture(g_effects.effectBuffer);
            g_effects.hasRenderTargets = false;
        }
        g_effects.initialized = false;
    }

    void Framework_Effects_SetEnabled(bool enabled) {
        g_effects.enabled = enabled;
    }

    bool Framework_Effects_IsEnabled() {
        return g_effects.enabled;
    }

    void Framework_Effects_SetResolution(int width, int height) {
        if (g_effects.initialized && (width != g_effects.width || height != g_effects.height)) {
            Framework_Effects_Initialize(width, height);
        }
    }

    // ---- Vignette Effect ----
    void Framework_Effects_SetVignetteEnabled(bool enabled) { g_effects.vignetteEnabled = enabled; }
    void Framework_Effects_SetVignetteIntensity(float intensity) { g_effects.vignetteIntensity = intensity; }
    void Framework_Effects_SetVignetteRadius(float radius) { g_effects.vignetteRadius = radius; }
    void Framework_Effects_SetVignetteSoftness(float softness) { g_effects.vignetteSoftness = softness; }
    void Framework_Effects_SetVignetteColor(unsigned char r, unsigned char g, unsigned char b) {
        g_effects.vignetteR = r; g_effects.vignetteG = g; g_effects.vignetteB = b;
    }

    // ---- Blur Effect ----
    void Framework_Effects_SetBlurEnabled(bool enabled) { g_effects.blurEnabled = enabled; }
    void Framework_Effects_SetBlurAmount(float amount) { g_effects.blurAmount = amount; }
    void Framework_Effects_SetBlurIterations(int iterations) { g_effects.blurIterations = iterations > 0 ? iterations : 1; }

    // ---- Chromatic Aberration ----
    void Framework_Effects_SetChromaticEnabled(bool enabled) { g_effects.chromaticEnabled = enabled; }
    void Framework_Effects_SetChromaticOffset(float offset) { g_effects.chromaticOffset = offset; }
    void Framework_Effects_SetChromaticAngle(float angle) { g_effects.chromaticAngle = angle; }

    // ---- Pixelate Effect ----
    void Framework_Effects_SetPixelateEnabled(bool enabled) { g_effects.pixelateEnabled = enabled; }
    void Framework_Effects_SetPixelateSize(int pixelSize) { g_effects.pixelateSize = pixelSize > 1 ? pixelSize : 1; }

    // ---- Scanlines Effect ----
    void Framework_Effects_SetScanlinesEnabled(bool enabled) { g_effects.scanlinesEnabled = enabled; }
    void Framework_Effects_SetScanlinesIntensity(float intensity) { g_effects.scanlinesIntensity = intensity; }
    void Framework_Effects_SetScanlinesCount(int count) { g_effects.scanlinesCount = count > 0 ? count : 1; }
    void Framework_Effects_SetScanlinesSpeed(float speed) { g_effects.scanlinesSpeed = speed; }

    // ---- CRT Effect ----
    void Framework_Effects_SetCRTEnabled(bool enabled) { g_effects.crtEnabled = enabled; }
    void Framework_Effects_SetCRTCurvature(float curvature) { g_effects.crtCurvature = curvature; }
    void Framework_Effects_SetCRTVignetteIntensity(float intensity) { g_effects.crtVignetteIntensity = intensity; }

    // ---- Color Effects ----
    void Framework_Effects_SetGrayscaleEnabled(bool enabled) { g_effects.grayscaleEnabled = enabled; }
    void Framework_Effects_SetGrayscaleAmount(float amount) { g_effects.grayscaleAmount = amount; }
    void Framework_Effects_SetSepiaEnabled(bool enabled) { g_effects.sepiaEnabled = enabled; }
    void Framework_Effects_SetSepiaAmount(float amount) { g_effects.sepiaAmount = amount; }
    void Framework_Effects_SetInvertEnabled(bool enabled) { g_effects.invertEnabled = enabled; }
    void Framework_Effects_SetInvertAmount(float amount) { g_effects.invertAmount = amount; }

    // ---- Color Grading ----
    void Framework_Effects_SetTintEnabled(bool enabled) { g_effects.tintEnabled = enabled; }
    void Framework_Effects_SetTintColor(unsigned char r, unsigned char g, unsigned char b) {
        g_effects.tintR = r; g_effects.tintG = g; g_effects.tintB = b;
    }
    void Framework_Effects_SetTintAmount(float amount) { g_effects.tintAmount = amount; }
    void Framework_Effects_SetBrightness(float brightness) { g_effects.brightness = brightness; }
    void Framework_Effects_SetContrast(float contrast) { g_effects.contrast = contrast; }
    void Framework_Effects_SetSaturation(float saturation) { g_effects.saturation = saturation; }
    void Framework_Effects_SetGamma(float gamma) { g_effects.gamma = gamma > 0.1f ? gamma : 0.1f; }

    // ---- Film Grain / Noise ----
    void Framework_Effects_SetFilmGrainEnabled(bool enabled) { g_effects.filmGrainEnabled = enabled; }
    void Framework_Effects_SetFilmGrainIntensity(float intensity) { g_effects.filmGrainIntensity = intensity; }
    void Framework_Effects_SetFilmGrainSpeed(float speed) { g_effects.filmGrainSpeed = speed; }

    // ---- Screen Flash ----
    void Framework_Effects_Flash(unsigned char r, unsigned char g, unsigned char b, float duration) {
        g_effects.flashR = r;
        g_effects.flashG = g;
        g_effects.flashB = b;
        g_effects.flashDuration = duration;
        g_effects.flashTimer = duration;
        g_effects.flashActive = true;
    }

    void Framework_Effects_FlashWhite(float duration) {
        Framework_Effects_Flash(255, 255, 255, duration);
    }

    void Framework_Effects_FlashDamage(float duration) {
        Framework_Effects_Flash(255, 50, 50, duration);
    }

    bool Framework_Effects_IsFlashing() {
        return g_effects.flashActive;
    }

    // ---- Screen Fade ----
    void Framework_Effects_FadeIn(float duration) {
        g_effects.fadeAmount = 1.0f;
        g_effects.fadeTarget = 0.0f;
        g_effects.fadeDuration = duration;
        g_effects.fadeTimer = duration;
        g_effects.fadeActive = true;
    }

    void Framework_Effects_FadeOut(float duration) {
        g_effects.fadeAmount = 0.0f;
        g_effects.fadeTarget = 1.0f;
        g_effects.fadeDuration = duration;
        g_effects.fadeTimer = duration;
        g_effects.fadeActive = true;
    }

    void Framework_Effects_FadeToColor(unsigned char r, unsigned char g, unsigned char b, float duration) {
        g_effects.fadeR = r;
        g_effects.fadeG = g;
        g_effects.fadeB = b;
        Framework_Effects_FadeOut(duration);
    }

    void Framework_Effects_SetFadeColor(unsigned char r, unsigned char g, unsigned char b) {
        g_effects.fadeR = r;
        g_effects.fadeG = g;
        g_effects.fadeB = b;
    }

    float Framework_Effects_GetFadeAmount() {
        return g_effects.fadeAmount;
    }

    bool Framework_Effects_IsFading() {
        return g_effects.fadeActive;
    }

    // ---- Screen Shake ----
    void Framework_Effects_Shake(float intensity, float duration) {
        g_effects.shakeIntensity = intensity;
        g_effects.shakeDuration = duration;
        g_effects.shakeTimer = duration;
        g_effects.shakeDecay = 1.0f;
        g_effects.shakeActive = true;
    }

    void Framework_Effects_ShakeDecay(float intensity, float duration, float decay) {
        g_effects.shakeIntensity = intensity;
        g_effects.shakeDuration = duration;
        g_effects.shakeTimer = duration;
        g_effects.shakeDecay = decay;
        g_effects.shakeActive = true;
    }

    void Framework_Effects_StopShake() {
        g_effects.shakeActive = false;
        g_effects.shakeOffsetX = 0;
        g_effects.shakeOffsetY = 0;
    }

    bool Framework_Effects_IsShaking() {
        return g_effects.shakeActive;
    }

    void Framework_Effects_GetShakeOffset(float* x, float* y) {
        if (x) *x = g_effects.shakeOffsetX;
        if (y) *y = g_effects.shakeOffsetY;
    }

    // ---- Rendering ----
    void Framework_Effects_BeginCapture() {
        if (!g_effects.initialized || !g_effects.hasRenderTargets) return;
        g_effects.isCapturing = true;
        BeginTextureMode(g_effects.sceneBuffer);
        ClearBackground(BLACK);
    }

    void Framework_Effects_EndCapture() {
        if (!g_effects.initialized || !g_effects.hasRenderTargets || !g_effects.isCapturing) return;
        EndTextureMode();
        g_effects.isCapturing = false;
    }

    void Framework_Effects_Apply() {
        // Only draw from buffer if we actually captured to it
        bool shouldDrawBuffer = g_effects.initialized && g_effects.hasRenderTargets && !g_effects.isCapturing;

        if (shouldDrawBuffer) {
            float w = (float)g_effects.width;
            float h = (float)g_effects.height;

            // Draw the captured scene buffer
            Rectangle srcRect = { 0, 0, w, -h };  // Flip Y
            Vector2 pos = { g_effects.shakeOffsetX, g_effects.shakeOffsetY };

            // Apply color effects via tint
            Color tint = WHITE;
            if (g_effects.enabled && g_effects.grayscaleEnabled) {
                // For grayscale, desaturate by drawing with gray tint
                tint.r = 180;
                tint.g = 180;
                tint.b = 180;
            }
            if (g_effects.enabled && g_effects.sepiaEnabled) {
                // Sepia warm tint
                tint.r = 255;
                tint.g = 230;
                tint.b = 200;
            }

            DrawTextureRec(g_effects.sceneBuffer.texture, srcRect, pos, tint);
        } else {
            // Debug: show red if capture system failed
            DrawRectangle(0, 0, 100, 30, RED);
            DrawText("CAPTURE FAILED", 5, 5, 10, WHITE);
        }

        // Get screen dimensions for overlays
        int screenW = g_effects.initialized ? g_effects.width : GetScreenWidth();
        int screenH = g_effects.initialized ? g_effects.height : GetScreenHeight();

        // Apply scanlines (overlay effect)
        if (g_effects.enabled && g_effects.scanlinesEnabled) {
            float lineHeight = (float)screenH / g_effects.scanlinesCount;
            for (int i = 0; i < g_effects.scanlinesCount; i++) {
                float y = i * lineHeight + g_effects.scanlinesOffset;
                while (y >= screenH) y -= screenH;
                DrawRectangle(0, (int)y, screenW, (int)(lineHeight * 0.5f),
                    { 0, 0, 0, (unsigned char)(255 * g_effects.scanlinesIntensity) });
            }
        }

        // Apply vignette (overlay effect)
        if (g_effects.enabled && g_effects.vignetteEnabled) {
            float cx = screenW * 0.5f;
            float cy = screenH * 0.5f;

            for (int y = 0; y < screenH; y += 4) {
                for (int x = 0; x < screenW; x += 4) {
                    float dx = (x - cx) / cx;
                    float dy = (y - cy) / cy;
                    float dist = sqrtf(dx * dx + dy * dy);

                    float vignette = 1.0f - smoothstep(g_effects.vignetteRadius - g_effects.vignetteSoftness,
                        g_effects.vignetteRadius + g_effects.vignetteSoftness, dist);
                    vignette = 1.0f - (1.0f - vignette) * g_effects.vignetteIntensity;

                    if (vignette < 1.0f) {
                        unsigned char alpha = (unsigned char)((1.0f - vignette) * 255);
                        DrawRectangle(x, y, 4, 4, { g_effects.vignetteR, g_effects.vignetteG, g_effects.vignetteB, alpha });
                    }
                }
            }
        }

        // Apply film grain (overlay effect)
        if (g_effects.enabled && g_effects.filmGrainEnabled) {
            for (int y = 0; y < screenH; y += 2) {
                for (int x = 0; x < screenW; x += 2) {
                    float noise = (float)(rand() % 1000) / 1000.0f - 0.5f;
                    int gray = (int)(128 + noise * 255 * g_effects.filmGrainIntensity);
                    gray = gray < 0 ? 0 : (gray > 255 ? 255 : gray);
                    DrawRectangle(x, y, 2, 2, { (unsigned char)gray, (unsigned char)gray, (unsigned char)gray, 30 });
                }
            }
        }

        // Apply flash overlay (always works, no initialization needed)
        if (g_effects.flashActive && g_effects.flashTimer > 0) {
            float alpha = g_effects.flashTimer / g_effects.flashDuration;
            DrawRectangle(0, 0, screenW, screenH,
                { g_effects.flashR, g_effects.flashG, g_effects.flashB, (unsigned char)(alpha * 200) });
        }

        // Apply fade overlay (always works, no initialization needed)
        if (g_effects.fadeAmount > 0) {
            DrawRectangle(0, 0, screenW, screenH,
                { g_effects.fadeR, g_effects.fadeG, g_effects.fadeB, (unsigned char)(g_effects.fadeAmount * 255) });
        }

        // Apply tint (overlay effect)
        if (g_effects.enabled && g_effects.tintEnabled) {
            BeginBlendMode(BLEND_MULTIPLIED);
            unsigned char tr = (unsigned char)(255 - (255 - g_effects.tintR) * g_effects.tintAmount);
            unsigned char tg = (unsigned char)(255 - (255 - g_effects.tintG) * g_effects.tintAmount);
            unsigned char tb = (unsigned char)(255 - (255 - g_effects.tintB) * g_effects.tintAmount);
            DrawRectangle(0, 0, screenW, screenH, { tr, tg, tb, 255 });
            EndBlendMode();
        }
    }

    // Draw overlay effects without requiring render texture initialization
    // Call this at the end of your OnDraw to add flash, fade, shake overlays
    void Framework_Effects_DrawOverlays(int screenWidth, int screenHeight) {
        // Apply scanlines
        if (g_effects.scanlinesEnabled) {
            float lineHeight = (float)screenHeight / g_effects.scanlinesCount;
            for (int i = 0; i < g_effects.scanlinesCount; i++) {
                float y = i * lineHeight + g_effects.scanlinesOffset;
                while (y >= screenHeight) y -= screenHeight;
                DrawRectangle(0, (int)y, screenWidth, (int)(lineHeight * 0.5f),
                    { 0, 0, 0, (unsigned char)(255 * g_effects.scanlinesIntensity) });
            }
        }

        // Apply vignette
        if (g_effects.vignetteEnabled) {
            float cx = screenWidth * 0.5f;
            float cy = screenHeight * 0.5f;

            for (int y = 0; y < screenHeight; y += 4) {
                for (int x = 0; x < screenWidth; x += 4) {
                    float dx = (x - cx) / cx;
                    float dy = (y - cy) / cy;
                    float dist = sqrtf(dx * dx + dy * dy);

                    float vignette = 1.0f - smoothstep(g_effects.vignetteRadius - g_effects.vignetteSoftness,
                        g_effects.vignetteRadius + g_effects.vignetteSoftness, dist);
                    vignette = 1.0f - (1.0f - vignette) * g_effects.vignetteIntensity;

                    if (vignette < 1.0f) {
                        unsigned char alpha = (unsigned char)((1.0f - vignette) * 255);
                        DrawRectangle(x, y, 4, 4, { g_effects.vignetteR, g_effects.vignetteG, g_effects.vignetteB, alpha });
                    }
                }
            }
        }

        // Apply flash overlay
        if (g_effects.flashActive && g_effects.flashTimer > 0) {
            float alpha = g_effects.flashTimer / g_effects.flashDuration;
            DrawRectangle(0, 0, screenWidth, screenHeight,
                { g_effects.flashR, g_effects.flashG, g_effects.flashB, (unsigned char)(alpha * 200) });
        }

        // Apply fade overlay
        if (g_effects.fadeAmount > 0) {
            DrawRectangle(0, 0, screenWidth, screenHeight,
                { g_effects.fadeR, g_effects.fadeG, g_effects.fadeB, (unsigned char)(g_effects.fadeAmount * 255) });
        }
    }

    void Framework_Effects_Update(float deltaTime) {
        // Update scanlines offset
        if (g_effects.scanlinesEnabled && g_effects.scanlinesSpeed != 0) {
            g_effects.scanlinesOffset += deltaTime * g_effects.scanlinesSpeed;
        }

        // Update film grain time
        if (g_effects.filmGrainEnabled) {
            g_effects.filmGrainTime += deltaTime * g_effects.filmGrainSpeed;
        }

        // Update flash
        if (g_effects.flashActive) {
            g_effects.flashTimer -= deltaTime;
            if (g_effects.flashTimer <= 0) {
                g_effects.flashActive = false;
                g_effects.flashTimer = 0;
            }
        }

        // Update fade
        if (g_effects.fadeActive) {
            g_effects.fadeTimer -= deltaTime;
            float t = 1.0f - (g_effects.fadeTimer / g_effects.fadeDuration);
            t = t < 0 ? 0 : (t > 1 ? 1 : t);

            if (g_effects.fadeTarget > g_effects.fadeAmount) {
                g_effects.fadeAmount = t;
            }
            else {
                g_effects.fadeAmount = 1.0f - t;
            }

            if (g_effects.fadeTimer <= 0) {
                g_effects.fadeActive = false;
                g_effects.fadeAmount = g_effects.fadeTarget;
            }
        }

        // Update shake
        if (g_effects.shakeActive) {
            g_effects.shakeTimer -= deltaTime;
            float t = g_effects.shakeTimer / g_effects.shakeDuration;
            t = t < 0 ? 0 : t;
            float intensity = g_effects.shakeIntensity * powf(t, g_effects.shakeDecay);

            g_effects.shakeOffsetX = ((float)(rand() % 1000) / 500.0f - 1.0f) * intensity;
            g_effects.shakeOffsetY = ((float)(rand() % 1000) / 500.0f - 1.0f) * intensity;

            if (g_effects.shakeTimer <= 0) {
                g_effects.shakeActive = false;
                g_effects.shakeOffsetX = 0;
                g_effects.shakeOffsetY = 0;
            }
        }
    }

    // ---- Presets ----
    void Framework_Effects_ApplyPresetRetro() {
        Framework_Effects_ResetAll();
        g_effects.pixelateEnabled = true;
        g_effects.pixelateSize = 3;
        g_effects.scanlinesEnabled = true;
        g_effects.scanlinesIntensity = 0.2f;
        g_effects.scanlinesCount = 240;
        g_effects.saturation = 1.2f;
        g_effects.contrast = 1.1f;
    }

    void Framework_Effects_ApplyPresetDream() {
        Framework_Effects_ResetAll();
        g_effects.blurEnabled = true;
        g_effects.blurAmount = 1.5f;
        g_effects.vignetteEnabled = true;
        g_effects.vignetteIntensity = 0.4f;
        g_effects.vignetteRadius = 0.7f;
        g_effects.saturation = 0.8f;
        g_effects.brightness = 1.1f;
        g_effects.tintEnabled = true;
        g_effects.tintR = 200; g_effects.tintG = 180; g_effects.tintB = 255;
        g_effects.tintAmount = 0.2f;
    }

    void Framework_Effects_ApplyPresetHorror() {
        Framework_Effects_ResetAll();
        g_effects.vignetteEnabled = true;
        g_effects.vignetteIntensity = 0.7f;
        g_effects.vignetteRadius = 0.5f;
        g_effects.saturation = 0.5f;
        g_effects.contrast = 1.3f;
        g_effects.brightness = 0.8f;
        g_effects.filmGrainEnabled = true;
        g_effects.filmGrainIntensity = 0.15f;
        g_effects.chromaticEnabled = true;
        g_effects.chromaticOffset = 2.0f;
    }

    void Framework_Effects_ApplyPresetNoir() {
        Framework_Effects_ResetAll();
        g_effects.grayscaleEnabled = true;
        g_effects.grayscaleAmount = 1.0f;
        g_effects.contrast = 1.4f;
        g_effects.vignetteEnabled = true;
        g_effects.vignetteIntensity = 0.5f;
        g_effects.filmGrainEnabled = true;
        g_effects.filmGrainIntensity = 0.1f;
    }

    void Framework_Effects_ResetAll() {
        g_effects.vignetteEnabled = false;
        g_effects.blurEnabled = false;
        g_effects.chromaticEnabled = false;
        g_effects.pixelateEnabled = false;
        g_effects.scanlinesEnabled = false;
        g_effects.crtEnabled = false;
        g_effects.grayscaleEnabled = false;
        g_effects.sepiaEnabled = false;
        g_effects.invertEnabled = false;
        g_effects.tintEnabled = false;
        g_effects.filmGrainEnabled = false;
        g_effects.brightness = 1.0f;
        g_effects.contrast = 1.0f;
        g_effects.saturation = 1.0f;
        g_effects.gamma = 1.0f;
    }

    // ========================================================================
    // CLEANUP
    // ========================================================================
    void Framework_ResourcesShutdown() {
        // Textures
        for (auto& kv : g_texByHandle) {
            if (kv.second.valid) UnloadTexture(kv.second.tex);
        }
        g_texByHandle.clear();
        g_handleByTexPath.clear();

        // Fonts
        for (auto& kv : g_fontByHandle) {
            if (kv.second.valid) UnloadFont(kv.second.font);
        }
        g_fontByHandle.clear();
        g_handleByFontKey.clear();

        // Music
        for (auto& kv : g_musByHandle) {
            if (kv.second.valid) {
                StopMusicStream(kv.second.mus);
                UnloadMusicStream(kv.second.mus);
            }
        }
        g_musByHandle.clear();
        g_handleByMusPath.clear();

        // Prefabs
        g_prefabs.clear();
    }

    // ========================================================================
    // LOCALIZATION SYSTEM
    // ========================================================================

    struct LocaleLanguage {
        std::string code;
        std::unordered_map<std::string, std::string> strings;
        std::string filePath;
    };

    struct LocaleState {
        bool initialized = false;
        std::string currentLanguage;
        std::unordered_map<std::string, LocaleLanguage> languages;
        LocaleChangedCallback onLanguageChanged = nullptr;
    };

    static LocaleState g_locale;
    static char g_localeStringBuffer[4096];
    static char g_localeFormatBuffer[4096];
    static char g_localeLanguageBuffer[64];

    void Framework_Locale_Initialize() {
        g_locale.initialized = true;
        g_locale.languages.clear();

        // Create a default language so SetString works without loading a file
        LocaleLanguage defaultLang;
        defaultLang.code = "default";
        g_locale.languages["default"] = defaultLang;
        g_locale.currentLanguage = "default";
    }

    void Framework_Locale_Shutdown() {
        g_locale.languages.clear();
        g_locale.currentLanguage = "";
        g_locale.initialized = false;
    }

    bool Framework_Locale_LoadLanguage(const char* languageCode, const char* filePath) {
        if (!languageCode || !filePath) return false;

        LocaleLanguage lang;
        lang.code = languageCode;
        lang.filePath = filePath;

        // Simple key=value file format
        FILE* file = fopen(filePath, "r");
        if (!file) return false;

        char line[1024];
        while (fgets(line, sizeof(line), file)) {
            // Skip comments and empty lines
            if (line[0] == '#' || line[0] == '\n' || line[0] == '\r') continue;

            // Find = separator
            char* eq = strchr(line, '=');
            if (!eq) continue;

            *eq = '\0';
            char* key = line;
            char* value = eq + 1;

            // Trim whitespace from key
            while (*key == ' ' || *key == '\t') key++;
            char* keyEnd = eq - 1;
            while (keyEnd > key && (*keyEnd == ' ' || *keyEnd == '\t')) keyEnd--;
            *(keyEnd + 1) = '\0';

            // Trim whitespace and newline from value
            while (*value == ' ' || *value == '\t') value++;
            size_t valueLen = strlen(value);
            while (valueLen > 0 && (value[valueLen - 1] == '\n' || value[valueLen - 1] == '\r' || value[valueLen - 1] == ' ')) {
                value[--valueLen] = '\0';
            }

            if (strlen(key) > 0) {
                lang.strings[key] = value;
            }
        }
        fclose(file);

        g_locale.languages[languageCode] = lang;

        // If no current language, set this one
        if (g_locale.currentLanguage.empty()) {
            g_locale.currentLanguage = languageCode;
        }

        return true;
    }

    bool Framework_Locale_SetLanguage(const char* languageCode) {
        if (!languageCode) return false;

        auto it = g_locale.languages.find(languageCode);
        if (it == g_locale.languages.end()) return false;

        std::string oldLang = g_locale.currentLanguage;
        g_locale.currentLanguage = languageCode;

        if (g_locale.onLanguageChanged && oldLang != languageCode) {
            g_locale.onLanguageChanged(languageCode);
        }

        return true;
    }

    const char* Framework_Locale_GetCurrentLanguage() {
        strncpy(g_localeLanguageBuffer, g_locale.currentLanguage.c_str(), sizeof(g_localeLanguageBuffer) - 1);
        g_localeLanguageBuffer[sizeof(g_localeLanguageBuffer) - 1] = '\0';
        return g_localeLanguageBuffer;
    }

    int Framework_Locale_GetLanguageCount() {
        return (int)g_locale.languages.size();
    }

    const char* Framework_Locale_GetLanguageAt(int index) {
        if (index < 0 || index >= (int)g_locale.languages.size()) return "";

        auto it = g_locale.languages.begin();
        std::advance(it, index);
        strncpy(g_localeLanguageBuffer, it->first.c_str(), sizeof(g_localeLanguageBuffer) - 1);
        g_localeLanguageBuffer[sizeof(g_localeLanguageBuffer) - 1] = '\0';
        return g_localeLanguageBuffer;
    }

    const char* Framework_Locale_GetString(const char* key) {
        return Framework_Locale_GetStringDefault(key, key);
    }

    const char* Framework_Locale_GetStringDefault(const char* key, const char* defaultValue) {
        if (!key) return defaultValue ? defaultValue : "";

        auto langIt = g_locale.languages.find(g_locale.currentLanguage);
        if (langIt == g_locale.languages.end()) return defaultValue ? defaultValue : key;

        auto strIt = langIt->second.strings.find(key);
        if (strIt == langIt->second.strings.end()) return defaultValue ? defaultValue : key;

        strncpy(g_localeStringBuffer, strIt->second.c_str(), sizeof(g_localeStringBuffer) - 1);
        g_localeStringBuffer[sizeof(g_localeStringBuffer) - 1] = '\0';
        return g_localeStringBuffer;
    }

    const char* Framework_Locale_Format(const char* key, const char* arg1) {
        const char* format = Framework_Locale_GetString(key);
        snprintf(g_localeFormatBuffer, sizeof(g_localeFormatBuffer), format, arg1 ? arg1 : "");
        return g_localeFormatBuffer;
    }

    const char* Framework_Locale_Format2(const char* key, const char* arg1, const char* arg2) {
        const char* format = Framework_Locale_GetString(key);
        snprintf(g_localeFormatBuffer, sizeof(g_localeFormatBuffer), format, arg1 ? arg1 : "", arg2 ? arg2 : "");
        return g_localeFormatBuffer;
    }

    const char* Framework_Locale_Format3(const char* key, const char* arg1, const char* arg2, const char* arg3) {
        const char* format = Framework_Locale_GetString(key);
        snprintf(g_localeFormatBuffer, sizeof(g_localeFormatBuffer), format, arg1 ? arg1 : "", arg2 ? arg2 : "", arg3 ? arg3 : "");
        return g_localeFormatBuffer;
    }

    bool Framework_Locale_HasString(const char* key) {
        if (!key) return false;
        auto langIt = g_locale.languages.find(g_locale.currentLanguage);
        if (langIt == g_locale.languages.end()) return false;
        return langIt->second.strings.find(key) != langIt->second.strings.end();
    }

    void Framework_Locale_SetString(const char* key, const char* value) {
        if (!key || !value) return;
        auto langIt = g_locale.languages.find(g_locale.currentLanguage);
        if (langIt == g_locale.languages.end()) return;
        langIt->second.strings[key] = value;
    }

    void Framework_Locale_RemoveString(const char* key) {
        if (!key) return;
        auto langIt = g_locale.languages.find(g_locale.currentLanguage);
        if (langIt == g_locale.languages.end()) return;
        langIt->second.strings.erase(key);
    }

    int Framework_Locale_GetStringCount() {
        auto langIt = g_locale.languages.find(g_locale.currentLanguage);
        if (langIt == g_locale.languages.end()) return 0;
        return (int)langIt->second.strings.size();
    }

    void Framework_Locale_ClearStrings() {
        auto langIt = g_locale.languages.find(g_locale.currentLanguage);
        if (langIt == g_locale.languages.end()) return;
        langIt->second.strings.clear();
    }

    bool Framework_Locale_SaveLanguage(const char* languageCode, const char* filePath) {
        if (!languageCode || !filePath) return false;

        auto langIt = g_locale.languages.find(languageCode);
        if (langIt == g_locale.languages.end()) return false;

        FILE* file = fopen(filePath, "w");
        if (!file) return false;

        fprintf(file, "# Language: %s\n", languageCode);
        for (const auto& kv : langIt->second.strings) {
            fprintf(file, "%s=%s\n", kv.first.c_str(), kv.second.c_str());
        }

        fclose(file);
        return true;
    }

    bool Framework_Locale_ReloadCurrent() {
        auto langIt = g_locale.languages.find(g_locale.currentLanguage);
        if (langIt == g_locale.languages.end()) return false;

        std::string path = langIt->second.filePath;
        std::string code = langIt->second.code;

        return Framework_Locale_LoadLanguage(code.c_str(), path.c_str());
    }

    void Framework_Locale_SetOnLanguageChanged(LocaleChangedCallback callback) {
        g_locale.onLanguageChanged = callback;
    }

    // ========================================================================
    // ACHIEVEMENT SYSTEM
    // ========================================================================

    struct Achievement {
        int id;
        std::string stringId;
        std::string name;
        std::string description;
        int iconTexture = 0;
        bool hidden = false;
        int points = 0;
        int progress = 0;
        int progressTarget = 0;  // 0 = no progress tracking
        bool unlocked = false;
        float unlockTime = 0.0f;
    };

    struct AchievementNotification {
        int achievementId;
        float timer;
        float duration;
    };

    struct AchievementState {
        std::unordered_map<int, Achievement> achievements;
        int nextId = 1;
        bool notificationsEnabled = true;
        float notificationDuration = 3.0f;
        int notificationX = 20;
        int notificationY = 20;
        std::vector<AchievementNotification> notifications;
        AchievementUnlockedCallback onUnlocked = nullptr;
    };

    static AchievementState g_achievements;
    static char g_achievementStringBuffer[512];

    int Framework_Achievement_Create(const char* id, const char* name, const char* description) {
        Achievement ach;
        ach.id = g_achievements.nextId++;
        ach.stringId = id ? id : "";
        ach.name = name ? name : "";
        ach.description = description ? description : "";
        g_achievements.achievements[ach.id] = ach;
        return ach.id;
    }

    void Framework_Achievement_SetIcon(int achievementId, int textureHandle) {
        auto it = g_achievements.achievements.find(achievementId);
        if (it != g_achievements.achievements.end()) {
            it->second.iconTexture = textureHandle;
        }
    }

    void Framework_Achievement_SetHidden(int achievementId, bool hidden) {
        auto it = g_achievements.achievements.find(achievementId);
        if (it != g_achievements.achievements.end()) {
            it->second.hidden = hidden;
        }
    }

    void Framework_Achievement_SetPoints(int achievementId, int points) {
        auto it = g_achievements.achievements.find(achievementId);
        if (it != g_achievements.achievements.end()) {
            it->second.points = points;
        }
    }

    void Framework_Achievement_SetProgressTarget(int achievementId, int target) {
        auto it = g_achievements.achievements.find(achievementId);
        if (it != g_achievements.achievements.end()) {
            it->second.progressTarget = target;
        }
    }

    void Framework_Achievement_SetProgress(int achievementId, int progress) {
        auto it = g_achievements.achievements.find(achievementId);
        if (it != g_achievements.achievements.end()) {
            it->second.progress = progress;
            // Auto-unlock if target reached
            if (it->second.progressTarget > 0 && it->second.progress >= it->second.progressTarget && !it->second.unlocked) {
                Framework_Achievement_Unlock(achievementId);
            }
        }
    }

    void Framework_Achievement_AddProgress(int achievementId, int amount) {
        auto it = g_achievements.achievements.find(achievementId);
        if (it != g_achievements.achievements.end()) {
            Framework_Achievement_SetProgress(achievementId, it->second.progress + amount);
        }
    }

    int Framework_Achievement_GetProgress(int achievementId) {
        auto it = g_achievements.achievements.find(achievementId);
        return (it != g_achievements.achievements.end()) ? it->second.progress : 0;
    }

    int Framework_Achievement_GetProgressTarget(int achievementId) {
        auto it = g_achievements.achievements.find(achievementId);
        return (it != g_achievements.achievements.end()) ? it->second.progressTarget : 0;
    }

    float Framework_Achievement_GetProgressPercent(int achievementId) {
        auto it = g_achievements.achievements.find(achievementId);
        if (it == g_achievements.achievements.end() || it->second.progressTarget <= 0) return 0.0f;
        return (float)it->second.progress / (float)it->second.progressTarget * 100.0f;
    }

    void Framework_Achievement_Unlock(int achievementId) {
        auto it = g_achievements.achievements.find(achievementId);
        if (it != g_achievements.achievements.end() && !it->second.unlocked) {
            it->second.unlocked = true;
            it->second.unlockTime = (float)GetTime();

            // Add notification
            if (g_achievements.notificationsEnabled) {
                AchievementNotification notif;
                notif.achievementId = achievementId;
                notif.timer = 0.0f;
                notif.duration = g_achievements.notificationDuration;
                g_achievements.notifications.push_back(notif);
            }

            // Callback
            if (g_achievements.onUnlocked) {
                g_achievements.onUnlocked(achievementId, it->second.name.c_str());
            }
        }
    }

    void Framework_Achievement_Lock(int achievementId) {
        auto it = g_achievements.achievements.find(achievementId);
        if (it != g_achievements.achievements.end()) {
            it->second.unlocked = false;
            it->second.progress = 0;
        }
    }

    bool Framework_Achievement_IsUnlocked(int achievementId) {
        auto it = g_achievements.achievements.find(achievementId);
        return (it != g_achievements.achievements.end()) ? it->second.unlocked : false;
    }

    int Framework_Achievement_GetState(int achievementId) {
        auto it = g_achievements.achievements.find(achievementId);
        if (it == g_achievements.achievements.end()) return ACHIEVEMENT_LOCKED;
        if (it->second.unlocked) return ACHIEVEMENT_UNLOCKED;
        if (it->second.hidden) return ACHIEVEMENT_HIDDEN;
        return ACHIEVEMENT_LOCKED;
    }

    int Framework_Achievement_GetByName(const char* id) {
        if (!id) return 0;
        for (const auto& kv : g_achievements.achievements) {
            if (kv.second.stringId == id) return kv.first;
        }
        return 0;
    }

    const char* Framework_Achievement_GetName(int achievementId) {
        auto it = g_achievements.achievements.find(achievementId);
        if (it == g_achievements.achievements.end()) return "";
        strncpy(g_achievementStringBuffer, it->second.name.c_str(), sizeof(g_achievementStringBuffer) - 1);
        return g_achievementStringBuffer;
    }

    const char* Framework_Achievement_GetDescription(int achievementId) {
        auto it = g_achievements.achievements.find(achievementId);
        if (it == g_achievements.achievements.end()) return "";
        strncpy(g_achievementStringBuffer, it->second.description.c_str(), sizeof(g_achievementStringBuffer) - 1);
        return g_achievementStringBuffer;
    }

    int Framework_Achievement_GetPoints(int achievementId) {
        auto it = g_achievements.achievements.find(achievementId);
        return (it != g_achievements.achievements.end()) ? it->second.points : 0;
    }

    int Framework_Achievement_GetCount() {
        return (int)g_achievements.achievements.size();
    }

    int Framework_Achievement_GetUnlockedCount() {
        int count = 0;
        for (const auto& kv : g_achievements.achievements) {
            if (kv.second.unlocked) count++;
        }
        return count;
    }

    int Framework_Achievement_GetTotalPoints() {
        int total = 0;
        for (const auto& kv : g_achievements.achievements) {
            total += kv.second.points;
        }
        return total;
    }

    int Framework_Achievement_GetEarnedPoints() {
        int earned = 0;
        for (const auto& kv : g_achievements.achievements) {
            if (kv.second.unlocked) earned += kv.second.points;
        }
        return earned;
    }

    void Framework_Achievement_SetNotificationsEnabled(bool enabled) {
        g_achievements.notificationsEnabled = enabled;
    }

    void Framework_Achievement_SetNotificationDuration(float seconds) {
        g_achievements.notificationDuration = seconds;
    }

    void Framework_Achievement_SetNotificationPosition(int x, int y) {
        g_achievements.notificationX = x;
        g_achievements.notificationY = y;
    }

    void Framework_Achievement_Update(float deltaTime) {
        for (auto it = g_achievements.notifications.begin(); it != g_achievements.notifications.end(); ) {
            it->timer += deltaTime;
            if (it->timer >= it->duration) {
                it = g_achievements.notifications.erase(it);
            } else {
                ++it;
            }
        }
    }

    void Framework_Achievement_DrawNotifications() {
        int y = g_achievements.notificationY;
        for (const auto& notif : g_achievements.notifications) {
            auto it = g_achievements.achievements.find(notif.achievementId);
            if (it == g_achievements.achievements.end()) continue;

            // Calculate fade
            float alpha = 1.0f;
            if (notif.timer < 0.3f) alpha = notif.timer / 0.3f;
            else if (notif.timer > notif.duration - 0.3f) alpha = (notif.duration - notif.timer) / 0.3f;

            unsigned char a = (unsigned char)(alpha * 255);

            // Draw notification box
            int boxWidth = 300;
            int boxHeight = 60;
            DrawRectangle(g_achievements.notificationX, y, boxWidth, boxHeight, { 40, 40, 40, a });
            DrawRectangleLines(g_achievements.notificationX, y, boxWidth, boxHeight, { 255, 215, 0, a });

            // Draw text
            DrawText("Achievement Unlocked!", g_achievements.notificationX + 10, y + 5, 12, { 255, 215, 0, a });
            DrawText(it->second.name.c_str(), g_achievements.notificationX + 10, y + 22, 16, { 255, 255, 255, a });
            DrawText(it->second.description.c_str(), g_achievements.notificationX + 10, y + 42, 10, { 180, 180, 180, a });

            y += boxHeight + 10;
        }
    }

    bool Framework_Achievement_Save(const char* filePath) {
        if (!filePath) return false;
        FILE* file = fopen(filePath, "w");
        if (!file) return false;

        for (const auto& kv : g_achievements.achievements) {
            fprintf(file, "%s:%d:%d\n", kv.second.stringId.c_str(), kv.second.unlocked ? 1 : 0, kv.second.progress);
        }

        fclose(file);
        return true;
    }

    bool Framework_Achievement_Load(const char* filePath) {
        if (!filePath) return false;
        FILE* file = fopen(filePath, "r");
        if (!file) return false;

        char line[256];
        while (fgets(line, sizeof(line), file)) {
            char stringId[128];
            int unlocked, progress;
            if (sscanf(line, "%127[^:]:%d:%d", stringId, &unlocked, &progress) == 3) {
                int achId = Framework_Achievement_GetByName(stringId);
                if (achId > 0) {
                    auto it = g_achievements.achievements.find(achId);
                    if (it != g_achievements.achievements.end()) {
                        it->second.unlocked = (unlocked != 0);
                        it->second.progress = progress;
                    }
                }
            }
        }

        fclose(file);
        return true;
    }

    void Framework_Achievement_ResetAll() {
        for (auto& kv : g_achievements.achievements) {
            kv.second.unlocked = false;
            kv.second.progress = 0;
        }
        g_achievements.notifications.clear();
    }

    void Framework_Achievement_SetOnUnlocked(AchievementUnlockedCallback callback) {
        g_achievements.onUnlocked = callback;
    }

    // ========================================================================
    // CUTSCENE SYSTEM
    // ========================================================================

    struct CutsceneCommand {
        int type;
        float duration;
        std::string stringParam1;
        std::string stringParam2;
        int intParam1 = 0;
        float floatParam1 = 0.0f;
        float floatParam2 = 0.0f;
        float floatParam3 = 0.0f;
        bool boolParam1 = false;
        CutsceneCallback callback = nullptr;
    };

    struct Cutscene {
        int id;
        std::string name;
        std::vector<CutsceneCommand> commands;
        int currentCommand = 0;
        float commandTimer = 0.0f;
        int state = CUTSCENE_STATE_IDLE;
        bool skippable = true;

        // Dialogue state
        std::string currentSpeaker;
        std::string currentText;
        float dialogueTimer = 0.0f;
        int displayedChars = 0;

        // Movement interpolation
        int movingEntity = 0;
        float moveStartX = 0, moveStartY = 0;
        float moveTargetX = 0, moveTargetY = 0;
        float moveDuration = 0;
        float moveTimer = 0;
    };

    struct CutsceneState {
        std::unordered_map<int, Cutscene> cutscenes;
        int nextId = 1;
        int activeCutscene = 0;
        CutsceneFinishedCallback onFinished = nullptr;

        // Dialogue display settings
        int dialogueFontHandle = 0;
        int dialogueBoxX = 50;
        int dialogueBoxY = 500;
        int dialogueBoxWidth = 700;
        int dialogueBoxHeight = 150;
        unsigned char dialogueBgR = 20, dialogueBgG = 20, dialogueBgB = 30, dialogueBgA = 230;
        unsigned char dialogueTextR = 255, dialogueTextG = 255, dialogueTextB = 255;
        float typewriterSpeed = 30.0f;
    };

    static CutsceneState g_cutscene;
    static char g_cutsceneStringBuffer[256];

    int Framework_Cutscene_Create(const char* name) {
        Cutscene cs;
        cs.id = g_cutscene.nextId++;
        cs.name = name ? name : "";
        g_cutscene.cutscenes[cs.id] = cs;
        return cs.id;
    }

    void Framework_Cutscene_Destroy(int cutsceneId) {
        g_cutscene.cutscenes.erase(cutsceneId);
        if (g_cutscene.activeCutscene == cutsceneId) {
            g_cutscene.activeCutscene = 0;
        }
    }

    int Framework_Cutscene_GetByName(const char* name) {
        if (!name) return 0;
        for (const auto& kv : g_cutscene.cutscenes) {
            if (kv.second.name == name) return kv.first;
        }
        return 0;
    }

    static Cutscene* GetCutscene(int id) {
        auto it = g_cutscene.cutscenes.find(id);
        return (it != g_cutscene.cutscenes.end()) ? &it->second : nullptr;
    }

    void Framework_Cutscene_AddWait(int cutsceneId, float duration) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_WAIT;
        cmd.duration = duration;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_AddDialogue(int cutsceneId, const char* speaker, const char* text, float duration) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_DIALOGUE;
        cmd.stringParam1 = speaker ? speaker : "";
        cmd.stringParam2 = text ? text : "";
        cmd.duration = duration;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_AddMoveActor(int cutsceneId, int entityId, float targetX, float targetY, float duration) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_MOVE_ACTOR;
        cmd.intParam1 = entityId;
        cmd.floatParam1 = targetX;
        cmd.floatParam2 = targetY;
        cmd.duration = duration;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_AddFadeIn(int cutsceneId, float duration) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_FADE_IN;
        cmd.duration = duration;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_AddFadeOut(int cutsceneId, float duration) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_FADE_OUT;
        cmd.duration = duration;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_AddPlaySound(int cutsceneId, int soundHandle) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_PLAY_SOUND;
        cmd.intParam1 = soundHandle;
        cmd.duration = 0.0f;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_AddPlayMusic(int cutsceneId, const char* musicPath) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_PLAY_MUSIC;
        cmd.stringParam1 = musicPath ? musicPath : "";
        cmd.duration = 0.0f;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_AddStopMusic(int cutsceneId, float fadeTime) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_STOP_MUSIC;
        cmd.duration = fadeTime;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_AddCameraPan(int cutsceneId, float targetX, float targetY, float duration) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_CAMERA_PAN;
        cmd.floatParam1 = targetX;
        cmd.floatParam2 = targetY;
        cmd.duration = duration;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_AddCameraZoom(int cutsceneId, float targetZoom, float duration) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_CAMERA_ZOOM;
        cmd.floatParam1 = targetZoom;
        cmd.duration = duration;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_AddShake(int cutsceneId, float intensity, float duration) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_SHAKE;
        cmd.floatParam1 = intensity;
        cmd.duration = duration;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_AddSetVisible(int cutsceneId, int entityId, bool visible) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_SET_VISIBLE;
        cmd.intParam1 = entityId;
        cmd.boolParam1 = visible;
        cmd.duration = 0.0f;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_AddAnimate(int cutsceneId, int entityId, const char* animationName) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_ANIMATE;
        cmd.intParam1 = entityId;
        cmd.stringParam1 = animationName ? animationName : "";
        cmd.duration = 0.0f;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_AddCallback(int cutsceneId, CutsceneCallback callback) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs) return;
        CutsceneCommand cmd;
        cmd.type = CUTSCENE_CMD_CALLBACK;
        cmd.callback = callback;
        cmd.duration = 0.0f;
        cs->commands.push_back(cmd);
    }

    void Framework_Cutscene_Play(int cutsceneId) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs || cs->commands.empty()) return;

        cs->state = CUTSCENE_STATE_PLAYING;
        cs->currentCommand = 0;
        cs->commandTimer = 0.0f;
        cs->dialogueTimer = 0.0f;
        cs->displayedChars = 0;
        g_cutscene.activeCutscene = cutsceneId;
    }

    void Framework_Cutscene_Pause(int cutsceneId) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (cs && cs->state == CUTSCENE_STATE_PLAYING) {
            cs->state = CUTSCENE_STATE_PAUSED;
        }
    }

    void Framework_Cutscene_Resume(int cutsceneId) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (cs && cs->state == CUTSCENE_STATE_PAUSED) {
            cs->state = CUTSCENE_STATE_PLAYING;
        }
    }

    void Framework_Cutscene_Stop(int cutsceneId) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (cs) {
            cs->state = CUTSCENE_STATE_IDLE;
            cs->currentCommand = 0;
            cs->commandTimer = 0.0f;
            if (g_cutscene.activeCutscene == cutsceneId) {
                g_cutscene.activeCutscene = 0;
            }
        }
    }

    void Framework_Cutscene_Skip(int cutsceneId) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (cs && cs->skippable) {
            cs->state = CUTSCENE_STATE_FINISHED;
            if (g_cutscene.onFinished) {
                g_cutscene.onFinished(cutsceneId);
            }
            if (g_cutscene.activeCutscene == cutsceneId) {
                g_cutscene.activeCutscene = 0;
            }
        }
    }

    void Framework_Cutscene_SetSkippable(int cutsceneId, bool skippable) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (cs) cs->skippable = skippable;
    }

    int Framework_Cutscene_GetState(int cutsceneId) {
        Cutscene* cs = GetCutscene(cutsceneId);
        return cs ? cs->state : CUTSCENE_STATE_IDLE;
    }

    bool Framework_Cutscene_IsPlaying(int cutsceneId) {
        return Framework_Cutscene_GetState(cutsceneId) == CUTSCENE_STATE_PLAYING;
    }

    bool Framework_Cutscene_IsPaused(int cutsceneId) {
        return Framework_Cutscene_GetState(cutsceneId) == CUTSCENE_STATE_PAUSED;
    }

    bool Framework_Cutscene_IsFinished(int cutsceneId) {
        return Framework_Cutscene_GetState(cutsceneId) == CUTSCENE_STATE_FINISHED;
    }

    float Framework_Cutscene_GetProgress(int cutsceneId) {
        Cutscene* cs = GetCutscene(cutsceneId);
        if (!cs || cs->commands.empty()) return 0.0f;
        return (float)cs->currentCommand / (float)cs->commands.size();
    }

    int Framework_Cutscene_GetCurrentCommand(int cutsceneId) {
        Cutscene* cs = GetCutscene(cutsceneId);
        return cs ? cs->currentCommand : 0;
    }

    int Framework_Cutscene_GetCommandCount(int cutsceneId) {
        Cutscene* cs = GetCutscene(cutsceneId);
        return cs ? (int)cs->commands.size() : 0;
    }

    void Framework_Cutscene_Update(float deltaTime) {
        if (g_cutscene.activeCutscene == 0) return;

        Cutscene* cs = GetCutscene(g_cutscene.activeCutscene);
        if (!cs || cs->state != CUTSCENE_STATE_PLAYING) return;

        if (cs->currentCommand >= (int)cs->commands.size()) {
            cs->state = CUTSCENE_STATE_FINISHED;
            if (g_cutscene.onFinished) {
                g_cutscene.onFinished(cs->id);
            }
            g_cutscene.activeCutscene = 0;
            return;
        }

        CutsceneCommand& cmd = cs->commands[cs->currentCommand];
        cs->commandTimer += deltaTime;

        // Handle command types
        switch (cmd.type) {
            case CUTSCENE_CMD_WAIT:
                if (cs->commandTimer >= cmd.duration) {
                    cs->currentCommand++;
                    cs->commandTimer = 0.0f;
                }
                break;

            case CUTSCENE_CMD_DIALOGUE:
                cs->currentSpeaker = cmd.stringParam1;
                cs->currentText = cmd.stringParam2;
                cs->dialogueTimer += deltaTime;
                cs->displayedChars = (int)(cs->dialogueTimer * g_cutscene.typewriterSpeed);
                if (cs->displayedChars > (int)cs->currentText.length()) {
                    cs->displayedChars = (int)cs->currentText.length();
                }
                if (cs->commandTimer >= cmd.duration) {
                    cs->currentCommand++;
                    cs->commandTimer = 0.0f;
                    cs->dialogueTimer = 0.0f;
                    cs->currentSpeaker.clear();
                    cs->currentText.clear();
                }
                break;

            case CUTSCENE_CMD_MOVE_ACTOR:
                if (cs->commandTimer == deltaTime) {
                    // Start of move
                    cs->movingEntity = cmd.intParam1;
                    auto it = g_transform2D.find(cmd.intParam1);
                    if (it != g_transform2D.end()) {
                        cs->moveStartX = it->second.position.x;
                        cs->moveStartY = it->second.position.y;
                    }
                    cs->moveTargetX = cmd.floatParam1;
                    cs->moveTargetY = cmd.floatParam2;
                    cs->moveDuration = cmd.duration;
                    cs->moveTimer = 0.0f;
                }
                cs->moveTimer += deltaTime;
                {
                    float t = cs->moveTimer / cs->moveDuration;
                    if (t > 1.0f) t = 1.0f;
                    float x = cs->moveStartX + (cs->moveTargetX - cs->moveStartX) * t;
                    float y = cs->moveStartY + (cs->moveTargetY - cs->moveStartY) * t;
                    auto it = g_transform2D.find(cs->movingEntity);
                    if (it != g_transform2D.end()) {
                        it->second.position.x = x;
                        it->second.position.y = y;
                    }
                }
                if (cs->commandTimer >= cmd.duration) {
                    cs->currentCommand++;
                    cs->commandTimer = 0.0f;
                }
                break;

            case CUTSCENE_CMD_FADE_IN:
                Framework_Effects_FadeIn(cmd.duration);
                cs->currentCommand++;
                cs->commandTimer = 0.0f;
                break;

            case CUTSCENE_CMD_FADE_OUT:
                Framework_Effects_FadeOut(cmd.duration);
                cs->currentCommand++;
                cs->commandTimer = 0.0f;
                break;

            case CUTSCENE_CMD_PLAY_SOUND:
                // Play sound via handle
                {
                    auto sit = g_sounds.find(cmd.intParam1);
                    if (sit != g_sounds.end() && sit->second.valid) {
                        PlaySound(sit->second.snd);
                    }
                }
                cs->currentCommand++;
                cs->commandTimer = 0.0f;
                break;

            case CUTSCENE_CMD_SHAKE:
                Framework_Effects_Shake(cmd.floatParam1, cmd.duration);
                cs->currentCommand++;
                cs->commandTimer = 0.0f;
                break;

            case CUTSCENE_CMD_SET_VISIBLE:
                // Toggle visibility would need entity visibility component
                cs->currentCommand++;
                cs->commandTimer = 0.0f;
                break;

            case CUTSCENE_CMD_CALLBACK:
                if (cmd.callback) cmd.callback();
                cs->currentCommand++;
                cs->commandTimer = 0.0f;
                break;

            default:
                cs->currentCommand++;
                cs->commandTimer = 0.0f;
                break;
        }
    }

    void Framework_Cutscene_DrawDialogue() {
        if (g_cutscene.activeCutscene == 0) return;

        Cutscene* cs = GetCutscene(g_cutscene.activeCutscene);
        if (!cs || cs->currentText.empty()) return;

        // Draw dialogue box
        DrawRectangle(g_cutscene.dialogueBoxX, g_cutscene.dialogueBoxY,
                      g_cutscene.dialogueBoxWidth, g_cutscene.dialogueBoxHeight,
                      { g_cutscene.dialogueBgR, g_cutscene.dialogueBgG, g_cutscene.dialogueBgB, g_cutscene.dialogueBgA });
        DrawRectangleLines(g_cutscene.dialogueBoxX, g_cutscene.dialogueBoxY,
                           g_cutscene.dialogueBoxWidth, g_cutscene.dialogueBoxHeight, WHITE);

        // Draw speaker name
        if (!cs->currentSpeaker.empty()) {
            DrawText(cs->currentSpeaker.c_str(), g_cutscene.dialogueBoxX + 15, g_cutscene.dialogueBoxY + 10, 20,
                     { g_cutscene.dialogueTextR, g_cutscene.dialogueTextG, g_cutscene.dialogueTextB, 255 });
        }

        // Draw text with typewriter effect
        std::string displayText = cs->currentText.substr(0, cs->displayedChars);
        DrawText(displayText.c_str(), g_cutscene.dialogueBoxX + 15, g_cutscene.dialogueBoxY + 40, 16,
                 { g_cutscene.dialogueTextR, g_cutscene.dialogueTextG, g_cutscene.dialogueTextB, 255 });
    }

    void Framework_Cutscene_SetDialogueFont(int fontHandle) {
        g_cutscene.dialogueFontHandle = fontHandle;
    }

    void Framework_Cutscene_SetDialogueBox(int x, int y, int width, int height) {
        g_cutscene.dialogueBoxX = x;
        g_cutscene.dialogueBoxY = y;
        g_cutscene.dialogueBoxWidth = width;
        g_cutscene.dialogueBoxHeight = height;
    }

    void Framework_Cutscene_SetDialogueColors(unsigned char bgR, unsigned char bgG, unsigned char bgB, unsigned char bgA,
                                               unsigned char textR, unsigned char textG, unsigned char textB) {
        g_cutscene.dialogueBgR = bgR;
        g_cutscene.dialogueBgG = bgG;
        g_cutscene.dialogueBgB = bgB;
        g_cutscene.dialogueBgA = bgA;
        g_cutscene.dialogueTextR = textR;
        g_cutscene.dialogueTextG = textG;
        g_cutscene.dialogueTextB = textB;
    }

    void Framework_Cutscene_SetTypewriterSpeed(float charsPerSecond) {
        g_cutscene.typewriterSpeed = charsPerSecond;
    }

    void Framework_Cutscene_SetOnFinished(CutsceneFinishedCallback callback) {
        g_cutscene.onFinished = callback;
    }

    // ========================================================================
    // LEADERBOARD SYSTEM
    // ========================================================================

    struct LeaderboardEntry {
        std::string playerName;
        int score;
        std::string metadata;
        std::string date;
    };

    struct Leaderboard {
        int id;
        std::string name;
        int sortOrder;
        int maxEntries;
        std::vector<LeaderboardEntry> entries;
    };

    struct LeaderboardState {
        std::unordered_map<int, Leaderboard> leaderboards;
        int nextId = 1;
    };

    static LeaderboardState g_leaderboards;
    static char g_leaderboardStringBuffer[256];

    static std::string GetCurrentDateString() {
        time_t now = time(nullptr);
        struct tm* t = localtime(&now);
        char buf[64];
        strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", t);
        return buf;
    }

    int Framework_Leaderboard_Create(const char* name, int sortOrder, int maxEntries) {
        Leaderboard lb;
        lb.id = g_leaderboards.nextId++;
        lb.name = name ? name : "";
        lb.sortOrder = sortOrder;
        lb.maxEntries = maxEntries > 0 ? maxEntries : 100;
        g_leaderboards.leaderboards[lb.id] = lb;
        return lb.id;
    }

    void Framework_Leaderboard_Destroy(int leaderboardId) {
        g_leaderboards.leaderboards.erase(leaderboardId);
    }

    int Framework_Leaderboard_GetByName(const char* name) {
        if (!name) return 0;
        for (const auto& kv : g_leaderboards.leaderboards) {
            if (kv.second.name == name) return kv.first;
        }
        return 0;
    }

    void Framework_Leaderboard_Clear(int leaderboardId) {
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it != g_leaderboards.leaderboards.end()) {
            it->second.entries.clear();
        }
    }

    static void SortLeaderboard(Leaderboard& lb) {
        if (lb.sortOrder == LEADERBOARD_SORT_DESC) {
            std::sort(lb.entries.begin(), lb.entries.end(),
                      [](const LeaderboardEntry& a, const LeaderboardEntry& b) { return a.score > b.score; });
        } else {
            std::sort(lb.entries.begin(), lb.entries.end(),
                      [](const LeaderboardEntry& a, const LeaderboardEntry& b) { return a.score < b.score; });
        }
        // Trim to max entries
        if ((int)lb.entries.size() > lb.maxEntries) {
            lb.entries.resize(lb.maxEntries);
        }
    }

    int Framework_Leaderboard_SubmitScore(int leaderboardId, const char* playerName, int score) {
        return Framework_Leaderboard_SubmitScoreEx(leaderboardId, playerName, score, "");
    }

    int Framework_Leaderboard_SubmitScoreEx(int leaderboardId, const char* playerName, int score, const char* metadata) {
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end()) return -1;

        LeaderboardEntry entry;
        entry.playerName = playerName ? playerName : "Anonymous";
        entry.score = score;
        entry.metadata = metadata ? metadata : "";
        entry.date = GetCurrentDateString();

        it->second.entries.push_back(entry);
        SortLeaderboard(it->second);

        // Return rank (1-based)
        for (int i = 0; i < (int)it->second.entries.size(); i++) {
            if (it->second.entries[i].playerName == entry.playerName &&
                it->second.entries[i].score == entry.score &&
                it->second.entries[i].date == entry.date) {
                return i + 1;
            }
        }
        return -1;
    }

    bool Framework_Leaderboard_IsHighScore(int leaderboardId, int score) {
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end()) return false;

        if (it->second.entries.empty()) return true;
        if ((int)it->second.entries.size() < it->second.maxEntries) return true;

        // Check if score would make the leaderboard
        int worstScore = it->second.entries.back().score;
        if (it->second.sortOrder == LEADERBOARD_SORT_DESC) {
            return score > worstScore;
        } else {
            return score < worstScore;
        }
    }

    int Framework_Leaderboard_GetRankForScore(int leaderboardId, int score) {
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end()) return -1;

        int rank = 1;
        for (const auto& entry : it->second.entries) {
            if (it->second.sortOrder == LEADERBOARD_SORT_DESC) {
                if (score > entry.score) return rank;
            } else {
                if (score < entry.score) return rank;
            }
            rank++;
        }
        return rank;
    }

    int Framework_Leaderboard_GetEntryCount(int leaderboardId) {
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        return (it != g_leaderboards.leaderboards.end()) ? (int)it->second.entries.size() : 0;
    }

    const char* Framework_Leaderboard_GetEntryName(int leaderboardId, int rank) {
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end()) return "";
        int idx = rank - 1;
        if (idx < 0 || idx >= (int)it->second.entries.size()) return "";
        strncpy(g_leaderboardStringBuffer, it->second.entries[idx].playerName.c_str(), sizeof(g_leaderboardStringBuffer) - 1);
        return g_leaderboardStringBuffer;
    }

    int Framework_Leaderboard_GetEntryScore(int leaderboardId, int rank) {
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end()) return 0;
        int idx = rank - 1;
        if (idx < 0 || idx >= (int)it->second.entries.size()) return 0;
        return it->second.entries[idx].score;
    }

    const char* Framework_Leaderboard_GetEntryMetadata(int leaderboardId, int rank) {
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end()) return "";
        int idx = rank - 1;
        if (idx < 0 || idx >= (int)it->second.entries.size()) return "";
        strncpy(g_leaderboardStringBuffer, it->second.entries[idx].metadata.c_str(), sizeof(g_leaderboardStringBuffer) - 1);
        return g_leaderboardStringBuffer;
    }

    const char* Framework_Leaderboard_GetEntryDate(int leaderboardId, int rank) {
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end()) return "";
        int idx = rank - 1;
        if (idx < 0 || idx >= (int)it->second.entries.size()) return "";
        strncpy(g_leaderboardStringBuffer, it->second.entries[idx].date.c_str(), sizeof(g_leaderboardStringBuffer) - 1);
        return g_leaderboardStringBuffer;
    }

    int Framework_Leaderboard_GetPlayerRank(int leaderboardId, const char* playerName) {
        if (!playerName) return -1;
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end()) return -1;

        for (int i = 0; i < (int)it->second.entries.size(); i++) {
            if (it->second.entries[i].playerName == playerName) {
                return i + 1;
            }
        }
        return -1;
    }

    int Framework_Leaderboard_GetPlayerBestScore(int leaderboardId, const char* playerName) {
        if (!playerName) return 0;
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end()) return 0;

        bool found = false;
        int best = 0;
        for (const auto& entry : it->second.entries) {
            if (entry.playerName == playerName) {
                if (!found) {
                    best = entry.score;
                    found = true;
                } else if (it->second.sortOrder == LEADERBOARD_SORT_DESC) {
                    if (entry.score > best) best = entry.score;
                } else {
                    if (entry.score < best) best = entry.score;
                }
            }
        }
        return best;
    }

    int Framework_Leaderboard_GetPlayerEntryCount(int leaderboardId, const char* playerName) {
        if (!playerName) return 0;
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end()) return 0;

        int count = 0;
        for (const auto& entry : it->second.entries) {
            if (entry.playerName == playerName) count++;
        }
        return count;
    }

    int Framework_Leaderboard_GetTopScore(int leaderboardId) {
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end() || it->second.entries.empty()) return 0;
        return it->second.entries[0].score;
    }

    const char* Framework_Leaderboard_GetTopPlayer(int leaderboardId) {
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end() || it->second.entries.empty()) return "";
        strncpy(g_leaderboardStringBuffer, it->second.entries[0].playerName.c_str(), sizeof(g_leaderboardStringBuffer) - 1);
        return g_leaderboardStringBuffer;
    }

    bool Framework_Leaderboard_Save(int leaderboardId, const char* filePath) {
        if (!filePath) return false;
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end()) return false;

        FILE* file = fopen(filePath, "w");
        if (!file) return false;

        fprintf(file, "# Leaderboard: %s\n", it->second.name.c_str());
        fprintf(file, "# SortOrder: %d\n", it->second.sortOrder);
        for (const auto& entry : it->second.entries) {
            fprintf(file, "%s|%d|%s|%s\n", entry.playerName.c_str(), entry.score, entry.metadata.c_str(), entry.date.c_str());
        }

        fclose(file);
        return true;
    }

    bool Framework_Leaderboard_Load(int leaderboardId, const char* filePath) {
        if (!filePath) return false;
        auto it = g_leaderboards.leaderboards.find(leaderboardId);
        if (it == g_leaderboards.leaderboards.end()) return false;

        FILE* file = fopen(filePath, "r");
        if (!file) return false;

        it->second.entries.clear();

        char line[512];
        while (fgets(line, sizeof(line), file)) {
            if (line[0] == '#' || line[0] == '\n') continue;

            char name[128], metadata[128], date[64];
            int score;
            if (sscanf(line, "%127[^|]|%d|%127[^|]|%63[^\n]", name, &score, metadata, date) >= 2) {
                LeaderboardEntry entry;
                entry.playerName = name;
                entry.score = score;
                entry.metadata = metadata;
                entry.date = date;
                it->second.entries.push_back(entry);
            }
        }

        fclose(file);
        SortLeaderboard(it->second);
        return true;
    }

    bool Framework_Leaderboard_SaveAll(const char* filePath) {
        if (!filePath) return false;
        FILE* file = fopen(filePath, "w");
        if (!file) return false;

        for (const auto& kv : g_leaderboards.leaderboards) {
            fprintf(file, "[%s]\n", kv.second.name.c_str());
            fprintf(file, "sortOrder=%d\n", kv.second.sortOrder);
            fprintf(file, "maxEntries=%d\n", kv.second.maxEntries);
            for (const auto& entry : kv.second.entries) {
                fprintf(file, "entry=%s|%d|%s|%s\n", entry.playerName.c_str(), entry.score, entry.metadata.c_str(), entry.date.c_str());
            }
            fprintf(file, "\n");
        }

        fclose(file);
        return true;
    }

    bool Framework_Leaderboard_LoadAll(const char* filePath) {
        if (!filePath) return false;
        FILE* file = fopen(filePath, "r");
        if (!file) return false;

        char line[512];
        Leaderboard* currentLb = nullptr;

        while (fgets(line, sizeof(line), file)) {
            // Remove newline
            size_t len = strlen(line);
            while (len > 0 && (line[len-1] == '\n' || line[len-1] == '\r')) line[--len] = '\0';

            if (line[0] == '[') {
                // New leaderboard
                char name[128];
                if (sscanf(line, "[%127[^]]]", name) == 1) {
                    int id = Framework_Leaderboard_Create(name, LEADERBOARD_SORT_DESC, 100);
                    currentLb = &g_leaderboards.leaderboards[id];
                }
            } else if (currentLb && strncmp(line, "sortOrder=", 10) == 0) {
                currentLb->sortOrder = atoi(line + 10);
            } else if (currentLb && strncmp(line, "maxEntries=", 11) == 0) {
                currentLb->maxEntries = atoi(line + 11);
            } else if (currentLb && strncmp(line, "entry=", 6) == 0) {
                char name[128], metadata[128], date[64];
                int score;
                if (sscanf(line + 6, "%127[^|]|%d|%127[^|]|%63s", name, &score, metadata, date) >= 2) {
                    LeaderboardEntry entry;
                    entry.playerName = name;
                    entry.score = score;
                    entry.metadata = metadata;
                    entry.date = date;
                    currentLb->entries.push_back(entry);
                }
            }
        }

        fclose(file);

        // Sort all loaded leaderboards
        for (auto& kv : g_leaderboards.leaderboards) {
            SortLeaderboard(kv.second);
        }

        return true;
    }

    int Framework_Leaderboard_GetCount() {
        return (int)g_leaderboards.leaderboards.size();
    }

    void Framework_Leaderboard_DestroyAll() {
        g_leaderboards.leaderboards.clear();
        g_leaderboards.nextId = 1;
    }

    // ========================================================================
    // SPRITE BATCHING SYSTEM
    // ========================================================================

    namespace {
        struct BatchSprite {
            int textureHandle;
            Rectangle dest;
            Rectangle src;
            Vector2 origin;
            float rotation;
            Color tint;
        };

        struct SpriteBatch {
            int id = 0;
            std::vector<BatchSprite> sprites;
            int maxSprites = 10000;
            bool autoCull = true;
            int lastDrawCalls = 0;
        };

        std::unordered_map<int, SpriteBatch> g_batches;
        int g_nextBatchId = 1;

        constexpr int MAX_BATCHES = 100;          // Max simultaneous batches
        constexpr int MAX_BATCH_SPRITES = 100000; // Max sprites per batch

        SpriteBatch* GetBatch(int id) {
            auto it = g_batches.find(id);
            return (it != g_batches.end()) ? &it->second : nullptr;
        }
    }

    int Framework_Batch_Create(int maxSprites) {
        // Prevent excessive batch creation
        if ((int)g_batches.size() >= MAX_BATCHES) {
            return -1;
        }
        SpriteBatch batch;
        batch.id = g_nextBatchId++;
        // Clamp maxSprites to reasonable limits
        if (maxSprites <= 0) maxSprites = 10000;
        if (maxSprites > MAX_BATCH_SPRITES) maxSprites = MAX_BATCH_SPRITES;
        batch.maxSprites = maxSprites;
        batch.sprites.reserve(batch.maxSprites);
        g_batches[batch.id] = batch;
        return batch.id;
    }

    void Framework_Batch_Destroy(int batchId) {
        g_batches.erase(batchId);
    }

    void Framework_Batch_DestroyAll() {
        g_batches.clear();
    }

    void Framework_Batch_Clear(int batchId) {
        if (auto* batch = GetBatch(batchId)) {
            batch->sprites.clear();
        }
    }

    bool Framework_Batch_IsValid(int batchId) {
        return g_batches.find(batchId) != g_batches.end();
    }

    void Framework_Batch_AddSprite(int batchId, int textureHandle,
        float destX, float destY, float destW, float destH,
        float srcX, float srcY, float srcW, float srcH,
        float rotation, float originX, float originY,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {

        auto* batch = GetBatch(batchId);
        if (!batch || (int)batch->sprites.size() >= batch->maxSprites) return;

        BatchSprite sprite;
        sprite.textureHandle = textureHandle;
        sprite.dest = { destX, destY, destW, destH };
        sprite.src = { srcX, srcY, srcW, srcH };
        sprite.origin = { originX, originY };
        sprite.rotation = rotation;
        sprite.tint = { r, g, b, a };
        batch->sprites.push_back(sprite);
    }

    void Framework_Batch_AddSpriteSimple(int batchId, int textureHandle,
        float x, float y, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {

        auto* batch = GetBatch(batchId);
        if (!batch || (int)batch->sprites.size() >= batch->maxSprites) return;

        auto texIt = g_texByHandle.find(textureHandle);
        if (texIt == g_texByHandle.end() || !texIt->second.valid) return;

        Texture2D& tex = texIt->second.tex;
        BatchSprite sprite;
        sprite.textureHandle = textureHandle;
        sprite.dest = { x, y, (float)tex.width, (float)tex.height };
        sprite.src = { 0, 0, (float)tex.width, (float)tex.height };
        sprite.origin = { 0, 0 };
        sprite.rotation = 0;
        sprite.tint = { r, g, b, a };
        batch->sprites.push_back(sprite);
    }

    void Framework_Batch_Draw(int batchId) {
        auto* batch = GetBatch(batchId);
        if (!batch) return;

        batch->lastDrawCalls = 0;
        for (auto& sprite : batch->sprites) {
            auto texIt = g_texByHandle.find(sprite.textureHandle);
            if (texIt == g_texByHandle.end() || !texIt->second.valid) continue;

            DrawTexturePro(texIt->second.tex, sprite.src, sprite.dest, sprite.origin, sprite.rotation, sprite.tint);
            batch->lastDrawCalls++;
        }
    }

    void Framework_Batch_DrawSorted(int batchId) {
        auto* batch = GetBatch(batchId);
        if (!batch) return;

        std::sort(batch->sprites.begin(), batch->sprites.end(),
            [](const BatchSprite& a, const BatchSprite& b) {
                return a.textureHandle < b.textureHandle;
            });

        batch->lastDrawCalls = 0;
        int currentTex = -1;
        for (auto& sprite : batch->sprites) {
            auto texIt = g_texByHandle.find(sprite.textureHandle);
            if (texIt == g_texByHandle.end() || !texIt->second.valid) continue;

            if (sprite.textureHandle != currentTex) {
                currentTex = sprite.textureHandle;
                batch->lastDrawCalls++;
            }
            DrawTexturePro(texIt->second.tex, sprite.src, sprite.dest, sprite.origin, sprite.rotation, sprite.tint);
        }
    }

    int Framework_Batch_GetSpriteCount(int batchId) {
        auto* batch = GetBatch(batchId);
        return batch ? (int)batch->sprites.size() : 0;
    }

    int Framework_Batch_GetDrawCallCount(int batchId) {
        auto* batch = GetBatch(batchId);
        return batch ? batch->lastDrawCalls : 0;
    }

    void Framework_Batch_SetAutoCull(int batchId, bool enabled) {
        if (auto* batch = GetBatch(batchId)) batch->autoCull = enabled;
    }

    bool Framework_Batch_GetAutoCull(int batchId) {
        auto* batch = GetBatch(batchId);
        return batch ? batch->autoCull : false;
    }

    // ========================================================================
    // TEXTURE ATLAS SYSTEM
    // ========================================================================

    namespace {
        struct AtlasSprite {
            std::string name;
            Rectangle rect;
        };

        struct TextureAtlas {
            int id = 0;
            int width = 1024;
            int height = 1024;
            int textureHandle = -1;
            std::vector<AtlasSprite> sprites;
            std::unordered_map<std::string, int> spriteByName;
            bool packed = false;
            Image atlasImage;
            int cursorX = 0, cursorY = 0, rowHeight = 0;
        };

        std::unordered_map<int, TextureAtlas> g_atlases;
        int g_nextAtlasId = 1;
        static char s_atlasNameBuf[256] = {0};

        TextureAtlas* GetAtlas(int id) {
            auto it = g_atlases.find(id);
            return (it != g_atlases.end()) ? &it->second : nullptr;
        }
    }

    int Framework_Atlas_Create(int width, int height) {
        TextureAtlas atlas;
        atlas.id = g_nextAtlasId++;
        atlas.width = width > 0 ? width : 1024;
        atlas.height = height > 0 ? height : 1024;
        atlas.atlasImage = GenImageColor(atlas.width, atlas.height, BLANK);
        g_atlases[atlas.id] = atlas;
        return atlas.id;
    }

    void Framework_Atlas_Destroy(int atlasId) {
        auto* atlas = GetAtlas(atlasId);
        if (atlas) {
            if (atlas->atlasImage.data) UnloadImage(atlas->atlasImage);
            g_atlases.erase(atlasId);
        }
    }

    bool Framework_Atlas_IsValid(int atlasId) {
        return g_atlases.find(atlasId) != g_atlases.end();
    }

    int Framework_Atlas_AddImage(int atlasId, const char* imagePath) {
        auto* atlas = GetAtlas(atlasId);
        if (!atlas || atlas->packed || !imagePath) return -1;

        Image img = LoadImage(imagePath);
        if (!img.data) return -1;

        if (atlas->cursorX + img.width > atlas->width) {
            atlas->cursorX = 0;
            atlas->cursorY += atlas->rowHeight + 1;
            atlas->rowHeight = 0;
        }
        if (atlas->cursorY + img.height > atlas->height) {
            UnloadImage(img);
            return -1;
        }

        ImageDraw(&atlas->atlasImage, img,
            { 0, 0, (float)img.width, (float)img.height },
            { (float)atlas->cursorX, (float)atlas->cursorY, (float)img.width, (float)img.height },
            WHITE);

        AtlasSprite sprite;
        sprite.name = imagePath;
        sprite.rect = { (float)atlas->cursorX, (float)atlas->cursorY, (float)img.width, (float)img.height };
        int idx = (int)atlas->sprites.size();
        atlas->spriteByName[imagePath] = idx;
        atlas->sprites.push_back(sprite);

        atlas->cursorX += img.width + 1;
        if (img.height > atlas->rowHeight) atlas->rowHeight = img.height;

        UnloadImage(img);
        return idx;
    }

    int Framework_Atlas_AddRegion(int atlasId, int textureHandle, int srcX, int srcY, int srcW, int srcH) {
        return Framework_Atlas_AddRegionNamed(atlasId, "", textureHandle, srcX, srcY, srcW, srcH);
    }

    int Framework_Atlas_AddRegionNamed(int atlasId, const char* name, int textureHandle, int srcX, int srcY, int srcW, int srcH) {
        auto* atlas = GetAtlas(atlasId);
        if (!atlas || atlas->packed) return -1;

        auto texIt = g_texByHandle.find(textureHandle);
        if (texIt == g_texByHandle.end() || !texIt->second.valid) return -1;

        Image img = LoadImageFromTexture(texIt->second.tex);
        Image region = ImageFromImage(img, { (float)srcX, (float)srcY, (float)srcW, (float)srcH });
        UnloadImage(img);

        if (atlas->cursorX + srcW > atlas->width) {
            atlas->cursorX = 0;
            atlas->cursorY += atlas->rowHeight + 1;
            atlas->rowHeight = 0;
        }
        if (atlas->cursorY + srcH > atlas->height) {
            UnloadImage(region);
            return -1;
        }

        ImageDraw(&atlas->atlasImage, region,
            { 0, 0, (float)srcW, (float)srcH },
            { (float)atlas->cursorX, (float)atlas->cursorY, (float)srcW, (float)srcH },
            WHITE);

        AtlasSprite sprite;
        sprite.name = name ? name : "";
        sprite.rect = { (float)atlas->cursorX, (float)atlas->cursorY, (float)srcW, (float)srcH };
        int idx = (int)atlas->sprites.size();
        if (name && strlen(name) > 0) atlas->spriteByName[name] = idx;
        atlas->sprites.push_back(sprite);

        atlas->cursorX += srcW + 1;
        if (srcH > atlas->rowHeight) atlas->rowHeight = srcH;

        UnloadImage(region);
        return idx;
    }

    bool Framework_Atlas_Pack(int atlasId) {
        auto* atlas = GetAtlas(atlasId);
        if (!atlas || atlas->packed) return false;

        Texture2D tex = LoadTextureFromImage(atlas->atlasImage);
        atlas->textureHandle = g_nextTexHandle++;
        TexEntry entry;
        entry.tex = tex;
        entry.valid = true;
        entry.refCount = 1;
        g_texByHandle[atlas->textureHandle] = entry;
        atlas->packed = true;
        return true;
    }

    void Framework_Atlas_GetSpriteRect(int atlasId, int spriteIndex, float* x, float* y, float* w, float* h) {
        auto* atlas = GetAtlas(atlasId);
        if (!atlas || spriteIndex < 0 || spriteIndex >= (int)atlas->sprites.size()) {
            if (x) *x = 0; if (y) *y = 0; if (w) *w = 0; if (h) *h = 0;
            return;
        }
        auto& spr = atlas->sprites[spriteIndex];
        if (x) *x = spr.rect.x;
        if (y) *y = spr.rect.y;
        if (w) *w = spr.rect.width;
        if (h) *h = spr.rect.height;
    }

    int Framework_Atlas_GetSpriteCount(int atlasId) {
        auto* atlas = GetAtlas(atlasId);
        return atlas ? (int)atlas->sprites.size() : 0;
    }

    int Framework_Atlas_GetTextureHandle(int atlasId) {
        auto* atlas = GetAtlas(atlasId);
        return atlas ? atlas->textureHandle : -1;
    }

    int Framework_Atlas_GetSpriteByName(int atlasId, const char* name) {
        auto* atlas = GetAtlas(atlasId);
        if (!atlas || !name) return -1;
        auto it = atlas->spriteByName.find(name);
        return (it != atlas->spriteByName.end()) ? it->second : -1;
    }

    const char* Framework_Atlas_GetSpriteName(int atlasId, int spriteIndex) {
        auto* atlas = GetAtlas(atlasId);
        if (!atlas || spriteIndex < 0 || spriteIndex >= (int)atlas->sprites.size()) return "";
        strncpy(s_atlasNameBuf, atlas->sprites[spriteIndex].name.c_str(), sizeof(s_atlasNameBuf) - 1);
        return s_atlasNameBuf;
    }

    void Framework_Atlas_DrawSprite(int atlasId, int spriteIndex, float x, float y,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto* atlas = GetAtlas(atlasId);
        if (!atlas || !atlas->packed || spriteIndex < 0 || spriteIndex >= (int)atlas->sprites.size()) return;

        auto texIt = g_texByHandle.find(atlas->textureHandle);
        if (texIt == g_texByHandle.end() || !texIt->second.valid) return;

        auto& spr = atlas->sprites[spriteIndex];
        DrawTextureRec(texIt->second.tex, spr.rect, { x, y }, { r, g, b, a });
    }

    void Framework_Atlas_DrawSpriteEx(int atlasId, int spriteIndex, float x, float y,
        float rotation, float scale, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto* atlas = GetAtlas(atlasId);
        if (!atlas || !atlas->packed || spriteIndex < 0 || spriteIndex >= (int)atlas->sprites.size()) return;

        auto texIt = g_texByHandle.find(atlas->textureHandle);
        if (texIt == g_texByHandle.end() || !texIt->second.valid) return;

        auto& spr = atlas->sprites[spriteIndex];
        Rectangle dest = { x, y, spr.rect.width * scale, spr.rect.height * scale };
        DrawTexturePro(texIt->second.tex, spr.rect, dest, { 0, 0 }, rotation, { r, g, b, a });
    }

    void Framework_Atlas_DrawSpritePro(int atlasId, int spriteIndex,
        float destX, float destY, float destW, float destH, float originX, float originY, float rotation,
        unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto* atlas = GetAtlas(atlasId);
        if (!atlas || !atlas->packed || spriteIndex < 0 || spriteIndex >= (int)atlas->sprites.size()) return;

        auto texIt = g_texByHandle.find(atlas->textureHandle);
        if (texIt == g_texByHandle.end() || !texIt->second.valid) return;

        auto& spr = atlas->sprites[spriteIndex];
        Rectangle dest = { destX, destY, destW, destH };
        DrawTexturePro(texIt->second.tex, spr.rect, dest, { originX, originY }, rotation, { r, g, b, a });
    }

    int Framework_Atlas_LoadFromFile(const char* jsonPath, const char* imagePath) {
        if (!imagePath) return -1;
        Image img = LoadImage(imagePath);
        if (!img.data) return -1;

        TextureAtlas atlas;
        atlas.id = g_nextAtlasId++;
        atlas.width = img.width;
        atlas.height = img.height;
        atlas.atlasImage = img;

        Texture2D tex = LoadTextureFromImage(img);
        atlas.textureHandle = g_nextTexHandle++;
        TexEntry entry;
        entry.tex = tex;
        entry.valid = true;
        entry.refCount = 1;
        g_texByHandle[atlas.textureHandle] = entry;

        AtlasSprite sprite;
        sprite.name = "full";
        sprite.rect = { 0, 0, (float)img.width, (float)img.height };
        atlas.sprites.push_back(sprite);
        atlas.spriteByName["full"] = 0;
        atlas.packed = true;

        g_atlases[atlas.id] = atlas;
        return atlas.id;
    }

    bool Framework_Atlas_SaveToFile(int atlasId, const char* jsonPath, const char* imagePath) {
        auto* atlas = GetAtlas(atlasId);
        if (!atlas || !imagePath) return false;
        ExportImage(atlas->atlasImage, imagePath);
        return true;
    }

    int Framework_Atlas_GetCount() {
        return (int)g_atlases.size();
    }

    void Framework_Atlas_DestroyAll() {
        for (auto& kv : g_atlases) {
            if (kv.second.atlasImage.data) UnloadImage(kv.second.atlasImage);
        }
        g_atlases.clear();
        g_nextAtlasId = 1;
    }

    // ========================================================================
    // LEVEL EDITOR SYSTEM
    // ========================================================================

    namespace {
        struct TileLayer {
            std::string name;
            std::unordered_map<int, int> tiles;
            bool visible = true;
        };

        struct LevelObject {
            int id = 0;
            std::string type;
            float x = 0, y = 0;
            float rotation = 0;
            float scaleX = 1, scaleY = 1;
            std::unordered_map<std::string, std::string> properties;
        };

        struct LevelCollision {
            int id = 0;
            int type = 0;
            float x, y, w, h, radius;
        };

        struct Level {
            int id = 0;
            std::string name;
            int widthTiles = 50, heightTiles = 30;
            int tileWidth = 32, tileHeight = 32;
            Color bgColor = { 30, 30, 50, 255 };
            std::vector<TileLayer> layers;
            std::vector<LevelObject> objects;
            std::vector<LevelCollision> collisions;
            int nextObjectId = 1;
            int nextCollisionId = 1;
        };

        std::unordered_map<int, Level> g_levels;
        std::unordered_map<std::string, int> g_levelByName;
        int g_nextLevelId = 1;
        static char s_levelNameBuf[256] = {0};
        static char s_levelPropBuf[1024] = {0};

        Level* GetLevel(int id) {
            auto it = g_levels.find(id);
            return (it != g_levels.end()) ? &it->second : nullptr;
        }

        LevelObject* GetLevelObject(Level* level, int objId) {
            if (!level) return nullptr;
            for (auto& obj : level->objects) {
                if (obj.id == objId) return &obj;
            }
            return nullptr;
        }
    }

    int Framework_Level_Create(const char* name) {
        Level level;
        level.id = g_nextLevelId++;
        level.name = name ? name : "";
        level.layers.push_back({ "default", {}, true });
        g_levels[level.id] = level;
        if (name && strlen(name) > 0) g_levelByName[name] = level.id;
        return level.id;
    }

    void Framework_Level_Destroy(int levelId) {
        auto* level = GetLevel(levelId);
        if (level) {
            g_levelByName.erase(level->name);
            g_levels.erase(levelId);
        }
    }

    int Framework_Level_GetByName(const char* name) {
        if (!name) return -1;
        auto it = g_levelByName.find(name);
        return (it != g_levelByName.end()) ? it->second : -1;
    }

    bool Framework_Level_IsValid(int levelId) {
        return g_levels.find(levelId) != g_levels.end();
    }

    const char* Framework_Level_GetName(int levelId) {
        auto* level = GetLevel(levelId);
        if (!level) return "";
        strncpy(s_levelNameBuf, level->name.c_str(), sizeof(s_levelNameBuf) - 1);
        return s_levelNameBuf;
    }

    void Framework_Level_SetSize(int levelId, int widthTiles, int heightTiles) {
        if (auto* level = GetLevel(levelId)) {
            level->widthTiles = widthTiles;
            level->heightTiles = heightTiles;
        }
    }

    void Framework_Level_GetSize(int levelId, int* width, int* height) {
        auto* level = GetLevel(levelId);
        if (width) *width = level ? level->widthTiles : 0;
        if (height) *height = level ? level->heightTiles : 0;
    }

    void Framework_Level_SetTileSize(int levelId, int tileWidth, int tileHeight) {
        if (auto* level = GetLevel(levelId)) {
            level->tileWidth = tileWidth;
            level->tileHeight = tileHeight;
        }
    }

    void Framework_Level_GetTileSize(int levelId, int* tileWidth, int* tileHeight) {
        auto* level = GetLevel(levelId);
        if (tileWidth) *tileWidth = level ? level->tileWidth : 32;
        if (tileHeight) *tileHeight = level ? level->tileHeight : 32;
    }

    void Framework_Level_SetBackground(int levelId, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        if (auto* level = GetLevel(levelId)) level->bgColor = { r, g, b, a };
    }

    int Framework_Level_AddLayer(int levelId, const char* layerName) {
        auto* level = GetLevel(levelId);
        if (!level) return -1;
        level->layers.push_back({ layerName ? layerName : "layer", {}, true });
        return (int)level->layers.size() - 1;
    }

    void Framework_Level_RemoveLayer(int levelId, int layerIndex) {
        auto* level = GetLevel(levelId);
        if (level && layerIndex >= 0 && layerIndex < (int)level->layers.size())
            level->layers.erase(level->layers.begin() + layerIndex);
    }

    int Framework_Level_GetLayerCount(int levelId) {
        auto* level = GetLevel(levelId);
        return level ? (int)level->layers.size() : 0;
    }

    const char* Framework_Level_GetLayerName(int levelId, int layerIndex) {
        auto* level = GetLevel(levelId);
        if (!level || layerIndex < 0 || layerIndex >= (int)level->layers.size()) return "";
        strncpy(s_levelNameBuf, level->layers[layerIndex].name.c_str(), sizeof(s_levelNameBuf) - 1);
        return s_levelNameBuf;
    }

    void Framework_Level_SetLayerVisible(int levelId, int layerIndex, bool visible) {
        auto* level = GetLevel(levelId);
        if (level && layerIndex >= 0 && layerIndex < (int)level->layers.size())
            level->layers[layerIndex].visible = visible;
    }

    bool Framework_Level_GetLayerVisible(int levelId, int layerIndex) {
        auto* level = GetLevel(levelId);
        if (!level || layerIndex < 0 || layerIndex >= (int)level->layers.size()) return false;
        return level->layers[layerIndex].visible;
    }

    void Framework_Level_SetTile(int levelId, int layerIndex, int x, int y, int tileId) {
        auto* level = GetLevel(levelId);
        if (!level || layerIndex < 0 || layerIndex >= (int)level->layers.size()) return;
        int key = y * level->widthTiles + x;
        if (tileId < 0) level->layers[layerIndex].tiles.erase(key);
        else level->layers[layerIndex].tiles[key] = tileId;
    }

    int Framework_Level_GetTile(int levelId, int layerIndex, int x, int y) {
        auto* level = GetLevel(levelId);
        if (!level || layerIndex < 0 || layerIndex >= (int)level->layers.size()) return -1;
        int key = y * level->widthTiles + x;
        auto it = level->layers[layerIndex].tiles.find(key);
        return (it != level->layers[layerIndex].tiles.end()) ? it->second : -1;
    }

    void Framework_Level_FillTiles(int levelId, int layerIndex, int x, int y, int w, int h, int tileId) {
        for (int ty = y; ty < y + h; ty++)
            for (int tx = x; tx < x + w; tx++)
                Framework_Level_SetTile(levelId, layerIndex, tx, ty, tileId);
    }

    void Framework_Level_ClearLayer(int levelId, int layerIndex) {
        auto* level = GetLevel(levelId);
        if (level && layerIndex >= 0 && layerIndex < (int)level->layers.size())
            level->layers[layerIndex].tiles.clear();
    }

    int Framework_Level_AddObject(int levelId, const char* objectType, float x, float y) {
        auto* level = GetLevel(levelId);
        if (!level) return -1;
        LevelObject obj;
        obj.id = level->nextObjectId++;
        obj.type = objectType ? objectType : "object";
        obj.x = x; obj.y = y;
        level->objects.push_back(obj);
        return obj.id;
    }

    void Framework_Level_RemoveObject(int levelId, int objectId) {
        auto* level = GetLevel(levelId);
        if (!level) return;
        level->objects.erase(std::remove_if(level->objects.begin(), level->objects.end(),
            [objectId](const LevelObject& o) { return o.id == objectId; }), level->objects.end());
    }

    int Framework_Level_GetObjectCount(int levelId) {
        auto* level = GetLevel(levelId);
        return level ? (int)level->objects.size() : 0;
    }

    void Framework_Level_SetObjectPosition(int levelId, int objectId, float x, float y) {
        if (auto* obj = GetLevelObject(GetLevel(levelId), objectId)) { obj->x = x; obj->y = y; }
    }

    void Framework_Level_GetObjectPosition(int levelId, int objectId, float* x, float* y) {
        auto* obj = GetLevelObject(GetLevel(levelId), objectId);
        if (x) *x = obj ? obj->x : 0;
        if (y) *y = obj ? obj->y : 0;
    }

    void Framework_Level_SetObjectRotation(int levelId, int objectId, float rotation) {
        if (auto* obj = GetLevelObject(GetLevel(levelId), objectId)) obj->rotation = rotation;
    }

    float Framework_Level_GetObjectRotation(int levelId, int objectId) {
        auto* obj = GetLevelObject(GetLevel(levelId), objectId);
        return obj ? obj->rotation : 0;
    }

    void Framework_Level_SetObjectScale(int levelId, int objectId, float scaleX, float scaleY) {
        if (auto* obj = GetLevelObject(GetLevel(levelId), objectId)) { obj->scaleX = scaleX; obj->scaleY = scaleY; }
    }

    void Framework_Level_SetObjectProperty(int levelId, int objectId, const char* key, const char* value) {
        auto* obj = GetLevelObject(GetLevel(levelId), objectId);
        if (obj && key) obj->properties[key] = value ? value : "";
    }

    const char* Framework_Level_GetObjectProperty(int levelId, int objectId, const char* key) {
        auto* obj = GetLevelObject(GetLevel(levelId), objectId);
        if (!obj || !key) return "";
        auto it = obj->properties.find(key);
        if (it == obj->properties.end()) return "";
        strncpy(s_levelPropBuf, it->second.c_str(), sizeof(s_levelPropBuf) - 1);
        return s_levelPropBuf;
    }

    const char* Framework_Level_GetObjectType(int levelId, int objectId) {
        auto* obj = GetLevelObject(GetLevel(levelId), objectId);
        if (!obj) return "";
        strncpy(s_levelNameBuf, obj->type.c_str(), sizeof(s_levelNameBuf) - 1);
        return s_levelNameBuf;
    }

    int Framework_Level_AddCollisionRect(int levelId, float x, float y, float w, float h) {
        auto* level = GetLevel(levelId);
        if (!level) return -1;
        LevelCollision col = { level->nextCollisionId++, 0, x, y, w, h, 0 };
        level->collisions.push_back(col);
        return col.id;
    }

    int Framework_Level_AddCollisionCircle(int levelId, float x, float y, float radius) {
        auto* level = GetLevel(levelId);
        if (!level) return -1;
        LevelCollision col = { level->nextCollisionId++, 1, x, y, 0, 0, radius };
        level->collisions.push_back(col);
        return col.id;
    }

    void Framework_Level_RemoveCollision(int levelId, int collisionId) {
        auto* level = GetLevel(levelId);
        if (!level) return;
        level->collisions.erase(std::remove_if(level->collisions.begin(), level->collisions.end(),
            [collisionId](const LevelCollision& c) { return c.id == collisionId; }), level->collisions.end());
    }

    void Framework_Level_ClearCollisions(int levelId) {
        if (auto* level = GetLevel(levelId)) level->collisions.clear();
    }

    int Framework_Level_GetCollisionCount(int levelId) {
        auto* level = GetLevel(levelId);
        return level ? (int)level->collisions.size() : 0;
    }

    bool Framework_Level_SaveToFile(int levelId, const char* filePath) {
        auto* level = GetLevel(levelId);
        if (!level || !filePath) return false;
        FILE* file = fopen(filePath, "w");
        if (!file) return false;

        fprintf(file, "{\n  \"name\": \"%s\",\n  \"width\": %d,\n  \"height\": %d,\n",
            level->name.c_str(), level->widthTiles, level->heightTiles);
        fprintf(file, "  \"tileWidth\": %d,\n  \"tileHeight\": %d,\n",
            level->tileWidth, level->tileHeight);
        fprintf(file, "  \"layers\": [\n");
        for (size_t i = 0; i < level->layers.size(); i++) {
            auto& layer = level->layers[i];
            fprintf(file, "    { \"name\": \"%s\", \"tiles\": [", layer.name.c_str());
            bool first = true;
            for (auto& kv : layer.tiles) {
                if (!first) fprintf(file, ",");
                fprintf(file, "[%d,%d,%d]", kv.first % level->widthTiles, kv.first / level->widthTiles, kv.second);
                first = false;
            }
            fprintf(file, "] }%s\n", i < level->layers.size() - 1 ? "," : "");
        }
        fprintf(file, "  ],\n  \"objects\": [],\n  \"collisions\": []\n}\n");
        fclose(file);
        return true;
    }

    int Framework_Level_LoadFromFile(const char* filePath) {
        if (!filePath) return -1;
        return Framework_Level_Create("loaded");
    }

    void Framework_Level_Draw(int levelId, int tilesetHandle, int tilesPerRow) {
        auto* level = GetLevel(levelId);
        if (!level) return;
        ClearBackground(level->bgColor);
        for (int i = 0; i < (int)level->layers.size(); i++)
            Framework_Level_DrawLayer(levelId, i, tilesetHandle, tilesPerRow);
    }

    void Framework_Level_DrawLayer(int levelId, int layerIndex, int tilesetHandle, int tilesPerRow) {
        auto* level = GetLevel(levelId);
        if (!level || layerIndex < 0 || layerIndex >= (int)level->layers.size()) return;
        if (!level->layers[layerIndex].visible) return;

        auto texIt = g_texByHandle.find(tilesetHandle);
        if (texIt == g_texByHandle.end() || !texIt->second.valid) return;

        int tw = level->tileWidth, th = level->tileHeight;
        for (auto& kv : level->layers[layerIndex].tiles) {
            int x = kv.first % level->widthTiles, y = kv.first / level->widthTiles;
            int tileId = kv.second;
            if (tileId < 0) continue;
            Rectangle src = { (float)((tileId % tilesPerRow) * tw), (float)((tileId / tilesPerRow) * th), (float)tw, (float)th };
            Rectangle dest = { (float)(x * tw), (float)(y * th), (float)tw, (float)th };
            DrawTexturePro(texIt->second.tex, src, dest, { 0, 0 }, 0, WHITE);
        }
    }

    void Framework_Level_SpawnObjects(int levelId) {
        auto* level = GetLevel(levelId);
        if (!level) return;
        for (auto& obj : level->objects) {
            int entity = Framework_Ecs_CreateEntity();
            Framework_Ecs_SetTransformPosition(entity, obj.x, obj.y);
            Framework_Ecs_SetTransformRotation(entity, obj.rotation);
            Framework_Ecs_SetTransformScale(entity, obj.scaleX, obj.scaleY);
        }
    }

    void Framework_Level_CreateCollisionBodies(int levelId) {
        auto* level = GetLevel(levelId);
        if (!level) return;
        for (auto& col : level->collisions) {
            // Create static physics body
            int body = Framework_Physics_CreateBody(0, col.x, col.y);  // 0 = static
            if (col.type == 0) Framework_Physics_SetBodyBox(body, col.w, col.h);
            else Framework_Physics_SetBodyCircle(body, col.radius);
        }
    }

    int Framework_Level_GetCount() { return (int)g_levels.size(); }

    void Framework_Level_DestroyAll() {
        g_levels.clear();
        g_levelByName.clear();
        g_nextLevelId = 1;
    }

    // Clipboard for copy/paste
    namespace {
        struct LevelClipboard {
            std::vector<std::vector<int>> tiles;
            int width = 0, height = 0;
        };
        LevelClipboard g_levelClipboard;

        // Undo/Redo per level
        struct TileEdit {
            int layerIndex;
            int x, y;
            int oldTileId, newTileId;
        };
        struct EditBatch {
            std::vector<TileEdit> edits;
        };
        std::unordered_map<int, std::vector<EditBatch>> g_levelUndoStack;
        std::unordered_map<int, std::vector<EditBatch>> g_levelRedoStack;
        std::unordered_map<int, EditBatch> g_levelCurrentEdit;
        std::unordered_map<int, bool> g_levelEditMode;

        // Tile properties
        struct TileProps {
            bool solid = false;
            std::unordered_map<std::string, std::string> properties;
        };
        std::unordered_map<int, std::unordered_map<int, TileProps>> g_levelTileProps; // levelId -> tileId -> props

        // Auto-tile rules
        std::unordered_map<int, std::unordered_map<int, std::array<int, 16>>> g_autoTileRules; // levelId -> baseTileId -> 16 tiles
    }

    void Framework_Level_WorldToTile(int levelId, float worldX, float worldY, int* tileX, int* tileY) {
        Level* level = GetLevel(levelId);
        if (!level) {
            if (tileX) *tileX = 0;
            if (tileY) *tileY = 0;
            return;
        }
        if (tileX) *tileX = (int)(worldX / level->tileWidth);
        if (tileY) *tileY = (int)(worldY / level->tileHeight);
    }

    void Framework_Level_TileToWorld(int levelId, int tileX, int tileY, float* worldX, float* worldY) {
        Level* level = GetLevel(levelId);
        if (!level) {
            if (worldX) *worldX = 0;
            if (worldY) *worldY = 0;
            return;
        }
        if (worldX) *worldX = (float)(tileX * level->tileWidth);
        if (worldY) *worldY = (float)(tileY * level->tileHeight);
    }

    void Framework_Level_TileToWorldCenter(int levelId, int tileX, int tileY, float* worldX, float* worldY) {
        Level* level = GetLevel(levelId);
        if (!level) {
            if (worldX) *worldX = 0;
            if (worldY) *worldY = 0;
            return;
        }
        if (worldX) *worldX = (float)(tileX * level->tileWidth + level->tileWidth / 2);
        if (worldY) *worldY = (float)(tileY * level->tileHeight + level->tileHeight / 2);
    }

    int Framework_Level_FloodFill(int levelId, int layerIndex, int x, int y, int newTileId) {
        Level* level = GetLevel(levelId);
        if (!level || layerIndex < 0 || layerIndex >= (int)level->layers.size()) return 0;
        TileLayer& layer = level->layers[layerIndex];
        if (x < 0 || x >= level->widthTiles || y < 0 || y >= level->heightTiles) return 0;

        int oldTileId = layer.tiles[y * level->widthTiles + x];
        if (oldTileId == newTileId) return 0;

        std::vector<std::pair<int, int>> stack;
        stack.push_back({ x, y });
        int count = 0;

        while (!stack.empty()) {
            auto [cx, cy] = stack.back();
            stack.pop_back();

            if (cx < 0 || cx >= level->widthTiles || cy < 0 || cy >= level->heightTiles) continue;
            int idx = cy * level->widthTiles + cx;
            if (layer.tiles[idx] != oldTileId) continue;

            layer.tiles[idx] = newTileId;
            count++;

            stack.push_back({ cx + 1, cy });
            stack.push_back({ cx - 1, cy });
            stack.push_back({ cx, cy + 1 });
            stack.push_back({ cx, cy - 1 });
        }
        return count;
    }

    void Framework_Level_CopyRegion(int levelId, int layerIndex, int x, int y, int w, int h) {
        Level* level = GetLevel(levelId);
        if (!level || layerIndex < 0 || layerIndex >= (int)level->layers.size() || w <= 0 || h <= 0) {
            g_levelClipboard.width = 0;
            g_levelClipboard.height = 0;
            g_levelClipboard.tiles.clear();
            return;
        }

        g_levelClipboard.width = w;
        g_levelClipboard.height = h;
        g_levelClipboard.tiles.resize(h);

        TileLayer& layer = level->layers[layerIndex];
        for (int dy = 0; dy < h; dy++) {
            g_levelClipboard.tiles[dy].resize(w);
            for (int dx = 0; dx < w; dx++) {
                int tx = x + dx, ty = y + dy;
                if (tx >= 0 && tx < level->widthTiles && ty >= 0 && ty < level->heightTiles) {
                    g_levelClipboard.tiles[dy][dx] = layer.tiles[ty * level->widthTiles + tx];
                } else {
                    g_levelClipboard.tiles[dy][dx] = -1;
                }
            }
        }
    }

    void Framework_Level_PasteRegion(int levelId, int layerIndex, int x, int y) {
        Level* level = GetLevel(levelId);
        if (!level || layerIndex < 0 || layerIndex >= (int)level->layers.size()) return;
        if (g_levelClipboard.width <= 0 || g_levelClipboard.height <= 0) return;

        TileLayer& layer = level->layers[layerIndex];
        for (int dy = 0; dy < g_levelClipboard.height; dy++) {
            for (int dx = 0; dx < g_levelClipboard.width; dx++) {
                int tx = x + dx, ty = y + dy;
                if (tx >= 0 && tx < level->widthTiles && ty >= 0 && ty < level->heightTiles) {
                    int tileId = g_levelClipboard.tiles[dy][dx];
                    if (tileId >= 0) {
                        layer.tiles[ty * level->widthTiles + tx] = tileId;
                    }
                }
            }
        }
    }

    void Framework_Level_ClearSelection() {
        g_levelClipboard.width = 0;
        g_levelClipboard.height = 0;
        g_levelClipboard.tiles.clear();
    }

    void Framework_Level_GetSelectionSize(int* width, int* height) {
        if (width) *width = g_levelClipboard.width;
        if (height) *height = g_levelClipboard.height;
    }

    void Framework_Level_Undo(int levelId) {
        auto& undoStack = g_levelUndoStack[levelId];
        if (undoStack.empty()) return;

        EditBatch batch = undoStack.back();
        undoStack.pop_back();

        Level* level = GetLevel(levelId);
        if (!level) return;

        for (auto& edit : batch.edits) {
            if (edit.layerIndex >= 0 && edit.layerIndex < (int)level->layers.size()) {
                TileLayer& layer = level->layers[edit.layerIndex];
                int idx = edit.y * level->widthTiles + edit.x;
                if (idx >= 0 && idx < (int)layer.tiles.size()) {
                    layer.tiles[idx] = edit.oldTileId;
                }
            }
        }

        g_levelRedoStack[levelId].push_back(batch);
    }

    void Framework_Level_Redo(int levelId) {
        auto& redoStack = g_levelRedoStack[levelId];
        if (redoStack.empty()) return;

        EditBatch batch = redoStack.back();
        redoStack.pop_back();

        Level* level = GetLevel(levelId);
        if (!level) return;

        for (auto& edit : batch.edits) {
            if (edit.layerIndex >= 0 && edit.layerIndex < (int)level->layers.size()) {
                TileLayer& layer = level->layers[edit.layerIndex];
                int idx = edit.y * level->widthTiles + edit.x;
                if (idx >= 0 && idx < (int)layer.tiles.size()) {
                    layer.tiles[idx] = edit.newTileId;
                }
            }
        }

        g_levelUndoStack[levelId].push_back(batch);
    }

    bool Framework_Level_CanUndo(int levelId) {
        auto it = g_levelUndoStack.find(levelId);
        return it != g_levelUndoStack.end() && !it->second.empty();
    }

    bool Framework_Level_CanRedo(int levelId) {
        auto it = g_levelRedoStack.find(levelId);
        return it != g_levelRedoStack.end() && !it->second.empty();
    }

    void Framework_Level_BeginEdit(int levelId) {
        g_levelEditMode[levelId] = true;
        g_levelCurrentEdit[levelId] = EditBatch();
    }

    void Framework_Level_EndEdit(int levelId) {
        if (!g_levelEditMode[levelId]) return;
        g_levelEditMode[levelId] = false;

        auto& batch = g_levelCurrentEdit[levelId];
        if (!batch.edits.empty()) {
            g_levelUndoStack[levelId].push_back(batch);
            g_levelRedoStack[levelId].clear();
        }
        g_levelCurrentEdit[levelId] = EditBatch();
    }

    void Framework_Level_SetTileCollision(int levelId, int tileId, bool solid) {
        g_levelTileProps[levelId][tileId].solid = solid;
    }

    bool Framework_Level_GetTileCollision(int levelId, int tileId) {
        auto levelIt = g_levelTileProps.find(levelId);
        if (levelIt == g_levelTileProps.end()) return false;
        auto tileIt = levelIt->second.find(tileId);
        if (tileIt == levelIt->second.end()) return false;
        return tileIt->second.solid;
    }

    void Framework_Level_SetTileProperty(int levelId, int tileId, const char* key, const char* value) {
        if (!key) return;
        g_levelTileProps[levelId][tileId].properties[key] = value ? value : "";
    }

    const char* Framework_Level_GetTileProperty(int levelId, int tileId, const char* key) {
        if (!key) return "";
        auto levelIt = g_levelTileProps.find(levelId);
        if (levelIt == g_levelTileProps.end()) return "";
        auto tileIt = levelIt->second.find(tileId);
        if (tileIt == levelIt->second.end()) return "";
        auto propIt = tileIt->second.properties.find(key);
        if (propIt == tileIt->second.properties.end()) return "";
        strncpy(s_levelPropBuf, propIt->second.c_str(), sizeof(s_levelPropBuf) - 1);
        return s_levelPropBuf;
    }

    void Framework_Level_SetAutoTileRules(int levelId, int baseTileId, const int* tileMapping) {
        if (!tileMapping) return;
        auto& rules = g_autoTileRules[levelId][baseTileId];
        for (int i = 0; i < 16; i++) {
            rules[i] = tileMapping[i];
        }
    }

    void Framework_Level_PlaceAutoTile(int levelId, int layerIndex, int x, int y, int baseTileId) {
        Level* level = GetLevel(levelId);
        if (!level || layerIndex < 0 || layerIndex >= (int)level->layers.size()) return;
        if (x < 0 || x >= level->widthTiles || y < 0 || y >= level->heightTiles) return;

        auto levelIt = g_autoTileRules.find(levelId);
        if (levelIt == g_autoTileRules.end()) {
            level->layers[layerIndex].tiles[y * level->widthTiles + x] = baseTileId;
            return;
        }
        auto baseIt = levelIt->second.find(baseTileId);
        if (baseIt == levelIt->second.end()) {
            level->layers[layerIndex].tiles[y * level->widthTiles + x] = baseTileId;
            return;
        }

        TileLayer& layer = level->layers[layerIndex];
        const std::array<int, 16>& rules = baseIt->second;

        auto isSameBase = [&](int tx, int ty) -> bool {
            if (tx < 0 || tx >= level->widthTiles || ty < 0 || ty >= level->heightTiles) return false;
            int t = layer.tiles[ty * level->widthTiles + tx];
            if (t == baseTileId) return true;
            for (int i = 0; i < 16; i++) {
                if (rules[i] == t) return true;
            }
            return false;
        };

        int mask = 0;
        if (isSameBase(x, y - 1)) mask |= 1;  // North
        if (isSameBase(x + 1, y)) mask |= 2;  // East
        if (isSameBase(x, y + 1)) mask |= 4;  // South
        if (isSameBase(x - 1, y)) mask |= 8;  // West

        layer.tiles[y * level->widthTiles + x] = rules[mask];
    }

    void Framework_Level_RefreshAutoTiles(int levelId, int layerIndex) {
        Level* level = GetLevel(levelId);
        if (!level || layerIndex < 0 || layerIndex >= (int)level->layers.size()) return;

        auto levelIt = g_autoTileRules.find(levelId);
        if (levelIt == g_autoTileRules.end()) return;

        TileLayer& layer = level->layers[layerIndex];
        for (int y = 0; y < level->heightTiles; y++) {
            for (int x = 0; x < level->widthTiles; x++) {
                int tileId = layer.tiles[y * level->widthTiles + x];
                for (const auto& pair : levelIt->second) {
                    int baseTileId = pair.first;
                    const std::array<int, 16>& rules = pair.second;
                    bool isAutoTile = (tileId == baseTileId);
                    for (int i = 0; i < 16 && !isAutoTile; i++) {
                        if (rules[i] == tileId) isAutoTile = true;
                    }
                    if (isAutoTile) {
                        Framework_Level_PlaceAutoTile(levelId, layerIndex, x, y, baseTileId);
                        break;
                    }
                }
            }
        }
    }

    bool Framework_Level_IsTileSolid(int levelId, int layerIndex, int x, int y) {
        Level* level = GetLevel(levelId);
        if (!level || layerIndex < 0 || layerIndex >= (int)level->layers.size()) return false;
        if (x < 0 || x >= level->widthTiles || y < 0 || y >= level->heightTiles) return false;

        int tileId = level->layers[layerIndex].tiles[y * level->widthTiles + x];
        return Framework_Level_GetTileCollision(levelId, tileId);
    }

    bool Framework_Level_RaycastTiles(int levelId, int layerIndex, float startX, float startY, float endX, float endY, int* hitTileX, int* hitTileY) {
        Level* level = GetLevel(levelId);
        if (!level || layerIndex < 0 || layerIndex >= (int)level->layers.size()) {
            if (hitTileX) *hitTileX = -1;
            if (hitTileY) *hitTileY = -1;
            return false;
        }

        float dx = endX - startX;
        float dy = endY - startY;
        float dist = sqrtf(dx * dx + dy * dy);
        if (dist < 0.001f) {
            if (hitTileX) *hitTileX = -1;
            if (hitTileY) *hitTileY = -1;
            return false;
        }

        dx /= dist;
        dy /= dist;

        float step = (float)std::min(level->tileWidth, level->tileHeight) * 0.5f;
        float traveled = 0;

        while (traveled < dist) {
            float cx = startX + dx * traveled;
            float cy = startY + dy * traveled;
            int tx = (int)(cx / level->tileWidth);
            int ty = (int)(cy / level->tileHeight);

            if (tx >= 0 && tx < level->widthTiles && ty >= 0 && ty < level->heightTiles) {
                if (Framework_Level_IsTileSolid(levelId, layerIndex, tx, ty)) {
                    if (hitTileX) *hitTileX = tx;
                    if (hitTileY) *hitTileY = ty;
                    return true;
                }
            }
            traveled += step;
        }

        if (hitTileX) *hitTileX = -1;
        if (hitTileY) *hitTileY = -1;
        return false;
    }

} // Temporarily close extern "C" for networking namespace

    // ========================================================================
    // NETWORKING SYSTEM (WinSock2 Implementation)
    // ========================================================================

    namespace {
        bool g_wsaInitialized = false;

        void EnsureWsaInit() {
            if (!g_wsaInitialized) {
                WSADATA wsaData;
                if (WSAStartup(MAKEWORD(2, 2), &wsaData) == 0) {
                    g_wsaInitialized = true;
                }
            }
        }

        void SetSocketNonBlocking(SOCKET s) {
            u_long mode = 1;
            ioctlsocket(s, FIONBIO, &mode);
        }

        // Message header: 4 bytes channel length + channel + 4 bytes data length + data
        struct NetMessage {
            std::string channel;
            std::vector<unsigned char> data;
        };

        struct ServerClient {
            int id = 0;
            SOCKET sock = INVALID_SOCKET;
            std::string address;
            int port = 0;
            std::vector<unsigned char> recvBuffer;
            int bytesSent = 0, bytesReceived = 0;
            double lastPingTime = 0;
            int ping = 0;
        };

        struct NetServer {
            int id = 0;
            SOCKET listenSock = INVALID_SOCKET;
            bool running = false;
            int port = 0, maxClients = 4;
            int nextClientId = 1;
            std::vector<ServerClient> clients;
            int bytesSent = 0, bytesReceived = 0;
            NetConnectCallback onClientConnect = nullptr;
            void* clientConnectUserData = nullptr;
            NetDisconnectCallback onClientDisconnect = nullptr;
            void* clientDisconnectUserData = nullptr;
            NetMessageCallback onMessage = nullptr;
            void* messageUserData = nullptr;
        };

        struct NetClient {
            int id = 0;
            SOCKET sock = INVALID_SOCKET;
            bool connected = false;
            bool connecting = false;
            std::string address;
            int port = 0;
            std::vector<unsigned char> recvBuffer;
            int bytesSent = 0, bytesReceived = 0;
            double lastPingSent = 0;
            int ping = 0;
            NetConnectCallback onConnect = nullptr;
            void* connectUserData = nullptr;
            NetDisconnectCallback onDisconnect = nullptr;
            void* disconnectUserData = nullptr;
            NetMessageCallback onMessage = nullptr;
            void* messageUserData = nullptr;
        };

        std::unordered_map<int, NetServer> g_servers;
        std::unordered_map<int, NetClient> g_netClients;
        int g_nextServerId = 1, g_nextNetClientId = 1;
        static char s_netAddrBuf[64] = { 0 };

        NetServer* GetServer(int id) {
            auto it = g_servers.find(id);
            return (it != g_servers.end()) ? &it->second : nullptr;
        }
        NetClient* GetNetClient(int id) {
            auto it = g_netClients.find(id);
            return (it != g_netClients.end()) ? &it->second : nullptr;
        }

        // Send a framed message: [4-byte channel len][channel][4-byte data len][data]
        bool SendFramedMessage(SOCKET s, const char* channel, const void* data, int dataSize, int& bytesSentOut) {
            if (s == INVALID_SOCKET) return false;
            std::string ch = channel ? channel : "";
            uint32_t chanLen = (uint32_t)ch.size();
            uint32_t dataLen = (uint32_t)dataSize;

            std::vector<unsigned char> frame;
            frame.resize(4 + chanLen + 4 + dataLen);
            memcpy(&frame[0], &chanLen, 4);
            if (chanLen > 0) memcpy(&frame[4], ch.c_str(), chanLen);
            memcpy(&frame[4 + chanLen], &dataLen, 4);
            if (dataLen > 0) memcpy(&frame[4 + chanLen + 4], data, dataLen);

            int totalSent = 0;
            while (totalSent < (int)frame.size()) {
                int sent = send(s, (const char*)&frame[totalSent], (int)frame.size() - totalSent, 0);
                if (sent == SOCKET_ERROR) {
                    int err = WSAGetLastError();
                    if (err == WSAEWOULDBLOCK) continue;
                    return false;
                }
                totalSent += sent;
            }
            bytesSentOut += totalSent;
            return true;
        }

        // Try to parse messages from buffer, returns parsed messages
        std::vector<NetMessage> ParseMessages(std::vector<unsigned char>& buffer) {
            std::vector<NetMessage> msgs;
            while (buffer.size() >= 8) {
                uint32_t chanLen = 0;
                memcpy(&chanLen, &buffer[0], 4);
                if (buffer.size() < 4 + chanLen + 4) break;
                uint32_t dataLen = 0;
                memcpy(&dataLen, &buffer[4 + chanLen], 4);
                if (buffer.size() < 4 + chanLen + 4 + dataLen) break;

                NetMessage msg;
                if (chanLen > 0) msg.channel.assign((char*)&buffer[4], chanLen);
                if (dataLen > 0) {
                    msg.data.resize(dataLen);
                    memcpy(msg.data.data(), &buffer[4 + chanLen + 4], dataLen);
                }
                msgs.push_back(std::move(msg));
                buffer.erase(buffer.begin(), buffer.begin() + 4 + chanLen + 4 + dataLen);
            }
            return msgs;
        }
    }

extern "C" {

    int Framework_Net_CreateServer(int port, int maxClients) {
        EnsureWsaInit();
        if (!g_wsaInitialized) return -1;

        SOCKET listenSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (listenSock == INVALID_SOCKET) return -1;

        // Allow address reuse
        int optval = 1;
        setsockopt(listenSock, SOL_SOCKET, SO_REUSEADDR, (const char*)&optval, sizeof(optval));

        sockaddr_in addr = {};
        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = INADDR_ANY;
        addr.sin_port = htons((u_short)port);

        if (bind(listenSock, (sockaddr*)&addr, sizeof(addr)) == SOCKET_ERROR) {
            closesocket(listenSock);
            return -1;
        }

        if (listen(listenSock, SOMAXCONN) == SOCKET_ERROR) {
            closesocket(listenSock);
            return -1;
        }

        SetSocketNonBlocking(listenSock);

        NetServer srv;
        srv.id = g_nextServerId++;
        srv.listenSock = listenSock;
        srv.running = true;
        srv.port = port;
        srv.maxClients = maxClients > 0 ? maxClients : 4;
        g_servers[srv.id] = srv;
        return srv.id;
    }

    void Framework_Net_DestroyServer(int serverId) {
        auto* s = GetServer(serverId);
        if (!s) return;
        for (auto& c : s->clients) {
            if (c.sock != INVALID_SOCKET) closesocket(c.sock);
        }
        if (s->listenSock != INVALID_SOCKET) closesocket(s->listenSock);
        g_servers.erase(serverId);
    }

    bool Framework_Net_ServerIsRunning(int serverId) {
        auto* s = GetServer(serverId);
        return s ? s->running : false;
    }

    int Framework_Net_GetClientCount(int serverId) {
        auto* s = GetServer(serverId);
        return s ? (int)s->clients.size() : 0;
    }

    void Framework_Net_DisconnectClient(int serverId, int clientId) {
        auto* s = GetServer(serverId);
        if (!s) return;
        for (auto it = s->clients.begin(); it != s->clients.end(); ++it) {
            if (it->id == clientId) {
                if (it->sock != INVALID_SOCKET) closesocket(it->sock);
                if (s->onClientDisconnect) s->onClientDisconnect(clientId, s->clientDisconnectUserData);
                s->clients.erase(it);
                break;
            }
        }
    }

    void Framework_Net_BroadcastMessage(int serverId, const char* channel, const void* data, int dataSize, bool reliable) {
        auto* s = GetServer(serverId);
        if (!s) return;
        for (auto& c : s->clients) {
            int sent = 0;
            SendFramedMessage(c.sock, channel, data, dataSize, sent);
            c.bytesSent += sent;
            s->bytesSent += sent;
        }
    }

    void Framework_Net_SendToClient(int serverId, int clientId, const char* channel, const void* data, int dataSize, bool reliable) {
        auto* s = GetServer(serverId);
        if (!s) return;
        for (auto& c : s->clients) {
            if (c.id == clientId) {
                int sent = 0;
                SendFramedMessage(c.sock, channel, data, dataSize, sent);
                c.bytesSent += sent;
                s->bytesSent += sent;
                break;
            }
        }
    }

    int Framework_Net_CreateClient() {
        EnsureWsaInit();
        NetClient c;
        c.id = g_nextNetClientId++;
        c.sock = INVALID_SOCKET;
        g_netClients[c.id] = c;
        return c.id;
    }

    void Framework_Net_DestroyClient(int clientId) {
        auto* c = GetNetClient(clientId);
        if (!c) return;
        if (c->sock != INVALID_SOCKET) closesocket(c->sock);
        g_netClients.erase(clientId);
    }

    bool Framework_Net_Connect(int clientId, const char* host, int port) {
        auto* c = GetNetClient(clientId);
        if (!c || !host || !g_wsaInitialized) return false;

        if (c->sock != INVALID_SOCKET) closesocket(c->sock);
        c->sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (c->sock == INVALID_SOCKET) return false;

        SetSocketNonBlocking(c->sock);

        // Resolve host
        struct addrinfo hints = {}, *result = nullptr;
        hints.ai_family = AF_INET;
        hints.ai_socktype = SOCK_STREAM;
        char portStr[16];
        snprintf(portStr, sizeof(portStr), "%d", port);

        if (getaddrinfo(host, portStr, &hints, &result) != 0 || !result) {
            closesocket(c->sock);
            c->sock = INVALID_SOCKET;
            return false;
        }

        int res = connect(c->sock, result->ai_addr, (int)result->ai_addrlen);
        freeaddrinfo(result);

        if (res == SOCKET_ERROR) {
            int err = WSAGetLastError();
            if (err != WSAEWOULDBLOCK) {
                closesocket(c->sock);
                c->sock = INVALID_SOCKET;
                return false;
            }
        }

        c->address = host;
        c->port = port;
        c->connecting = true;
        c->connected = false;
        return true;
    }

    void Framework_Net_Disconnect(int clientId) {
        auto* c = GetNetClient(clientId);
        if (!c) return;
        if (c->sock != INVALID_SOCKET) {
            closesocket(c->sock);
            c->sock = INVALID_SOCKET;
        }
        bool wasConnected = c->connected;
        c->connected = false;
        c->connecting = false;
        if (wasConnected && c->onDisconnect) c->onDisconnect(clientId, c->disconnectUserData);
    }

    bool Framework_Net_IsConnected(int clientId) {
        auto* c = GetNetClient(clientId);
        return c ? c->connected : false;
    }

    void Framework_Net_SendMessage(int clientId, const char* channel, const void* data, int dataSize, bool reliable) {
        auto* c = GetNetClient(clientId);
        if (!c || !c->connected) return;
        int sent = 0;
        if (SendFramedMessage(c->sock, channel, data, dataSize, sent)) {
            c->bytesSent += sent;
        }
    }

    void Framework_Net_UpdateServer(int serverId) {
        auto* s = GetServer(serverId);
        if (!s || !s->running) return;

        // Accept new connections
        while ((int)s->clients.size() < s->maxClients) {
            sockaddr_in clientAddr;
            int addrLen = sizeof(clientAddr);
            SOCKET clientSock = accept(s->listenSock, (sockaddr*)&clientAddr, &addrLen);
            if (clientSock == INVALID_SOCKET) break;

            SetSocketNonBlocking(clientSock);

            ServerClient sc;
            sc.id = s->nextClientId++;
            sc.sock = clientSock;
            char ipBuf[INET_ADDRSTRLEN];
            inet_ntop(AF_INET, &clientAddr.sin_addr, ipBuf, sizeof(ipBuf));
            sc.address = ipBuf;
            sc.port = ntohs(clientAddr.sin_port);
            s->clients.push_back(sc);

            if (s->onClientConnect) s->onClientConnect(sc.id, s->clientConnectUserData);
        }

        // Process each client
        std::vector<int> toRemove;
        for (auto& c : s->clients) {
            // Receive data
            char recvBuf[4096];
            int received = recv(c.sock, recvBuf, sizeof(recvBuf), 0);
            if (received > 0) {
                c.recvBuffer.insert(c.recvBuffer.end(), recvBuf, recvBuf + received);
                c.bytesReceived += received;
                s->bytesReceived += received;

                // Parse and dispatch messages
                auto msgs = ParseMessages(c.recvBuffer);
                for (auto& msg : msgs) {
                    if (s->onMessage) {
                        s->onMessage(c.id, msg.channel.c_str(), msg.data.data(), (int)msg.data.size(), s->messageUserData);
                    }
                }
            }
            else if (received == 0) {
                // Connection closed
                toRemove.push_back(c.id);
            }
            else {
                int err = WSAGetLastError();
                if (err != WSAEWOULDBLOCK) {
                    toRemove.push_back(c.id);
                }
            }
        }

        // Remove disconnected clients
        for (int id : toRemove) {
            for (auto it = s->clients.begin(); it != s->clients.end(); ++it) {
                if (it->id == id) {
                    if (it->sock != INVALID_SOCKET) closesocket(it->sock);
                    if (s->onClientDisconnect) s->onClientDisconnect(id, s->clientDisconnectUserData);
                    s->clients.erase(it);
                    break;
                }
            }
        }
    }

    void Framework_Net_UpdateClient(int clientId) {
        auto* c = GetNetClient(clientId);
        if (!c || c->sock == INVALID_SOCKET) return;

        // Check if still connecting
        if (c->connecting && !c->connected) {
            fd_set writeSet, exceptSet;
            FD_ZERO(&writeSet);
            FD_ZERO(&exceptSet);
            FD_SET(c->sock, &writeSet);
            FD_SET(c->sock, &exceptSet);
            timeval tv = { 0, 0 };

            int res = select(0, nullptr, &writeSet, &exceptSet, &tv);
            if (res > 0) {
                if (FD_ISSET(c->sock, &exceptSet)) {
                    // Connection failed
                    closesocket(c->sock);
                    c->sock = INVALID_SOCKET;
                    c->connecting = false;
                }
                else if (FD_ISSET(c->sock, &writeSet)) {
                    // Connected!
                    c->connected = true;
                    c->connecting = false;
                    if (c->onConnect) c->onConnect(clientId, c->connectUserData);
                }
            }
        }

        if (!c->connected) return;

        // Receive data
        char recvBuf[4096];
        int received = recv(c->sock, recvBuf, sizeof(recvBuf), 0);
        if (received > 0) {
            c->recvBuffer.insert(c->recvBuffer.end(), recvBuf, recvBuf + received);
            c->bytesReceived += received;

            // Parse and dispatch messages
            auto msgs = ParseMessages(c->recvBuffer);
            for (auto& msg : msgs) {
                if (c->onMessage) {
                    c->onMessage(clientId, msg.channel.c_str(), msg.data.data(), (int)msg.data.size(), c->messageUserData);
                }
            }
        }
        else if (received == 0) {
            // Server closed connection
            Framework_Net_Disconnect(clientId);
        }
        else {
            int err = WSAGetLastError();
            if (err != WSAEWOULDBLOCK) {
                Framework_Net_Disconnect(clientId);
            }
        }
    }

    void Framework_Net_SetOnClientConnected(int serverId, NetConnectCallback cb, void* ud) {
        if (auto* s = GetServer(serverId)) { s->onClientConnect = cb; s->clientConnectUserData = ud; }
    }

    void Framework_Net_SetOnClientDisconnected(int serverId, NetDisconnectCallback cb, void* ud) {
        if (auto* s = GetServer(serverId)) { s->onClientDisconnect = cb; s->clientDisconnectUserData = ud; }
    }

    void Framework_Net_SetOnServerMessage(int serverId, NetMessageCallback cb, void* ud) {
        if (auto* s = GetServer(serverId)) { s->onMessage = cb; s->messageUserData = ud; }
    }

    void Framework_Net_SetOnConnected(int clientId, NetConnectCallback cb, void* ud) {
        if (auto* c = GetNetClient(clientId)) { c->onConnect = cb; c->connectUserData = ud; }
    }

    void Framework_Net_SetOnDisconnected(int clientId, NetDisconnectCallback cb, void* ud) {
        if (auto* c = GetNetClient(clientId)) { c->onDisconnect = cb; c->disconnectUserData = ud; }
    }

    void Framework_Net_SetOnMessage(int clientId, NetMessageCallback cb, void* ud) {
        if (auto* c = GetNetClient(clientId)) { c->onMessage = cb; c->messageUserData = ud; }
    }

    int Framework_Net_GetPing(int clientId) {
        auto* c = GetNetClient(clientId);
        return c ? c->ping : 0;
    }

    int Framework_Net_GetBytesSent(int connectionId) {
        if (auto* c = GetNetClient(connectionId)) return c->bytesSent;
        if (auto* s = GetServer(connectionId)) return s->bytesSent;
        return 0;
    }

    int Framework_Net_GetBytesReceived(int connectionId) {
        if (auto* c = GetNetClient(connectionId)) return c->bytesReceived;
        if (auto* s = GetServer(connectionId)) return s->bytesReceived;
        return 0;
    }

    const char* Framework_Net_GetClientAddress(int serverId, int clientId) {
        auto* s = GetServer(serverId);
        if (!s) return "";
        for (auto& c : s->clients) {
            if (c.id == clientId) {
                strncpy(s_netAddrBuf, c.address.c_str(), sizeof(s_netAddrBuf) - 1);
                return s_netAddrBuf;
            }
        }
        return "";
    }

    int Framework_Net_GetClientId(int serverId, int index) {
        auto* s = GetServer(serverId);
        if (!s || index < 0 || index >= (int)s->clients.size()) return -1;
        return s->clients[index].id;
    }

    void Framework_Net_Shutdown() {
        for (auto& kv : g_servers) {
            for (auto& c : kv.second.clients) {
                if (c.sock != INVALID_SOCKET) closesocket(c.sock);
            }
            if (kv.second.listenSock != INVALID_SOCKET) closesocket(kv.second.listenSock);
        }
        for (auto& kv : g_netClients) {
            if (kv.second.sock != INVALID_SOCKET) closesocket(kv.second.sock);
        }
        g_servers.clear();
        g_netClients.clear();
        g_nextServerId = 1;
        g_nextNetClientId = 1;
        if (g_wsaInitialized) {
            WSACleanup();
            g_wsaInitialized = false;
        }
    }

    // ========================================================================
    // SHADER SYSTEM
    // ========================================================================

    namespace {
        struct ManagedShader {
            int id = 0;
            Shader shader;
            std::unordered_map<std::string, int> uniformLocs;
            bool valid = false;
        };

        std::unordered_map<int, ManagedShader> g_shaders;
        int g_nextShaderId = 1;
        int g_activeShader = 0;

        ManagedShader* GetShader(int id) {
            auto it = g_shaders.find(id);
            return (it != g_shaders.end()) ? &it->second : nullptr;
        }
    }

    int Framework_Shader_Load(const char* vsPath, const char* fsPath) {
        Shader s = LoadShader(vsPath, fsPath);
        if (s.id == 0) return 0;
        ManagedShader ms;
        ms.id = g_nextShaderId++;
        ms.shader = s;
        ms.valid = true;
        g_shaders[ms.id] = ms;
        return ms.id;
    }

    int Framework_Shader_LoadFromMemory(const char* vsCode, const char* fsCode) {
        Shader s = LoadShaderFromMemory(vsCode, fsCode);
        if (s.id == 0) return 0;
        ManagedShader ms;
        ms.id = g_nextShaderId++;
        ms.shader = s;
        ms.valid = true;
        g_shaders[ms.id] = ms;
        return ms.id;
    }

    void Framework_Shader_Unload(int shaderId) {
        auto* ms = GetShader(shaderId);
        if (ms && ms->valid) {
            UnloadShader(ms->shader);
            g_shaders.erase(shaderId);
        }
    }

    bool Framework_Shader_IsValid(int shaderId) {
        auto* ms = GetShader(shaderId);
        return ms && ms->valid;
    }

    void Framework_Shader_Begin(int shaderId) {
        auto* ms = GetShader(shaderId);
        if (ms && ms->valid) {
            BeginShaderMode(ms->shader);
            g_activeShader = shaderId;
        }
    }

    void Framework_Shader_End() {
        EndShaderMode();
        g_activeShader = 0;
    }

    int Framework_Shader_GetActive() { return g_activeShader; }

    int Framework_Shader_GetUniformLocation(int shaderId, const char* uniformName) {
        auto* ms = GetShader(shaderId);
        if (!ms || !ms->valid || !uniformName) return -1;
        auto it = ms->uniformLocs.find(uniformName);
        if (it != ms->uniformLocs.end()) return it->second;
        int loc = GetShaderLocation(ms->shader, uniformName);
        ms->uniformLocs[uniformName] = loc;
        return loc;
    }

    int Framework_Shader_GetAttributeLocation(int shaderId, const char* attribName) {
        auto* ms = GetShader(shaderId);
        if (!ms || !ms->valid || !attribName) return -1;
        return GetShaderLocationAttrib(ms->shader, attribName);
    }

    void Framework_Shader_SetInt(int shaderId, int loc, int value) {
        auto* ms = GetShader(shaderId);
        if (ms && ms->valid && loc >= 0) SetShaderValue(ms->shader, loc, &value, SHADER_UNIFORM_INT);
    }

    void Framework_Shader_SetFloat(int shaderId, int loc, float value) {
        auto* ms = GetShader(shaderId);
        if (ms && ms->valid && loc >= 0) SetShaderValue(ms->shader, loc, &value, SHADER_UNIFORM_FLOAT);
    }

    void Framework_Shader_SetVec2(int shaderId, int loc, float x, float y) {
        auto* ms = GetShader(shaderId);
        if (ms && ms->valid && loc >= 0) {
            float v[2] = { x, y };
            SetShaderValue(ms->shader, loc, v, SHADER_UNIFORM_VEC2);
        }
    }

    void Framework_Shader_SetVec3(int shaderId, int loc, float x, float y, float z) {
        auto* ms = GetShader(shaderId);
        if (ms && ms->valid && loc >= 0) {
            float v[3] = { x, y, z };
            SetShaderValue(ms->shader, loc, v, SHADER_UNIFORM_VEC3);
        }
    }

    void Framework_Shader_SetVec4(int shaderId, int loc, float x, float y, float z, float w) {
        auto* ms = GetShader(shaderId);
        if (ms && ms->valid && loc >= 0) {
            float v[4] = { x, y, z, w };
            SetShaderValue(ms->shader, loc, v, SHADER_UNIFORM_VEC4);
        }
    }

    void Framework_Shader_SetMat4(int shaderId, int loc, const float* matrix) {
        auto* ms = GetShader(shaderId);
        if (ms && ms->valid && loc >= 0 && matrix) {
            SetShaderValueMatrix(ms->shader, loc, *(Matrix*)matrix);
        }
    }

    void Framework_Shader_SetTexture(int shaderId, int loc, int textureHandle) {
        auto* ms = GetShader(shaderId);
        auto* tex = GetTextureH_Internal(textureHandle);
        if (ms && ms->valid && loc >= 0 && tex) {
            SetShaderValueTexture(ms->shader, loc, *tex);
        }
    }

    void Framework_Shader_SetIntByName(int shaderId, const char* name, int value) {
        int loc = Framework_Shader_GetUniformLocation(shaderId, name);
        Framework_Shader_SetInt(shaderId, loc, value);
    }

    void Framework_Shader_SetFloatByName(int shaderId, const char* name, float value) {
        int loc = Framework_Shader_GetUniformLocation(shaderId, name);
        Framework_Shader_SetFloat(shaderId, loc, value);
    }

    void Framework_Shader_SetVec2ByName(int shaderId, const char* name, float x, float y) {
        int loc = Framework_Shader_GetUniformLocation(shaderId, name);
        Framework_Shader_SetVec2(shaderId, loc, x, y);
    }

    void Framework_Shader_SetVec3ByName(int shaderId, const char* name, float x, float y, float z) {
        int loc = Framework_Shader_GetUniformLocation(shaderId, name);
        Framework_Shader_SetVec3(shaderId, loc, x, y, z);
    }

    void Framework_Shader_SetVec4ByName(int shaderId, const char* name, float x, float y, float z, float w) {
        int loc = Framework_Shader_GetUniformLocation(shaderId, name);
        Framework_Shader_SetVec4(shaderId, loc, x, y, z, w);
    }

    void Framework_Shader_SetTime(int shaderId, float time) {
        Framework_Shader_SetFloatByName(shaderId, "time", time);
    }

    void Framework_Shader_SetResolution(int shaderId, float width, float height) {
        Framework_Shader_SetVec2ByName(shaderId, "resolution", width, height);
    }

    void Framework_Shader_SetMouse(int shaderId, float x, float y) {
        Framework_Shader_SetVec2ByName(shaderId, "mouse", x, y);
    }

    // Built-in shaders
    int Framework_Shader_LoadGrayscale() {
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "out vec4 finalColor;\n"
            "void main() {\n"
            "    vec4 c = texture(texture0, fragTexCoord) * fragColor;\n"
            "    float gray = dot(c.rgb, vec3(0.299, 0.587, 0.114));\n"
            "    finalColor = vec4(vec3(gray), c.a);\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_LoadBlur() {
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "uniform vec2 resolution;\n"
            "out vec4 finalColor;\n"
            "void main() {\n"
            "    vec2 texel = 1.0 / resolution;\n"
            "    vec4 c = vec4(0.0);\n"
            "    for(int x = -2; x <= 2; x++) {\n"
            "        for(int y = -2; y <= 2; y++) {\n"
            "            c += texture(texture0, fragTexCoord + vec2(x,y) * texel);\n"
            "        }\n"
            "    }\n"
            "    finalColor = (c / 25.0) * fragColor;\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_LoadCRT() {
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "uniform vec2 resolution;\n"
            "out vec4 finalColor;\n"
            "void main() {\n"
            "    vec2 uv = fragTexCoord;\n"
            "    vec4 c = texture(texture0, uv) * fragColor;\n"
            "    float scanline = sin(uv.y * resolution.y * 3.14159) * 0.04;\n"
            "    c.rgb -= scanline;\n"
            "    float vignette = 1.0 - length((uv - 0.5) * 1.5);\n"
            "    c.rgb *= clamp(vignette, 0.0, 1.0);\n"
            "    finalColor = c;\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_LoadOutline() {
        // Outline shader - detects edges and draws an outline
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "uniform vec2 resolution;\n"
            "uniform vec4 outlineColor;\n"
            "uniform float outlineThickness;\n"
            "out vec4 finalColor;\n"
            "void main() {\n"
            "    vec2 texel = 1.0 / resolution;\n"
            "    float thickness = max(outlineThickness, 1.0);\n"
            "    vec4 c = texture(texture0, fragTexCoord);\n"
            "    if (c.a > 0.1) {\n"
            "        finalColor = c * fragColor;\n"
            "        return;\n"
            "    }\n"
            "    float outline = 0.0;\n"
            "    for(float x = -thickness; x <= thickness; x++) {\n"
            "        for(float y = -thickness; y <= thickness; y++) {\n"
            "            outline = max(outline, texture(texture0, fragTexCoord + vec2(x,y) * texel).a);\n"
            "        }\n"
            "    }\n"
            "    if (outline > 0.1) {\n"
            "        vec4 oc = outlineColor.a > 0.0 ? outlineColor : vec4(0.0, 0.0, 0.0, 1.0);\n"
            "        finalColor = oc;\n"
            "    } else {\n"
            "        finalColor = vec4(0.0);\n"
            "    }\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_LoadGlow() {
        // Glow shader - adds a soft glow around bright areas
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "uniform vec2 resolution;\n"
            "uniform float glowIntensity;\n"
            "uniform float glowRadius;\n"
            "out vec4 finalColor;\n"
            "void main() {\n"
            "    vec2 texel = 1.0 / resolution;\n"
            "    vec4 c = texture(texture0, fragTexCoord) * fragColor;\n"
            "    float radius = max(glowRadius, 2.0);\n"
            "    float intensity = max(glowIntensity, 0.5);\n"
            "    vec4 glow = vec4(0.0);\n"
            "    float totalWeight = 0.0;\n"
            "    for(float x = -radius; x <= radius; x++) {\n"
            "        for(float y = -radius; y <= radius; y++) {\n"
            "            float dist = length(vec2(x, y));\n"
            "            if (dist <= radius) {\n"
            "                float weight = 1.0 - (dist / radius);\n"
            "                glow += texture(texture0, fragTexCoord + vec2(x,y) * texel) * weight;\n"
            "                totalWeight += weight;\n"
            "            }\n"
            "        }\n"
            "    }\n"
            "    glow = glow / totalWeight;\n"
            "    finalColor = c + glow * intensity * c.a;\n"
            "    finalColor.a = max(c.a, glow.a * intensity * 0.5);\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_LoadDistortion() {
        // Distortion shader - creates wavy distortion effect
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "uniform float time;\n"
            "uniform float distortionStrength;\n"
            "uniform float waveFrequency;\n"
            "out vec4 finalColor;\n"
            "void main() {\n"
            "    float strength = max(distortionStrength, 0.01);\n"
            "    float freq = max(waveFrequency, 5.0);\n"
            "    vec2 uv = fragTexCoord;\n"
            "    uv.x += sin(uv.y * freq + time) * strength;\n"
            "    uv.y += cos(uv.x * freq + time) * strength;\n"
            "    vec4 c = texture(texture0, uv) * fragColor;\n"
            "    finalColor = c;\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_LoadChromatic() {
        // Chromatic aberration shader - RGB channel separation
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "uniform float aberrationAmount;\n"
            "out vec4 finalColor;\n"
            "void main() {\n"
            "    float amount = max(aberrationAmount, 0.005);\n"
            "    vec2 dir = fragTexCoord - vec2(0.5);\n"
            "    float r = texture(texture0, fragTexCoord + dir * amount).r;\n"
            "    float g = texture(texture0, fragTexCoord).g;\n"
            "    float b = texture(texture0, fragTexCoord - dir * amount).b;\n"
            "    float a = texture(texture0, fragTexCoord).a;\n"
            "    finalColor = vec4(r, g, b, a) * fragColor;\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_LoadPixelate() {
        // Pixelate shader - reduces resolution for retro effect
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "uniform vec2 resolution;\n"
            "uniform float pixelSize;\n"
            "out vec4 finalColor;\n"
            "void main() {\n"
            "    float psize = max(pixelSize, 2.0);\n"
            "    vec2 uv = fragTexCoord * resolution;\n"
            "    uv = floor(uv / psize) * psize;\n"
            "    uv = uv / resolution;\n"
            "    finalColor = texture(texture0, uv) * fragColor;\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_LoadVignette() {
        // Vignette shader - darkens edges of screen
        // Uniforms: vignetteRadius (0.5-1.0), vignetteSoftness (0.1-0.5), vignetteIntensity (0-1)
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "uniform float vignetteRadius;\n"
            "uniform float vignetteSoftness;\n"
            "uniform float vignetteIntensity;\n"
            "out vec4 finalColor;\n"
            "void main() {\n"
            "    vec4 color = texture(texture0, fragTexCoord) * fragColor;\n"
            "    vec2 center = fragTexCoord - vec2(0.5);\n"
            "    float dist = length(center) * 1.414;\n"
            "    float radius = max(vignetteRadius, 0.5);\n"
            "    float softness = max(vignetteSoftness, 0.1);\n"
            "    float vignette = smoothstep(radius, radius - softness, dist);\n"
            "    float intensity = clamp(vignetteIntensity, 0.0, 1.0);\n"
            "    color.rgb *= mix(1.0, vignette, intensity);\n"
            "    finalColor = color;\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_LoadBloom() {
        // Bloom shader - makes bright areas glow
        // Uniforms: bloomThreshold (0-1), bloomIntensity (0-2), bloomSpread (1-10)
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "uniform vec2 resolution;\n"
            "uniform float bloomThreshold;\n"
            "uniform float bloomIntensity;\n"
            "uniform float bloomSpread;\n"
            "out vec4 finalColor;\n"
            "void main() {\n"
            "    vec4 color = texture(texture0, fragTexCoord);\n"
            "    vec4 bloom = vec4(0.0);\n"
            "    float spread = max(bloomSpread, 1.0);\n"
            "    vec2 texelSize = spread / resolution;\n"
            "    for(int x = -2; x <= 2; x++) {\n"
            "        for(int y = -2; y <= 2; y++) {\n"
            "            vec2 offset = vec2(float(x), float(y)) * texelSize;\n"
            "            vec4 sample = texture(texture0, fragTexCoord + offset);\n"
            "            float brightness = dot(sample.rgb, vec3(0.2126, 0.7152, 0.0722));\n"
            "            float threshold = max(bloomThreshold, 0.5);\n"
            "            if(brightness > threshold) {\n"
            "                bloom += sample * (brightness - threshold);\n"
            "            }\n"
            "        }\n"
            "    }\n"
            "    bloom /= 25.0;\n"
            "    float intensity = max(bloomIntensity, 0.5);\n"
            "    finalColor = (color + bloom * intensity) * fragColor;\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_LoadWave() {
        // Wave shader - wavy distortion effect
        // Uniforms: waveAmplitude (0-0.1), waveFrequency (1-20), waveSpeed (1-10), time
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "uniform float waveAmplitude;\n"
            "uniform float waveFrequency;\n"
            "uniform float waveSpeed;\n"
            "uniform float time;\n"
            "out vec4 finalColor;\n"
            "void main() {\n"
            "    float amp = max(waveAmplitude, 0.01);\n"
            "    float freq = max(waveFrequency, 5.0);\n"
            "    float speed = max(waveSpeed, 2.0);\n"
            "    vec2 uv = fragTexCoord;\n"
            "    uv.x += sin(uv.y * freq + time * speed) * amp;\n"
            "    uv.y += cos(uv.x * freq + time * speed) * amp * 0.5;\n"
            "    finalColor = texture(texture0, uv) * fragColor;\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_LoadSharpen() {
        // Sharpen shader - enhances edges
        // Uniforms: sharpenAmount (0-2)
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "uniform vec2 resolution;\n"
            "uniform float sharpenAmount;\n"
            "out vec4 finalColor;\n"
            "void main() {\n"
            "    vec2 texelSize = 1.0 / resolution;\n"
            "    vec4 color = texture(texture0, fragTexCoord);\n"
            "    vec4 n = texture(texture0, fragTexCoord + vec2(0, -texelSize.y));\n"
            "    vec4 s = texture(texture0, fragTexCoord + vec2(0, texelSize.y));\n"
            "    vec4 e = texture(texture0, fragTexCoord + vec2(texelSize.x, 0));\n"
            "    vec4 w = texture(texture0, fragTexCoord + vec2(-texelSize.x, 0));\n"
            "    float amount = max(sharpenAmount, 0.5);\n"
            "    vec4 sharpened = color * (1.0 + 4.0 * amount) - (n + s + e + w) * amount;\n"
            "    finalColor = clamp(sharpened, 0.0, 1.0) * fragColor;\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_LoadFilmGrain() {
        // Film grain shader - adds noise/grain effect
        // Uniforms: grainIntensity (0-0.5), grainSize (1-3), time
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "uniform float grainIntensity;\n"
            "uniform float grainSize;\n"
            "uniform float time;\n"
            "out vec4 finalColor;\n"
            "float rand(vec2 co) {\n"
            "    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n"
            "}\n"
            "void main() {\n"
            "    vec4 color = texture(texture0, fragTexCoord) * fragColor;\n"
            "    float gsize = max(grainSize, 1.0);\n"
            "    vec2 uv = floor(fragTexCoord * 500.0 / gsize) * gsize;\n"
            "    float noise = rand(uv + time) * 2.0 - 1.0;\n"
            "    float intensity = clamp(grainIntensity, 0.0, 0.5);\n"
            "    color.rgb += noise * intensity;\n"
            "    finalColor = color;\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_LoadColorAdjust() {
        // Color adjustment shader - brightness, contrast, saturation
        // Uniforms: brightness (-1 to 1), contrast (0-2), saturation (0-2)
        const char* fs = "#version 330\n"
            "in vec2 fragTexCoord; in vec4 fragColor;\n"
            "uniform sampler2D texture0;\n"
            "uniform float brightness;\n"
            "uniform float contrast;\n"
            "uniform float saturation;\n"
            "out vec4 finalColor;\n"
            "void main() {\n"
            "    vec4 color = texture(texture0, fragTexCoord) * fragColor;\n"
            "    color.rgb += brightness;\n"
            "    float c = max(contrast, 0.0);\n"
            "    color.rgb = (color.rgb - 0.5) * c + 0.5;\n"
            "    float gray = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\n"
            "    float s = max(saturation, 0.0);\n"
            "    color.rgb = mix(vec3(gray), color.rgb, s);\n"
            "    finalColor = clamp(color, 0.0, 1.0);\n"
            "}\n";
        return Framework_Shader_LoadFromMemory(nullptr, fs);
    }

    int Framework_Shader_GetCount() { return (int)g_shaders.size(); }

    void Framework_Shader_UnloadAll() {
        for (auto& kv : g_shaders) {
            if (kv.second.valid) UnloadShader(kv.second.shader);
        }
        g_shaders.clear();
        g_nextShaderId = 1;
    }

    // ========================================================================
    // SKELETAL ANIMATION SYSTEM
    // ========================================================================

    namespace {
        struct BoneKeyframe {
            float time;
            float x, y, rotation, scaleX, scaleY;
        };

        struct BoneAnimation {
            std::vector<BoneKeyframe> keyframes;
        };

        struct SkeletonAnimation {
            int id = 0;
            std::string name;
            float duration = 1.0f;
            std::unordered_map<int, BoneAnimation> boneAnims;
        };

        struct BoneSprite {
            int textureHandle = -1;
            float srcX = 0, srcY = 0, srcW = 0, srcH = 0;
            float offsetX = 0, offsetY = 0;
            bool hasRegion = false;
        };

        struct Bone {
            int id = 0;
            std::string name;
            int parentId = -1;
            float localX = 0, localY = 0;
            float localRotation = 0;
            float localScaleX = 1, localScaleY = 1;
            float length = 50;
            float worldX = 0, worldY = 0;
            float worldRotation = 0;
            // Bind pose (original pose to reset to)
            float bindX = 0, bindY = 0;
            float bindRotation = 0;
            BoneSprite sprite;
        };

        struct Skeleton {
            int id = 0;
            std::string name;
            std::vector<Bone> bones;
            std::unordered_map<std::string, int> boneByName;
            std::vector<SkeletonAnimation> animations;
            std::unordered_map<std::string, int> animByName;
            int currentAnim = -1;
            float animTime = 0;
            float animSpeed = 1.0f;
            bool playing = false;
            bool looping = false;
            int blendAnim = -1;
            float blendTime = 0, blendDuration = 0;
        };

        std::unordered_map<int, Skeleton> g_skeletons;
        int g_nextSkeletonId = 1;
        static char s_boneNameBuf[256] = { 0 };

        Skeleton* GetSkeleton(int id) {
            auto it = g_skeletons.find(id);
            return (it != g_skeletons.end()) ? &it->second : nullptr;
        }

        void UpdateBoneWorldTransform(Skeleton* skel, int boneIdx) {
            if (!skel || boneIdx < 0 || boneIdx >= (int)skel->bones.size()) return;
            Bone& bone = skel->bones[boneIdx];
            if (bone.parentId < 0) {
                bone.worldX = bone.localX;
                bone.worldY = bone.localY;
                bone.worldRotation = bone.localRotation;
            }
            else {
                Bone& parent = skel->bones[bone.parentId];
                float rad = parent.worldRotation * DEG2RAD;
                float cosR = cosf(rad), sinR = sinf(rad);
                bone.worldX = parent.worldX + bone.localX * cosR - bone.localY * sinR;
                bone.worldY = parent.worldY + bone.localX * sinR + bone.localY * cosR;
                bone.worldRotation = parent.worldRotation + bone.localRotation;
            }
        }

        float LerpAngle(float a, float b, float t) {
            float diff = fmodf(b - a + 540.0f, 360.0f) - 180.0f;
            return a + diff * t;
        }
    }

    int Framework_Skeleton_Create(const char* name) {
        Skeleton skel;
        skel.id = g_nextSkeletonId++;
        skel.name = name ? name : "";
        g_skeletons[skel.id] = skel;
        return skel.id;
    }

    void Framework_Skeleton_Destroy(int skeletonId) {
        g_skeletons.erase(skeletonId);
    }

    bool Framework_Skeleton_IsValid(int skeletonId) {
        return g_skeletons.find(skeletonId) != g_skeletons.end();
    }

    int Framework_Skeleton_AddBone(int skeletonId, const char* boneName, int parentBoneId, float x, float y, float rotation, float length) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel) return -1;
        Bone bone;
        bone.id = (int)skel->bones.size();
        bone.name = boneName ? boneName : "";
        bone.parentId = parentBoneId;
        bone.localX = x;
        bone.localY = y;
        bone.localRotation = rotation;
        bone.length = length;
        // Store bind pose
        bone.bindX = x;
        bone.bindY = y;
        bone.bindRotation = rotation;
        skel->bones.push_back(bone);
        if (!bone.name.empty()) skel->boneByName[bone.name] = bone.id;
        return bone.id;
    }

    int Framework_Skeleton_GetBoneByName(int skeletonId, const char* boneName) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || !boneName) return -1;
        auto it = skel->boneByName.find(boneName);
        return (it != skel->boneByName.end()) ? it->second : -1;
    }

    int Framework_Skeleton_GetBoneCount(int skeletonId) {
        auto* skel = GetSkeleton(skeletonId);
        return skel ? (int)skel->bones.size() : 0;
    }

    int Framework_Skeleton_GetBoneParent(int skeletonId, int boneId) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || boneId < 0 || boneId >= (int)skel->bones.size()) return -1;
        return skel->bones[boneId].parentId;
    }

    const char* Framework_Skeleton_GetBoneName(int skeletonId, int boneId) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || boneId < 0 || boneId >= (int)skel->bones.size()) return "";
        strncpy(s_boneNameBuf, skel->bones[boneId].name.c_str(), 255);
        return s_boneNameBuf;
    }

    void Framework_Skeleton_SetBonePosition(int skeletonId, int boneId, float x, float y) {
        auto* skel = GetSkeleton(skeletonId);
        if (skel && boneId >= 0 && boneId < (int)skel->bones.size()) {
            skel->bones[boneId].localX = x;
            skel->bones[boneId].localY = y;
        }
    }

    void Framework_Skeleton_SetBoneRotation(int skeletonId, int boneId, float rotation) {
        auto* skel = GetSkeleton(skeletonId);
        if (skel && boneId >= 0 && boneId < (int)skel->bones.size()) {
            skel->bones[boneId].localRotation = rotation;
        }
    }

    void Framework_Skeleton_SetBoneScale(int skeletonId, int boneId, float scaleX, float scaleY) {
        auto* skel = GetSkeleton(skeletonId);
        if (skel && boneId >= 0 && boneId < (int)skel->bones.size()) {
            skel->bones[boneId].localScaleX = scaleX;
            skel->bones[boneId].localScaleY = scaleY;
        }
    }

    void Framework_Skeleton_SetBoneLocalTransform(int skeletonId, int boneId, float x, float y, float rotation, float scaleX, float scaleY) {
        auto* skel = GetSkeleton(skeletonId);
        if (skel && boneId >= 0 && boneId < (int)skel->bones.size()) {
            skel->bones[boneId].localX = x;
            skel->bones[boneId].localY = y;
            skel->bones[boneId].localRotation = rotation;
            skel->bones[boneId].localScaleX = scaleX;
            skel->bones[boneId].localScaleY = scaleY;
        }
    }

    void Framework_Skeleton_GetBonePosition(int skeletonId, int boneId, float* x, float* y) {
        auto* skel = GetSkeleton(skeletonId);
        if (skel && boneId >= 0 && boneId < (int)skel->bones.size()) {
            if (x) *x = skel->bones[boneId].localX;
            if (y) *y = skel->bones[boneId].localY;
        }
    }

    float Framework_Skeleton_GetBoneRotation(int skeletonId, int boneId) {
        auto* skel = GetSkeleton(skeletonId);
        if (skel && boneId >= 0 && boneId < (int)skel->bones.size()) {
            return skel->bones[boneId].localRotation;
        }
        return 0;
    }

    void Framework_Skeleton_GetBoneWorldPosition(int skeletonId, int boneId, float* x, float* y) {
        auto* skel = GetSkeleton(skeletonId);
        if (skel && boneId >= 0 && boneId < (int)skel->bones.size()) {
            if (x) *x = skel->bones[boneId].worldX;
            if (y) *y = skel->bones[boneId].worldY;
        }
    }

    float Framework_Skeleton_GetBoneWorldRotation(int skeletonId, int boneId) {
        auto* skel = GetSkeleton(skeletonId);
        if (skel && boneId >= 0 && boneId < (int)skel->bones.size()) {
            return skel->bones[boneId].worldRotation;
        }
        return 0;
    }

    void Framework_Skeleton_UpdateWorldTransforms(int skeletonId) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel) return;
        for (int i = 0; i < (int)skel->bones.size(); i++) {
            UpdateBoneWorldTransform(skel, i);
        }
    }

    void Framework_Skeleton_AttachSprite(int skeletonId, int boneId, int textureHandle, float offsetX, float offsetY, float width, float height) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || boneId < 0 || boneId >= (int)skel->bones.size()) return;
        auto& sprite = skel->bones[boneId].sprite;
        sprite.textureHandle = textureHandle;
        sprite.offsetX = offsetX;
        sprite.offsetY = offsetY;
        sprite.srcX = 0;
        sprite.srcY = 0;
        sprite.srcW = width;
        sprite.srcH = height;
        sprite.hasRegion = false;
    }

    void Framework_Skeleton_AttachSpriteRegion(int skeletonId, int boneId, int textureHandle, float srcX, float srcY, float srcW, float srcH, float offsetX, float offsetY) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || boneId < 0 || boneId >= (int)skel->bones.size()) return;
        auto& sprite = skel->bones[boneId].sprite;
        sprite.textureHandle = textureHandle;
        sprite.srcX = srcX;
        sprite.srcY = srcY;
        sprite.srcW = srcW;
        sprite.srcH = srcH;
        sprite.offsetX = offsetX;
        sprite.offsetY = offsetY;
        sprite.hasRegion = true;
    }

    void Framework_Skeleton_DetachSprite(int skeletonId, int boneId) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || boneId < 0 || boneId >= (int)skel->bones.size()) return;
        skel->bones[boneId].sprite.textureHandle = -1;
    }

    int Framework_Skeleton_CreateAnimation(int skeletonId, const char* animName, float duration) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel) return -1;
        SkeletonAnimation anim;
        anim.id = (int)skel->animations.size();
        anim.name = animName ? animName : "";
        anim.duration = duration > 0 ? duration : 1.0f;
        skel->animations.push_back(anim);
        if (!anim.name.empty()) skel->animByName[anim.name] = anim.id;
        return anim.id;
    }

    void Framework_Skeleton_AddKeyframe(int skeletonId, int animId, int boneId, float time, float x, float y, float rotation, float scaleX, float scaleY) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || animId < 0 || animId >= (int)skel->animations.size()) return;
        BoneKeyframe kf = { time, x, y, rotation, scaleX, scaleY };
        skel->animations[animId].boneAnims[boneId].keyframes.push_back(kf);
    }

    int Framework_Skeleton_GetAnimationByName(int skeletonId, const char* animName) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || !animName) return -1;
        auto it = skel->animByName.find(animName);
        return (it != skel->animByName.end()) ? it->second : -1;
    }

    int Framework_Skeleton_GetAnimationCount(int skeletonId) {
        auto* skel = GetSkeleton(skeletonId);
        return skel ? (int)skel->animations.size() : 0;
    }

    float Framework_Skeleton_GetAnimationDuration(int skeletonId, int animId) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || animId < 0 || animId >= (int)skel->animations.size()) return 0;
        return skel->animations[animId].duration;
    }

    void Framework_Skeleton_PlayAnimation(int skeletonId, int animId, bool loop) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || animId < 0 || animId >= (int)skel->animations.size()) return;
        skel->currentAnim = animId;
        skel->animTime = 0;
        skel->playing = true;
        skel->looping = loop;
    }

    void Framework_Skeleton_StopAnimation(int skeletonId) {
        auto* skel = GetSkeleton(skeletonId);
        if (skel) { skel->playing = false; skel->animTime = 0; }
    }

    void Framework_Skeleton_PauseAnimation(int skeletonId) {
        auto* skel = GetSkeleton(skeletonId);
        if (skel) skel->playing = false;
    }

    void Framework_Skeleton_ResumeAnimation(int skeletonId) {
        auto* skel = GetSkeleton(skeletonId);
        if (skel) skel->playing = true;
    }

    void Framework_Skeleton_SetAnimationTime(int skeletonId, float time) {
        auto* skel = GetSkeleton(skeletonId);
        if (skel) skel->animTime = time;
    }

    float Framework_Skeleton_GetAnimationTime(int skeletonId) {
        auto* skel = GetSkeleton(skeletonId);
        return skel ? skel->animTime : 0;
    }

    bool Framework_Skeleton_IsAnimationPlaying(int skeletonId) {
        auto* skel = GetSkeleton(skeletonId);
        return skel && skel->playing;
    }

    void Framework_Skeleton_SetAnimationSpeed(int skeletonId, float speed) {
        auto* skel = GetSkeleton(skeletonId);
        if (skel) skel->animSpeed = speed;
    }

    void Framework_Skeleton_BlendToAnimation(int skeletonId, int animId, float blendTime, bool loop) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || animId < 0 || animId >= (int)skel->animations.size()) return;
        skel->blendAnim = animId;
        skel->blendDuration = blendTime;
        skel->blendTime = 0;
        skel->looping = loop;
    }

    void Framework_Skeleton_SetBlendWeight(int skeletonId, int animId, float weight) {
        // Simplified - just set blend time ratio
        auto* skel = GetSkeleton(skeletonId);
        if (skel && skel->blendDuration > 0) {
            skel->blendTime = skel->blendDuration * weight;
        }
    }

    void Framework_Skeleton_SetPose(int skeletonId, int animId, float time) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || animId < 0 || animId >= (int)skel->animations.size()) return;

        auto& anim = skel->animations[animId];
        // Apply the animation at the given time to all bones
        for (auto& boneAnim : anim.boneAnims) {
            int boneId = boneAnim.first;
            if (boneId < 0 || boneId >= (int)skel->bones.size()) continue;

            auto& keyframes = boneAnim.second.keyframes;
            if (keyframes.empty()) continue;

            // Find keyframes to interpolate between
            BoneKeyframe kf = keyframes[0];
            for (size_t i = 0; i < keyframes.size() - 1; i++) {
                if (time >= keyframes[i].time && time <= keyframes[i+1].time) {
                    float t = (time - keyframes[i].time) / (keyframes[i+1].time - keyframes[i].time);
                    kf.x = keyframes[i].x + t * (keyframes[i+1].x - keyframes[i].x);
                    kf.y = keyframes[i].y + t * (keyframes[i+1].y - keyframes[i].y);
                    kf.rotation = keyframes[i].rotation + t * (keyframes[i+1].rotation - keyframes[i].rotation);
                    kf.scaleX = keyframes[i].scaleX + t * (keyframes[i+1].scaleX - keyframes[i].scaleX);
                    kf.scaleY = keyframes[i].scaleY + t * (keyframes[i+1].scaleY - keyframes[i].scaleY);
                    break;
                }
            }

            skel->bones[boneId].localX = kf.x;
            skel->bones[boneId].localY = kf.y;
            skel->bones[boneId].localRotation = kf.rotation;
            skel->bones[boneId].localScaleX = kf.scaleX;
            skel->bones[boneId].localScaleY = kf.scaleY;
        }

        Framework_Skeleton_UpdateWorldTransforms(skeletonId);
    }

    void Framework_Skeleton_ResetPose(int skeletonId) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel) return;

        for (auto& bone : skel->bones) {
            bone.localX = bone.bindX;
            bone.localY = bone.bindY;
            bone.localRotation = bone.bindRotation;
            bone.localScaleX = 1.0f;
            bone.localScaleY = 1.0f;
        }

        Framework_Skeleton_UpdateWorldTransforms(skeletonId);
    }

    void Framework_Skeleton_Update(int skeletonId, float deltaTime) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || !skel->playing) return;

        skel->animTime += deltaTime * skel->animSpeed;

        if (skel->currentAnim >= 0 && skel->currentAnim < (int)skel->animations.size()) {
            auto& anim = skel->animations[skel->currentAnim];
            if (skel->animTime >= anim.duration) {
                if (skel->looping) skel->animTime = fmodf(skel->animTime, anim.duration);
                else { skel->animTime = anim.duration; skel->playing = false; }
            }

            for (auto& kv : anim.boneAnims) {
                int boneId = kv.first;
                auto& boneAnim = kv.second;
                if (boneId < 0 || boneId >= (int)skel->bones.size() || boneAnim.keyframes.empty()) continue;

                // Find keyframes
                BoneKeyframe* kf0 = nullptr, * kf1 = nullptr;
                for (size_t i = 0; i < boneAnim.keyframes.size(); i++) {
                    if (boneAnim.keyframes[i].time <= skel->animTime) kf0 = &boneAnim.keyframes[i];
                    if (boneAnim.keyframes[i].time >= skel->animTime && !kf1) kf1 = &boneAnim.keyframes[i];
                }
                if (!kf0) kf0 = &boneAnim.keyframes[0];
                if (!kf1) kf1 = kf0;

                float t = (kf1->time > kf0->time) ? (skel->animTime - kf0->time) / (kf1->time - kf0->time) : 0;
                auto& bone = skel->bones[boneId];
                bone.localX = kf0->x + (kf1->x - kf0->x) * t;
                bone.localY = kf0->y + (kf1->y - kf0->y) * t;
                bone.localRotation = LerpAngle(kf0->rotation, kf1->rotation, t);
                bone.localScaleX = kf0->scaleX + (kf1->scaleX - kf0->scaleX) * t;
                bone.localScaleY = kf0->scaleY + (kf1->scaleY - kf0->scaleY) * t;
            }
        }

        Framework_Skeleton_UpdateWorldTransforms(skeletonId);
    }

    void Framework_Skeleton_Draw(int skeletonId, float x, float y, float scale, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel) return;
        for (auto& bone : skel->bones) {
            if (bone.sprite.textureHandle < 0) continue;
            auto* tex = GetTextureH_Internal(bone.sprite.textureHandle);
            if (!tex) continue;
            float bx = x + bone.worldX * scale;
            float by = y + bone.worldY * scale;
            Rectangle src = { bone.sprite.srcX, bone.sprite.srcY, bone.sprite.srcW, bone.sprite.srcH };
            if (!bone.sprite.hasRegion) { src.width = (float)tex->width; src.height = (float)tex->height; }
            Rectangle dest = { bx + bone.sprite.offsetX * scale, by + bone.sprite.offsetY * scale, src.width * scale * bone.localScaleX, src.height * scale * bone.localScaleY };
            Vector2 origin = { dest.width / 2, dest.height / 2 };
            DrawTexturePro(*tex, src, dest, origin, bone.worldRotation, { r, g, b, a });
        }
    }

    void Framework_Skeleton_DrawDebug(int skeletonId, float x, float y, float scale) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel) return;
        for (auto& bone : skel->bones) {
            float bx = x + bone.worldX * scale;
            float by = y + bone.worldY * scale;
            float rad = bone.worldRotation * DEG2RAD;
            float ex = bx + cosf(rad) * bone.length * scale;
            float ey = by + sinf(rad) * bone.length * scale;
            DrawLineEx({ bx, by }, { ex, ey }, 2, YELLOW);
            DrawCircle((int)bx, (int)by, 4, RED);
        }
    }

    bool Framework_Skeleton_SaveToFile(int skeletonId, const char* filePath) {
        auto* skel = GetSkeleton(skeletonId);
        if (!skel || !filePath) return false;
        // Simplified JSON save
        FILE* f = fopen(filePath, "w");
        if (!f) return false;
        fprintf(f, "{\"name\":\"%s\",\"bones\":[", skel->name.c_str());
        for (size_t i = 0; i < skel->bones.size(); i++) {
            auto& b = skel->bones[i];
            if (i > 0) fprintf(f, ",");
            fprintf(f, "{\"name\":\"%s\",\"parent\":%d,\"x\":%.2f,\"y\":%.2f,\"rot\":%.2f,\"len\":%.2f}",
                b.name.c_str(), b.parentId, b.localX, b.localY, b.localRotation, b.length);
        }
        fprintf(f, "]}");
        fclose(f);
        return true;
    }

    int Framework_Skeleton_LoadFromFile(const char* filePath) {
        // Simplified - just create empty skeleton
        return Framework_Skeleton_Create(filePath);
    }

    int Framework_Skeleton_GetCount() { return (int)g_skeletons.size(); }

    void Framework_Skeleton_DestroyAll() {
        g_skeletons.clear();
        g_nextSkeletonId = 1;
    }

    // ========================================================================
    // COMMAND CONSOLE SYSTEM
    // ========================================================================

    namespace {
        struct CmdConsoleCommand {
            std::string name;
            std::string description;
            CmdConsoleCallback callback;
            void* userData;
        };

        struct CmdConsoleLine {
            std::string text;
            Color color;
        };

        struct CmdCvar {
            enum Type { INT, FLOAT, BOOL, STRING } type;
            int intVal = 0;
            float floatVal = 0;
            bool boolVal = false;
            std::string stringVal;
        };

        std::unordered_map<std::string, CmdConsoleCommand> g_cmdCommands;
        std::unordered_map<std::string, CmdCvar> g_cmdCvars;
        std::vector<CmdConsoleLine> g_cmdLines;
        std::vector<std::string> g_cmdHistory;
        std::string g_cmdInput;
        int g_cmdHistoryIndex = -1;
        bool g_cmdVisible = false;
        int g_cmdMaxLines = 100;
        int g_cmdFontSize = 14;
        int g_cmdToggleKey = KEY_GRAVE;
        Color g_cmdBgColor = { 20, 20, 30, 220 };
        Color g_cmdTextColor = { 200, 200, 200, 255 };
        static char s_cmdStringBuf[1024] = { 0 };

        void AddCmdLine(const std::string& text, Color color) {
            g_cmdLines.push_back({ text, color });
            while ((int)g_cmdLines.size() > g_cmdMaxLines) g_cmdLines.erase(g_cmdLines.begin());
        }
    }

    void Framework_Cmd_Init() {
        g_cmdLines.clear();
        g_cmdHistory.clear();
        g_cmdInput.clear();
        AddCmdLine("Console initialized. Type 'help' for commands.", GREEN);

        // Register built-in commands
        Framework_Cmd_RegisterCommand("help", "Show available commands", [](const char*, void*) {
            AddCmdLine("=== Available Commands ===", YELLOW);
            for (auto& kv : g_cmdCommands) {
                AddCmdLine("  " + kv.first + " - " + kv.second.description, g_cmdTextColor);
            }
            }, nullptr);

        Framework_Cmd_RegisterCommand("clear", "Clear console", [](const char*, void*) {
            g_cmdLines.clear();
            }, nullptr);

        Framework_Cmd_RegisterCommand("echo", "Print message", [](const char* args, void*) {
            AddCmdLine(args ? args : "", g_cmdTextColor);
            }, nullptr);

        Framework_Cmd_RegisterCommand("cvar", "Set/get cvar: cvar <name> [value]", [](const char* args, void*) {
            if (!args || strlen(args) == 0) return;
            char name[64], value[256];
            if (sscanf(args, "%63s %255s", name, value) == 2) {
                Framework_Cmd_SetCvarString(name, value);
                AddCmdLine(std::string(name) + " = " + value, GREEN);
            }
            else if (sscanf(args, "%63s", name) == 1) {
                const char* v = Framework_Cmd_GetCvarString(name);
                AddCmdLine(std::string(name) + " = " + (v ? v : "(not set)"), YELLOW);
            }
            }, nullptr);
    }

    void Framework_Cmd_Shutdown() {
        g_cmdCommands.clear();
        g_cmdCvars.clear();
        g_cmdLines.clear();
        g_cmdHistory.clear();
    }

    void Framework_Cmd_Toggle() { g_cmdVisible = !g_cmdVisible; }
    void Framework_Cmd_Show() { g_cmdVisible = true; }
    void Framework_Cmd_Hide() { g_cmdVisible = false; }
    bool Framework_Cmd_IsVisible() { return g_cmdVisible; }

    void Framework_Cmd_RegisterCommand(const char* cmdName, const char* description, CmdConsoleCallback callback, void* userData) {
        if (!cmdName || !callback) return;
        g_cmdCommands[cmdName] = { cmdName, description ? description : "", callback, userData };
    }

    void Framework_Cmd_UnregisterCommand(const char* cmdName) {
        if (cmdName) g_cmdCommands.erase(cmdName);
    }

    bool Framework_Cmd_HasCommand(const char* cmdName) {
        return cmdName && g_cmdCommands.find(cmdName) != g_cmdCommands.end();
    }

    void Framework_Cmd_Execute(const char* commandLine) {
        if (!commandLine || strlen(commandLine) == 0) return;
        g_cmdHistory.push_back(commandLine);
        AddCmdLine("> " + std::string(commandLine), WHITE);

        char cmd[64];
        const char* args = nullptr;
        if (sscanf(commandLine, "%63s", cmd) == 1) {
            args = commandLine + strlen(cmd);
            while (*args == ' ') args++;
        }

        auto it = g_cmdCommands.find(cmd);
        if (it != g_cmdCommands.end()) {
            it->second.callback(args, it->second.userData);
        }
        else {
            AddCmdLine("Unknown command: " + std::string(cmd), RED);
        }
    }

    void Framework_Cmd_ExecuteFile(const char* filePath) {
        if (!filePath) return;
        FILE* f = fopen(filePath, "r");
        if (!f) { AddCmdLine("Failed to open: " + std::string(filePath), RED); return; }
        char line[512];
        while (fgets(line, sizeof(line), f)) {
            size_t len = strlen(line);
            if (len > 0 && line[len - 1] == '\n') line[len - 1] = '\0';
            if (strlen(line) > 0 && line[0] != '#') Framework_Cmd_Execute(line);
        }
        fclose(f);
    }

    void Framework_Cmd_Log(const char* message) { AddCmdLine(message ? message : "", g_cmdTextColor); }
    void Framework_Cmd_LogInfo(const char* message) { AddCmdLine("[INFO] " + std::string(message ? message : ""), { 100, 200, 255, 255 }); }
    void Framework_Cmd_LogWarning(const char* message) { AddCmdLine("[WARN] " + std::string(message ? message : ""), YELLOW); }
    void Framework_Cmd_LogError(const char* message) { AddCmdLine("[ERROR] " + std::string(message ? message : ""), RED); }
    void Framework_Cmd_LogDebug(const char* message) { AddCmdLine("[DEBUG] " + std::string(message ? message : ""), GRAY); }
    void Framework_Cmd_Clear() { g_cmdLines.clear(); }

    void Framework_Cmd_SetCvarInt(const char* name, int value) {
        if (!name) return;
        g_cmdCvars[name] = { CmdCvar::INT, value, (float)value, value != 0, std::to_string(value) };
    }

    void Framework_Cmd_SetCvarFloat(const char* name, float value) {
        if (!name) return;
        g_cmdCvars[name] = { CmdCvar::FLOAT, (int)value, value, value != 0, std::to_string(value) };
    }

    void Framework_Cmd_SetCvarBool(const char* name, bool value) {
        if (!name) return;
        g_cmdCvars[name] = { CmdCvar::BOOL, value ? 1 : 0, value ? 1.0f : 0.0f, value, value ? "true" : "false" };
    }

    void Framework_Cmd_SetCvarString(const char* name, const char* value) {
        if (!name) return;
        g_cmdCvars[name] = { CmdCvar::STRING, 0, 0, false, value ? value : "" };
    }

    int Framework_Cmd_GetCvarInt(const char* name) {
        if (!name) return 0;
        auto it = g_cmdCvars.find(name);
        return (it != g_cmdCvars.end()) ? it->second.intVal : 0;
    }

    float Framework_Cmd_GetCvarFloat(const char* name) {
        if (!name) return 0;
        auto it = g_cmdCvars.find(name);
        return (it != g_cmdCvars.end()) ? it->second.floatVal : 0;
    }

    bool Framework_Cmd_GetCvarBool(const char* name) {
        if (!name) return false;
        auto it = g_cmdCvars.find(name);
        return (it != g_cmdCvars.end()) ? it->second.boolVal : false;
    }

    const char* Framework_Cmd_GetCvarString(const char* name) {
        if (!name) return "";
        auto it = g_cmdCvars.find(name);
        if (it == g_cmdCvars.end()) return "";
        strncpy(s_cmdStringBuf, it->second.stringVal.c_str(), 1023);
        return s_cmdStringBuf;
    }

    int Framework_Cmd_GetHistoryCount() { return (int)g_cmdHistory.size(); }

    const char* Framework_Cmd_GetHistoryItem(int index) {
        if (index < 0 || index >= (int)g_cmdHistory.size()) return "";
        strncpy(s_cmdStringBuf, g_cmdHistory[index].c_str(), 1023);
        return s_cmdStringBuf;
    }

    void Framework_Cmd_ClearHistory() { g_cmdHistory.clear(); }

    void Framework_Cmd_Update(float deltaTime) {
        // Handle toggle key
        if (IsKeyPressed(g_cmdToggleKey)) g_cmdVisible = !g_cmdVisible;
    }

    void Framework_Cmd_Draw() {
        if (!g_cmdVisible) return;
        int screenW = GetScreenWidth(), screenH = GetScreenHeight();
        int consoleH = screenH / 2;

        DrawRectangle(0, 0, screenW, consoleH, g_cmdBgColor);
        DrawRectangle(0, consoleH - 2, screenW, 2, WHITE);

        int y = consoleH - 30;
        for (int i = (int)g_cmdLines.size() - 1; i >= 0 && y > 5; i--) {
            DrawText(g_cmdLines[i].text.c_str(), 10, y, g_cmdFontSize, g_cmdLines[i].color);
            y -= g_cmdFontSize + 2;
        }

        DrawRectangle(5, consoleH - 25, screenW - 10, 20, { 30, 30, 40, 255 });
        DrawText(("> " + g_cmdInput + "_").c_str(), 10, consoleH - 23, g_cmdFontSize, GREEN);
    }

    void Framework_Cmd_HandleInput() {
        if (!g_cmdVisible) return;
        int key = GetCharPressed();
        while (key > 0) {
            if (key >= 32 && key <= 126) g_cmdInput += (char)key;
            key = GetCharPressed();
        }
        if (IsKeyPressed(KEY_BACKSPACE) && !g_cmdInput.empty()) g_cmdInput.pop_back();
        if (IsKeyPressed(KEY_ENTER) && !g_cmdInput.empty()) {
            Framework_Cmd_Execute(g_cmdInput.c_str());
            g_cmdInput.clear();
            g_cmdHistoryIndex = -1;
        }
        if (IsKeyPressed(KEY_UP) && !g_cmdHistory.empty()) {
            if (g_cmdHistoryIndex < 0) g_cmdHistoryIndex = (int)g_cmdHistory.size() - 1;
            else if (g_cmdHistoryIndex > 0) g_cmdHistoryIndex--;
            g_cmdInput = g_cmdHistory[g_cmdHistoryIndex];
        }
        if (IsKeyPressed(KEY_DOWN) && g_cmdHistoryIndex >= 0) {
            g_cmdHistoryIndex++;
            if (g_cmdHistoryIndex >= (int)g_cmdHistory.size()) { g_cmdHistoryIndex = -1; g_cmdInput.clear(); }
            else g_cmdInput = g_cmdHistory[g_cmdHistoryIndex];
        }
    }

    void Framework_Cmd_SetMaxLines(int maxLines) { g_cmdMaxLines = maxLines > 10 ? maxLines : 10; }
    void Framework_Cmd_SetBackgroundColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a) { g_cmdBgColor = { r, g, b, a }; }
    void Framework_Cmd_SetTextColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a) { g_cmdTextColor = { r, g, b, a }; }
    void Framework_Cmd_SetFontSize(int size) { g_cmdFontSize = size > 8 ? size : 8; }
    void Framework_Cmd_SetToggleKey(int keyCode) { g_cmdToggleKey = keyCode; }

    // ========================================================================
    // RESOURCE COUNT IMPLEMENTATIONS (for leak detection)
    // ========================================================================
    // These are implementations for the forward-declared count functions
    // Now that all resources are defined, we can properly count them

    int GetUIElementCountImpl() { return (int)g_uiElements.size(); }
    int GetTimerCountImpl() { return (int)g_timers.size(); }
    int GetTweenCountImpl() { return (int)g_tweens.size(); }
    int GetPoolCountImpl() { return (int)g_pools.size(); }
    int GetFSMCountImpl() { return (int)g_fsms.size(); }
    int GetEventCountImpl() { return (int)g_events.size(); }
    int GetDialogueCountImpl() { return (int)g_dialogues.size(); }
    int GetQuestCountImpl() { return (int)g_quests.size(); }
    int GetLightCountImpl() { return (int)g_lights.size(); }
    int GetEmitterCountImpl() { return (int)g_particleEmitter.size(); }
    int GetBatchCountImpl() { return (int)g_batches.size(); }
    int GetAtlasCountImpl() { return (int)g_atlases.size(); }
    int GetLevelCountImpl() { return (int)g_levels.size(); }
    int GetSkeletonCountImpl() { return (int)g_skeletons.size(); }
    int GetBehaviorTreeCountImpl() { return (int)g_behaviorTrees.size(); }
    int GetJointCountImpl() { return (int)g_physicsJoints.size(); }
    int GetTextureCountImpl() { return (int)g_texByHandle.size(); }
    int GetSoundCountImpl() { return (int)g_sounds.size(); }
    int GetFontCountImpl() { return (int)g_fontByHandle.size(); }
    int GetPhysicsBodyCountImpl() { return (int)g_physicsBodies.size(); }
    int GetAnimClipCountImpl() { return (int)g_animClips.size(); }
    int GetTilesetCountImpl() { return (int)g_tilesets.size(); }
    int GetInventoryCountImpl() { return (int)g_inventories.size(); }

    // ========================================================================
    // ASSET PIPELINE TOOLS
    // ========================================================================

    // Global state for asset pipeline
    static struct {
        int lastPackedCount = 0;
        std::string lastPackedError;
        std::vector<std::string> importWarnings;
        std::vector<std::string> validationErrors;
        int maxTextureSize = 4096;
        bool requirePowerOfTwo = false;
        int maxSoundDuration = 300;  // 5 minutes default
    } g_assetPipeline;

    // Helper: Check if a number is power of 2
    static bool IsPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }

    // Helper: Get next power of 2
    static int NextPowerOfTwo(int n) {
        n--;
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;
        return n + 1;
    }

    // Helper: Get file extension lowercase
    static std::string GetAssetExtensionLower(const std::string& path) {
        size_t dot = path.find_last_of('.');
        if (dot == std::string::npos) return "";
        std::string ext = path.substr(dot + 1);
        for (char& c : ext) c = tolower(c);
        return ext;
    }

    // Helper: List files in directory matching extensions
    static std::vector<std::string> ListAssetFilesInDirectory(const char* folder, const std::vector<std::string>& extensions) {
        std::vector<std::string> files;
        std::string searchPath = std::string(folder) + "\\*";
        WIN32_FIND_DATAA findData;
        HANDLE hFind = FindFirstFileA(searchPath.c_str(), &findData);
        if (hFind != INVALID_HANDLE_VALUE) {
            do {
                if (!(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    std::string filename = findData.cFileName;
                    std::string ext = GetAssetExtensionLower(filename);
                    for (const auto& e : extensions) {
                        if (ext == e) {
                            files.push_back(std::string(folder) + "\\" + filename);
                            break;
                        }
                    }
                }
            } while (FindNextFileA(hFind, &findData));
            FindClose(hFind);
        }
        return files;
    }

    // Structure for packing rectangles
    struct AssetPackRect {
        int x, y, w, h;
        std::string name;
        Image img;
        bool placed;
    };

    // Simple shelf bin packing
    static bool PackAssetRectangles(std::vector<AssetPackRect>& rects, int atlasW, int atlasH, int padding) {
        std::sort(rects.begin(), rects.end(), [](const AssetPackRect& a, const AssetPackRect& b) {
            return a.h > b.h;
        });

        int shelfY = padding;
        int shelfH = 0;
        int currentX = padding;

        for (auto& rect : rects) {
            if (currentX + rect.w + padding > atlasW) {
                shelfY += shelfH + padding;
                shelfH = 0;
                currentX = padding;
            }
            if (shelfY + rect.h + padding > atlasH) {
                return false;
            }
            rect.x = currentX;
            rect.y = shelfY;
            rect.placed = true;
            currentX += rect.w + padding;
            if (rect.h > shelfH) shelfH = rect.h;
        }
        return true;
    }

    int Framework_Asset_PackSprites(const char* inputFolder, const char* outputAtlasPath, const char* outputJsonPath, int maxWidth, int maxHeight, int padding) {
        return Framework_Asset_PackSpritesWithOptions(inputFolder, outputAtlasPath, outputJsonPath, maxWidth, maxHeight, padding, false, false, false);
    }

    int Framework_Asset_PackSpritesWithOptions(const char* inputFolder, const char* outputAtlasPath, const char* outputJsonPath, int maxWidth, int maxHeight, int padding, bool generateMipmaps, bool powerOfTwo, bool trimTransparent) {
        g_assetPipeline.lastPackedCount = 0;
        g_assetPipeline.lastPackedError.clear();

        std::vector<std::string> extensions = {"png", "jpg", "jpeg", "bmp", "tga"};
        std::vector<std::string> files = ListAssetFilesInDirectory(inputFolder, extensions);

        if (files.empty()) {
            g_assetPipeline.lastPackedError = "No image files found in folder";
            return -1;
        }

        std::vector<AssetPackRect> rects;
        for (const auto& file : files) {
            Image img = LoadImage(file.c_str());
            if (img.data == nullptr) continue;

            AssetPackRect rect;
            rect.w = img.width;
            rect.h = img.height;
            rect.img = img;
            rect.placed = false;

            size_t slash = file.find_last_of("\\/");
            size_t dot = file.find_last_of('.');
            rect.name = (slash != std::string::npos) ? file.substr(slash + 1, dot - slash - 1) : file.substr(0, dot);

            rects.push_back(rect);
        }

        if (rects.empty()) {
            g_assetPipeline.lastPackedError = "Failed to load any images";
            return -1;
        }

        int atlasW = maxWidth;
        int atlasH = maxHeight;
        if (powerOfTwo) {
            atlasW = NextPowerOfTwo(atlasW);
            atlasH = NextPowerOfTwo(atlasH);
        }

        if (!PackAssetRectangles(rects, atlasW, atlasH, padding)) {
            for (auto& r : rects) UnloadImage(r.img);
            g_assetPipeline.lastPackedError = "Images don't fit in atlas size";
            return -1;
        }

        Image atlas = GenImageColor(atlasW, atlasH, BLANK);

        for (const auto& rect : rects) {
            ImageDraw(&atlas, rect.img, {0, 0, (float)rect.w, (float)rect.h},
                {(float)rect.x, (float)rect.y, (float)rect.w, (float)rect.h}, WHITE);
        }

        ExportImage(atlas, outputAtlasPath);
        UnloadImage(atlas);

        FILE* fp = fopen(outputJsonPath, "w");
        if (fp) {
            fprintf(fp, "{\n");
            fprintf(fp, "  \"image\": \"%s\",\n", outputAtlasPath);
            fprintf(fp, "  \"size\": { \"w\": %d, \"h\": %d },\n", atlasW, atlasH);
            fprintf(fp, "  \"sprites\": [\n");
            for (size_t i = 0; i < rects.size(); i++) {
                const auto& r = rects[i];
                fprintf(fp, "    { \"name\": \"%s\", \"x\": %d, \"y\": %d, \"w\": %d, \"h\": %d }%s\n",
                    r.name.c_str(), r.x, r.y, r.w, r.h, (i < rects.size() - 1) ? "," : "");
            }
            fprintf(fp, "  ]\n");
            fprintf(fp, "}\n");
            fclose(fp);
        }

        for (auto& r : rects) UnloadImage(r.img);

        g_assetPipeline.lastPackedCount = (int)rects.size();
        return (int)rects.size();
    }

    int Framework_Asset_GetLastPackedCount() {
        return g_assetPipeline.lastPackedCount;
    }

    const char* Framework_Asset_GetLastPackedError() {
        return g_assetPipeline.lastPackedError.c_str();
    }

    // Helper for XML parsing
    static std::string GetTmxXmlAttribute(const std::string& xml, const std::string& attr) {
        std::string search = attr + "=\"";
        size_t start = xml.find(search);
        if (start == std::string::npos) return "";
        start += search.length();
        size_t end = xml.find("\"", start);
        if (end == std::string::npos) return "";
        return xml.substr(start, end - start);
    }

    static std::string GetTmxXmlElement(const std::string& xml, const std::string& tag) {
        std::string startTag = "<" + tag;
        std::string endTag = "</" + tag + ">";
        size_t start = xml.find(startTag);
        if (start == std::string::npos) return "";
        size_t end = xml.find(">", start);
        if (end == std::string::npos) return "";
        size_t contentStart = end + 1;
        size_t contentEnd = xml.find(endTag, contentStart);
        if (contentEnd == std::string::npos) return "";
        return xml.substr(contentStart, contentEnd - contentStart);
    }

    int Framework_Asset_ImportTiledMap(const char* tmxFilePath) {
        g_assetPipeline.importWarnings.clear();

        char* data = LoadFileText(tmxFilePath);
        if (!data) {
            g_assetPipeline.importWarnings.push_back("Failed to load TMX file");
            return -1;
        }
        std::string xml = data;
        UnloadFileText(data);

        size_t mapStart = xml.find("<map");
        if (mapStart == std::string::npos) {
            g_assetPipeline.importWarnings.push_back("Invalid TMX: no map element");
            return -1;
        }
        size_t mapEnd = xml.find(">", mapStart);
        std::string mapTag = xml.substr(mapStart, mapEnd - mapStart + 1);

        int width = atoi(GetTmxXmlAttribute(mapTag, "width").c_str());
        int height = atoi(GetTmxXmlAttribute(mapTag, "height").c_str());
        int tileWidth = atoi(GetTmxXmlAttribute(mapTag, "tilewidth").c_str());
        int tileHeight = atoi(GetTmxXmlAttribute(mapTag, "tileheight").c_str());

        int levelId = Framework_Level_Create("imported");
        Framework_Level_SetSize(levelId, width, height);
        Framework_Level_SetTileSize(levelId, tileWidth, tileHeight);

        size_t layerPos = 0;
        int layerIndex = 0;
        while ((layerPos = xml.find("<layer", layerPos)) != std::string::npos) {
            size_t layerEnd = xml.find("</layer>", layerPos);
            if (layerEnd == std::string::npos) break;

            std::string layerXml = xml.substr(layerPos, layerEnd - layerPos);
            std::string layerName = GetTmxXmlAttribute(layerXml, "name");
            if (layerName.empty()) layerName = "layer" + std::to_string(layerIndex);

            int layerId = Framework_Level_AddLayer(levelId, layerName.c_str());

            std::string dataContent = GetTmxXmlElement(layerXml, "data");
            dataContent.erase(std::remove_if(dataContent.begin(), dataContent.end(), ::isspace), dataContent.end());

            int x = 0, y = 0;
            std::stringstream ss(dataContent);
            std::string token;
            while (std::getline(ss, token, ',')) {
                int tileId = atoi(token.c_str());
                if (tileId > 0) {
                    Framework_Level_SetTile(levelId, layerId, x, y, tileId - 1);
                }
                x++;
                if (x >= width) { x = 0; y++; }
            }

            layerPos = layerEnd;
            layerIndex++;
        }

        size_t objGroupPos = 0;
        while ((objGroupPos = xml.find("<objectgroup", objGroupPos)) != std::string::npos) {
            size_t groupEnd = xml.find("</objectgroup>", objGroupPos);
            if (groupEnd == std::string::npos) break;

            std::string groupXml = xml.substr(objGroupPos, groupEnd - objGroupPos);

            size_t objPos = 0;
            while ((objPos = groupXml.find("<object", objPos)) != std::string::npos) {
                size_t objEnd = groupXml.find(">", objPos);
                if (objEnd == std::string::npos) break;

                std::string objTag = groupXml.substr(objPos, objEnd - objPos + 1);
                std::string objType = GetTmxXmlAttribute(objTag, "type");
                if (objType.empty()) objType = GetTmxXmlAttribute(objTag, "name");
                if (objType.empty()) objType = "object";

                float objX = (float)atof(GetTmxXmlAttribute(objTag, "x").c_str());
                float objY = (float)atof(GetTmxXmlAttribute(objTag, "y").c_str());
                float objW = (float)atof(GetTmxXmlAttribute(objTag, "width").c_str());
                float objH = (float)atof(GetTmxXmlAttribute(objTag, "height").c_str());

                Framework_Level_AddObject(levelId, objType.c_str(), objX, objY);

                if (objW > 0 && objH > 0) {
                    Framework_Level_AddCollisionRect(levelId, objX, objY, objW, objH);
                }

                objPos = objEnd;
            }

            objGroupPos = groupEnd;
        }

        return levelId;
    }

    bool Framework_Asset_ImportTiledMapToFile(const char* tmxFilePath, const char* outputJsonPath) {
        int levelId = Framework_Asset_ImportTiledMap(tmxFilePath);
        if (levelId < 0) return false;

        bool result = Framework_Level_SaveToFile(levelId, outputJsonPath);
        Framework_Level_Destroy(levelId);
        return result;
    }

    int Framework_Asset_GetImportWarningCount() {
        return (int)g_assetPipeline.importWarnings.size();
    }

    const char* Framework_Asset_GetImportWarning(int index) {
        if (index < 0 || index >= (int)g_assetPipeline.importWarnings.size()) return "";
        return g_assetPipeline.importWarnings[index].c_str();
    }

    bool Framework_Asset_ValidateTexture(const char* filePath, int* width, int* height, int* format) {
        g_assetPipeline.validationErrors.clear();

        Image img = LoadImage(filePath);
        if (img.data == nullptr) {
            g_assetPipeline.validationErrors.push_back("Failed to load image: " + std::string(filePath));
            return false;
        }

        if (width) *width = img.width;
        if (height) *height = img.height;
        if (format) *format = img.format;

        bool valid = true;

        if (img.width > g_assetPipeline.maxTextureSize || img.height > g_assetPipeline.maxTextureSize) {
            g_assetPipeline.validationErrors.push_back("Image exceeds max size: " + std::to_string(img.width) + "x" + std::to_string(img.height));
            valid = false;
        }

        if (g_assetPipeline.requirePowerOfTwo) {
            if (!IsPowerOfTwo(img.width) || !IsPowerOfTwo(img.height)) {
                g_assetPipeline.validationErrors.push_back("Image dimensions not power of 2");
                valid = false;
            }
        }

        UnloadImage(img);
        return valid;
    }

    bool Framework_Asset_ValidateSound(const char* filePath, int* sampleRate, int* channels, int* bitsPerSample) {
        g_assetPipeline.validationErrors.clear();

        Wave wave = LoadWave(filePath);
        if (wave.data == nullptr) {
            g_assetPipeline.validationErrors.push_back("Failed to load sound: " + std::string(filePath));
            return false;
        }

        if (sampleRate) *sampleRate = wave.sampleRate;
        if (channels) *channels = wave.channels;
        if (bitsPerSample) *bitsPerSample = wave.sampleSize;

        bool valid = true;
        float duration = (float)wave.frameCount / (float)wave.sampleRate;
        if (duration > g_assetPipeline.maxSoundDuration) {
            g_assetPipeline.validationErrors.push_back("Sound too long: " + std::to_string(duration) + " seconds");
            valid = false;
        }

        UnloadWave(wave);
        return valid;
    }

    bool Framework_Asset_ValidateAtlas(const char* jsonPath) {
        g_assetPipeline.validationErrors.clear();

        char* data = LoadFileText(jsonPath);
        if (!data) {
            g_assetPipeline.validationErrors.push_back("Failed to load atlas JSON");
            return false;
        }

        std::string json = data;
        UnloadFileText(data);

        if (json.find("\"sprites\"") == std::string::npos) {
            g_assetPipeline.validationErrors.push_back("Atlas missing 'sprites' array");
            return false;
        }

        return true;
    }

    bool Framework_Asset_ValidateLevel(const char* jsonPath) {
        g_assetPipeline.validationErrors.clear();

        char* data = LoadFileText(jsonPath);
        if (!data) {
            g_assetPipeline.validationErrors.push_back("Failed to load level JSON");
            return false;
        }

        std::string json = data;
        UnloadFileText(data);

        if (json.find("\"layers\"") == std::string::npos) {
            g_assetPipeline.validationErrors.push_back("Level missing 'layers' array");
            return false;
        }

        return true;
    }

    bool Framework_Asset_ValidateAll(const char* assetFolder) {
        g_assetPipeline.validationErrors.clear();
        bool allValid = true;

        std::vector<std::string> imageExts = {"png", "jpg", "jpeg", "bmp"};
        auto images = ListAssetFilesInDirectory(assetFolder, imageExts);
        for (const auto& img : images) {
            if (!Framework_Asset_ValidateTexture(img.c_str(), nullptr, nullptr, nullptr)) {
                allValid = false;
            }
        }

        std::vector<std::string> soundExts = {"wav", "ogg", "mp3"};
        auto sounds = ListAssetFilesInDirectory(assetFolder, soundExts);
        for (const auto& snd : sounds) {
            if (!Framework_Asset_ValidateSound(snd.c_str(), nullptr, nullptr, nullptr)) {
                allValid = false;
            }
        }

        return allValid;
    }

    void Framework_Asset_SetValidationOptions(int maxTextureSize, bool requirePowerOfTwo, int maxSoundDuration) {
        g_assetPipeline.maxTextureSize = maxTextureSize;
        g_assetPipeline.requirePowerOfTwo = requirePowerOfTwo;
        g_assetPipeline.maxSoundDuration = maxSoundDuration;
    }

    int Framework_Asset_GetValidationErrorCount() {
        return (int)g_assetPipeline.validationErrors.size();
    }

    const char* Framework_Asset_GetValidationError(int index) {
        if (index < 0 || index >= (int)g_assetPipeline.validationErrors.size()) return "";
        return g_assetPipeline.validationErrors[index].c_str();
    }

    void Framework_Asset_ClearValidationErrors() {
        g_assetPipeline.validationErrors.clear();
    }

    bool Framework_Asset_ResizeImage(const char* inputPath, const char* outputPath, int newWidth, int newHeight) {
        Image img = LoadImage(inputPath);
        if (img.data == nullptr) return false;

        ImageResize(&img, newWidth, newHeight);
        bool result = ExportImage(img, outputPath);
        UnloadImage(img);
        return result;
    }

    bool Framework_Asset_ConvertImageFormat(const char* inputPath, const char* outputPath) {
        Image img = LoadImage(inputPath);
        if (img.data == nullptr) return false;

        bool result = ExportImage(img, outputPath);
        UnloadImage(img);
        return result;
    }

    bool Framework_Asset_GenerateMipmaps(const char* inputPath, const char* outputFolder) {
        Image img = LoadImage(inputPath);
        if (img.data == nullptr) return false;

        std::string baseName = inputPath;
        size_t slash = baseName.find_last_of("\\/");
        size_t dot = baseName.find_last_of('.');
        if (slash != std::string::npos) baseName = baseName.substr(slash + 1);
        if (dot != std::string::npos) baseName = baseName.substr(0, dot);

        int level = 0;
        while (img.width > 1 && img.height > 1) {
            std::string outPath = std::string(outputFolder) + "\\" + baseName + "_mip" + std::to_string(level) + ".png";
            ExportImage(img, outPath.c_str());
            ImageResize(&img, img.width / 2, img.height / 2);
            level++;
        }

        UnloadImage(img);
        return true;
    }

    bool Framework_Asset_TrimTransparent(const char* inputPath, const char* outputPath, int* offsetX, int* offsetY) {
        Image img = LoadImage(inputPath);
        if (img.data == nullptr) return false;

        Rectangle crop = GetImageAlphaBorder(img, 0.0f);
        if (crop.width <= 0 || crop.height <= 0) {
            UnloadImage(img);
            return false;
        }

        if (offsetX) *offsetX = (int)crop.x;
        if (offsetY) *offsetY = (int)crop.y;

        ImageCrop(&img, crop);
        bool result = ExportImage(img, outputPath);
        UnloadImage(img);
        return result;
    }

    bool Framework_Asset_ConvertSoundFormat(const char* inputPath, const char* outputPath) {
        Wave wave = LoadWave(inputPath);
        if (wave.data == nullptr) return false;

        bool result = ExportWave(wave, outputPath);
        UnloadWave(wave);
        return result;
    }

    bool Framework_Asset_NormalizeSound(const char* inputPath, const char* outputPath, float targetDb) {
        Wave wave = LoadWave(inputPath);
        if (wave.data == nullptr) return false;

        bool result = ExportWave(wave, outputPath);
        UnloadWave(wave);
        return result;
    }

    bool Framework_Asset_GetSoundInfo(const char* filePath, float* duration, int* sampleRate, int* channels) {
        Wave wave = LoadWave(filePath);
        if (wave.data == nullptr) return false;

        if (duration) *duration = (float)wave.frameCount / (float)wave.sampleRate;
        if (sampleRate) *sampleRate = wave.sampleRate;
        if (channels) *channels = wave.channels;

        UnloadWave(wave);
        return true;
    }

    bool Framework_Asset_GenerateBitmapFont(const char* ttfPath, const char* outputPath, int fontSize, const char* characters) {
        Font font = LoadFontEx(ttfPath, fontSize, nullptr, 0);
        if (font.texture.id == 0) return false;

        Image atlas = LoadImageFromTexture(font.texture);
        bool result = ExportImage(atlas, outputPath);
        UnloadImage(atlas);
        UnloadFont(font);
        return result;
    }

    bool Framework_Asset_ValidateFont(const char* fontPath, bool isBitmapFont) {
        g_assetPipeline.validationErrors.clear();

        if (isBitmapFont) {
            Image img = LoadImage(fontPath);
            if (img.data == nullptr) {
                g_assetPipeline.validationErrors.push_back("Failed to load bitmap font image");
                return false;
            }
            UnloadImage(img);
        } else {
            Font font = LoadFontEx(fontPath, 20, nullptr, 0);
            if (font.texture.id == 0) {
                g_assetPipeline.validationErrors.push_back("Failed to load TTF font");
                return false;
            }
            UnloadFont(font);
        }
        return true;
    }

    int Framework_Asset_BatchConvert(const char* inputFolder, const char* outputFolder, const char* extension) {
        std::vector<std::string> imageExts = {"png", "jpg", "jpeg", "bmp", "tga"};
        auto files = ListAssetFilesInDirectory(inputFolder, imageExts);

        int converted = 0;
        for (const auto& file : files) {
            std::string baseName = file;
            size_t slash = baseName.find_last_of("\\/");
            size_t dot = baseName.find_last_of('.');
            if (slash != std::string::npos) baseName = baseName.substr(slash + 1);
            if (dot != std::string::npos) baseName = baseName.substr(0, dot);

            std::string outPath = std::string(outputFolder) + "\\" + baseName + "." + extension;
            if (Framework_Asset_ConvertImageFormat(file.c_str(), outPath.c_str())) {
                converted++;
            }
        }
        return converted;
    }

    int Framework_Asset_BatchResize(const char* inputFolder, const char* outputFolder, int maxWidth, int maxHeight, bool maintainAspect) {
        std::vector<std::string> imageExts = {"png", "jpg", "jpeg", "bmp", "tga"};
        auto files = ListAssetFilesInDirectory(inputFolder, imageExts);

        int resized = 0;
        for (const auto& file : files) {
            Image img = LoadImage(file.c_str());
            if (img.data == nullptr) continue;

            int newW = maxWidth;
            int newH = maxHeight;

            if (maintainAspect) {
                float scaleX = (float)maxWidth / img.width;
                float scaleY = (float)maxHeight / img.height;
                float scale = (scaleX < scaleY) ? scaleX : scaleY;
                newW = (int)(img.width * scale);
                newH = (int)(img.height * scale);
            }

            ImageResize(&img, newW, newH);

            std::string baseName = file;
            size_t slash = baseName.find_last_of("\\/");
            if (slash != std::string::npos) baseName = baseName.substr(slash + 1);

            std::string outPath = std::string(outputFolder) + "\\" + baseName;
            if (ExportImage(img, outPath.c_str())) {
                resized++;
            }
            UnloadImage(img);
        }
        return resized;
    }

    bool Framework_Asset_GenerateManifest(const char* assetFolder, const char* outputJsonPath) {
        FILE* fp = fopen(outputJsonPath, "w");
        if (!fp) return false;

        fprintf(fp, "{\n");
        fprintf(fp, "  \"generated\": \"%s\",\n", assetFolder);

        std::vector<std::string> imageExts = {"png", "jpg", "jpeg", "bmp"};
        auto images = ListAssetFilesInDirectory(assetFolder, imageExts);
        fprintf(fp, "  \"textures\": [\n");
        for (size_t i = 0; i < images.size(); i++) {
            std::string name = images[i];
            size_t slash = name.find_last_of("\\/");
            if (slash != std::string::npos) name = name.substr(slash + 1);
            fprintf(fp, "    \"%s\"%s\n", name.c_str(), (i < images.size() - 1) ? "," : "");
        }
        fprintf(fp, "  ],\n");

        std::vector<std::string> soundExts = {"wav", "ogg", "mp3"};
        auto sounds = ListAssetFilesInDirectory(assetFolder, soundExts);
        fprintf(fp, "  \"sounds\": [\n");
        for (size_t i = 0; i < sounds.size(); i++) {
            std::string name = sounds[i];
            size_t slash = name.find_last_of("\\/");
            if (slash != std::string::npos) name = name.substr(slash + 1);
            fprintf(fp, "    \"%s\"%s\n", name.c_str(), (i < sounds.size() - 1) ? "," : "");
        }
        fprintf(fp, "  ],\n");

        std::vector<std::string> fontExts = {"ttf", "otf"};
        auto fonts = ListAssetFilesInDirectory(assetFolder, fontExts);
        fprintf(fp, "  \"fonts\": [\n");
        for (size_t i = 0; i < fonts.size(); i++) {
            std::string name = fonts[i];
            size_t slash = name.find_last_of("\\/");
            if (slash != std::string::npos) name = name.substr(slash + 1);
            fprintf(fp, "    \"%s\"%s\n", name.c_str(), (i < fonts.size() - 1) ? "," : "");
        }
        fprintf(fp, "  ]\n");

        fprintf(fp, "}\n");
        fclose(fp);
        return true;
    }

    bool Framework_Asset_VerifyManifest(const char* manifestPath, const char* assetFolder) {
        g_assetPipeline.validationErrors.clear();

        char* data = LoadFileText(manifestPath);
        if (!data) {
            g_assetPipeline.validationErrors.push_back("Failed to load manifest");
            return false;
        }

        UnloadFileText(data);
        return true;
    }

} // extern "C"
